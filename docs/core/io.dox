/**
 * @file io.dox
 * @brief Cython definitions and Python wrapper for C++ I/O operations,
 *        primarily focused on reading ROOT files for High Energy Physics analysis.
 * @details This file contains the Cython interface (`.dox` typically implies `.pyx` in this context)
 *          that bridges Python with a C++ backend (`io.h`) responsible for handling
 *          file operations (ROOT, HDF5), metadata management, and data retrieval.
 *          It defines the C++ interface using `cdef extern from` and then implements
 *          a Python class `IO` that wraps the C++ functionality, providing a
 *          user-friendly API for data access and iteration.
 */

// Compiler directives for Cython, specifying C++ language and Python 3 syntax.
// # distutils: language=c++
// # cython: language_level=3

/**
 * @brief Import necessary Cython, C++ standard library, and Python components.
 * @details These imports bring in type definitions and functions required for the interface.
 *          - `libcpp.*`: C++ standard types like `bool`, `map`, `string`, `vector`.
 *          - `AnalysisG.core.*`: Custom C++ types (`data_t`, `meta`, `notification`) and Cython wrappers (`Meta`).
 *          - `tqdm`: Python library for displaying progress bars during iteration.
 *          - `cython.operator`: Utility for dereferencing C++ pointers.
 *          - `AnalysisG.core.tools`: Helper functions for string encoding/decoding (`enc`, `env`, `env_vec`, `enc_list`).
 *          - `AnalysisG.core.structs`: Data structures (`data_t`, `data_enum`) and conversion logic (`switch_board`).
 */
// --- Imports Section Removed ---

/**
 * @brief Declares the external C++ `io` class interface from the `<io/io.h>` header file.
 * @details This block informs Cython about the structure and methods of the C++ class
 *          that will be used. The `nogil` keyword indicates that these C++ methods
 *          release Python's Global Interpreter Lock (GIL), allowing potential parallel
 *          execution in threaded contexts. The `except+` keyword enables automatic
 *          translation of C++ exceptions into Python exceptions.
 */
// cdef extern from "<io/io.h>" nogil:

    /**
     * @brief Definition of the C++ class `io`, inheriting from `notification`.
     * @details This class encapsulates the low-level I/O logic for handling files (ROOT, HDF5),
     *          managing metadata, and providing access to event data. It inherits from
     *          `notification` likely to provide mechanisms for logging or status messages.
     */
    // cdef cppclass io(notification):

        /**
         * @brief C++ constructor for the `io` class.
         * @details Initializes the C++ `io` object.
         * @note Marked `except+ nogil`, indicating it can throw C++ exceptions (translated to Python)
         *       and runs without the Python GIL.
         */
        // io() except+ nogil

        // --- HDF5 Wrappers ---

        /**
         * @brief Starts (opens or creates) an HDF5 file operation.
         * @param filename The path to the HDF5 file.
         * @param read_write The mode for opening the file (e.g., "r", "w", "a").
         * @return bool True if the file operation was started successfully, False otherwise.
         * @note Marked `except+ nogil`.
         */
        // bool start(string filename, string read_write) except+ nogil

        /**
         * @brief Ends (closes) the current HDF5 file operation.
         * @details Finalizes any pending operations and closes the HDF5 file.
         * @note Marked `except+ nogil`.
         */
        // void end() except+ nogil

        /**
         * @brief Retrieves the names of datasets within the currently open HDF5 file.
         * @return vector[string] A vector containing the names of the datasets.
         * @note Marked `except+ nogil`.
         */
        // vector[string] dataset_names() except+ nogil

        /**
         * @brief Checks if a dataset with the given name exists in the HDF5 file.
         * @param name The name of the dataset to check.
         * @return bool True if the dataset exists, False otherwise.
         * @note Marked `except+ nogil`.
         */
        // bool has_dataset_name(string name) except+ nogil

        // --- ROOT Wrappers ---

        /**
         * @brief Gets the number of entries (size) for the configured ROOT TTrees.
         * @return map[string, long] A map where keys are typically filenames or tree identifiers
         *         and values are the corresponding number of entries (long integer).
         * @note Marked `except+ nogil`. Used by `__len__` in the Python wrapper.
         */
        // map[string, long] root_size() except+ nogil

        /**
         * @brief Validates the existence and accessibility of the ROOT file paths provided.
         * @details Checks the paths stored in the `root_files` member map and updates their
         *          associated boolean flags. May also handle directory expansion.
         * @note Marked `except+ nogil`. Called by the `Files` property setter.
         */
        // void check_root_file_paths() except+ nogil

        /**
         * @brief Scans the configured ROOT files to discover their internal structure (Trees, Branches, Leaves).
         * @details Populates the `keys`, `tree_entries`, and `leaf_typed` member maps with information
         *          about the structure found within the files listed in `root_files`.
         * @return bool True if keys were successfully scanned, False otherwise (e.g., no files, no trees found).
         * @note Marked `except+ nogil`. Called by the `Keys` property getter and `ScanKeys` method.
         */
        // bool scan_keys() except+ nogil

        /**
         * @brief Prepares the C++ backend for reading events from the ROOT files.
         * @details Opens the ROOT files, accesses the specified TTrees, sets up TBranch addresses
         *          to point to internal data buffers based on the configured `Branches` and `Leaves`,
         *          and initializes internal counters for iteration.
         * @note Marked `except+ nogil`. Called by `__iter__` and the `begin` method.
         */
        // void root_begin() except+ nogil

        /**
         * @brief Finalizes ROOT file reading and releases associated resources.
         * @details Closes ROOT files, deletes internal TTree/TBranch objects, frees memory buffers,
         *          and resets the C++ backend state related to file reading.
         * @note Marked `except+ nogil`. Called by `__dealloc__`, `__next__` (on StopIteration), and the `end` method.
         */
        // void root_end() except+ nogil

        /**
         * @brief Triggers Particle Change Monitoring (PCM) or similar performance/state monitoring.
         * @details The exact function depends on the C++ implementation, but likely relates to
         *          initializing or interacting with a monitoring system.
         * @note Marked `except+ nogil`. Called during `__cinit__`.
         */
        // void trigger_pcm() except+ nogil

        /**
         * @brief Gets a pointer to the internal C++ map holding the data buffers for the current event.
         * @return map[string, data_t*]* A pointer to a map where keys are branch/leaf names (string)
         *         and values are pointers (`data_t*`) to structures holding the actual data read
         *         from the ROOT file for the current event.
         * @note Marked `except+ nogil`. Called by `__iter__` to get access to the data buffers for `__next__`.
         */
        // map[string, data_t*]* get_data() except+ nogil

        // ------ C++ Member Variables (Parameters) ------- //
        /**
         * @brief Stores the current working path, potentially used for resolving relative file paths.
         */
        // string current_working_path

        /**
         * @brief Stores the designated name of the TTree containing Sum-of-Weights information.
         * @details Used to identify the specific tree for normalization or metadata purposes.
         */
        // string sow_name

        /**
         * @brief Flag to control whether PyAMI (Analysis Metadata Interface) processing is enabled.
         * @details If true, the `MetaData` method will attempt to use PyAMI for richer metadata extraction.
         */
        // bool enable_pyami

        /**
         * @brief Vector storing the names of the TTrees to be processed from the input ROOT files.
         */
        // vector[string] trees

        /**
         * @brief Vector storing the names or patterns of the TBranches to be read from the specified TTrees.
         */
        // vector[string] branches

        /**
         * @brief Vector storing the names of specific TLeaves to be read (allows finer granularity than branches).
         */
        // vector[string] leaves

        /**
         * @brief Map storing the paths of input ROOT files and a boolean indicating their validity/accessibility.
         * @details Keys are file paths (string), values are booleans (true if valid/accessible, false otherwise).
         *          Updated by `check_root_file_paths`.
         */
        // map[string, bool] root_files

        /**
         * @brief Map storing metadata associated with each input file.
         * @details Keys are file paths (string), values are pointers to C++ `meta` objects containing
         *          metadata extracted from the file (e.g., Sum-of-Weights, dataset info). Populated during scanning/setup.
         */
        // map[string, meta*] meta_data

        /**
         * @brief Map storing the number of entries for each TTree within each file.
         * @details Structure: `{ filename : { treename : num_entries } }`. Populated by `scan_keys`.
         */
        // map[string, map[string, long]] tree_entries

        /**
         * @brief Map storing the data type (as a string representation) for each leaf within each TTree.
         * @details Structure: `{ treename : { leafname : type_string } }`. Populated by `scan_keys`.
         */
        // map[string, map[string, string]] leaf_typed

        /**
         * @brief Nested map storing the discovered structure (keys) of the input ROOT files.
         * @details Structure: `{ filename : { treename : { branchname : [leafname1, leafname2, ...] } } }`.
         *          Populated by `scan_keys`. Accessed via the `Keys` property.
         */
        // map[string, map[string, map[string, vector[string]]]] keys

        /**
         * @brief Stores the file path used for caching metadata information.
         * @details If set, the C++ backend might use this path to store/retrieve processed metadata
         *          to speed up subsequent runs.
         */
        // string metacache_path


/**
 * @brief Cython class `IO` providing a Python interface to the C++ `io` backend.
 * @details This class wraps the C++ `io` object (`ptr`) and exposes its functionality
 *          through Python methods and properties. It handles object lifetime (`__cinit__`, `__dealloc__`),
 *          iteration (`__iter__`, `__next__`, `__len__`), configuration (properties like `Files`, `Trees`, `Branches`),
 *          and data/metadata access (`__next__`, `MetaData`). It also manages helper objects like
 *          a progress bar (`prg`) and internal caches (`meta_data`, `fnames`).
 */
// cdef class IO:
    /**
     * @brief Pointer to the underlying C++ `io` object instance.
     * @details This member holds the memory address of the C++ object that performs the actual work.
     */
    // cdef io* ptr

    /**
     * @brief Holds the progress bar object (e.g., from `tqdm`).
     * @details Used to display progress during event iteration via `__iter__` and `__next__`.
     *          Initialized to `None` and created in `__iter__`.
     */
    // cdef object prg // Changed from prg to object prg for clarity

    /**
     * @brief Python dictionary used to cache metadata retrieved from the C++ layer.
     * @details Populated by the `MetaData` method. Keys are file paths (str), values are `Meta` wrapper objects.
     *          This avoids repeated conversion from C++ `meta*` pointers.
     */
    // cdef dict meta_data

    /**
     * @brief C++ map used to cache encoded filenames for efficient progress bar display.
     * @details Stores a mapping from the raw C++ filename string to its Python string representation
     *          to avoid repeated encoding/decoding in the `__next__` loop when updating the progress bar.
     */
    // cdef map[string, string] fnames

    /**
     * @brief Pointer to the C++ map holding the current event's data buffers.
     * @details Obtained from `ptr.get_data()` during `__iter__`. Used by `__next__` to access
     *          the data for the current event entry via `data_t*` pointers.
     */
    // cdef map[string, data_t*]* data_ops

    /**
     * @brief C++ map used internally during iteration to track which branches have finished processing.
     * @details Keys are branch names (string), values are booleans. If `skip[branch_name]` is true,
     *          `__next__` will skip reading data for that branch in the current and subsequent iterations,
     *          as it has reached the end of its entries. Updated within `__next__`.
     */
    // cdef map[string, bool] skip

    // --- Public Methods (cpdef for Python and Cython access) ---

    /**
     * @brief Retrieves metadata associated with the processed files.
     * @details Accesses the C++ `meta_data` map via `ptr`, wraps the C++ `meta` objects
     *          in Python `Meta` objects. If `EnablePyAMI` property is true, it triggers
     *          PyAMI processing within the `Meta` object's initialization (`__meta__`).
     *          The results (Python `Meta` objects keyed by Python file path strings)
     *          are cached in the `self.meta_data` dictionary and returned.
     * @return dict A Python dictionary where keys are file paths (str) and values are
     *         `Meta` objects containing the metadata for each file.
     */
    // cpdef dict MetaData(self)

    /**
     * @brief Initiates a scan of the input ROOT files to discover their structure (Trees, Branches, Leaves).
     * @details Calls the `scan_keys` method on the underlying C++ `io` object (`ptr`).
     *          This populates internal C++ maps (`keys`, `leaf_typed`, `tree_entries`)
     *          with information derived from the files specified via the `Files` property.
     *          The discovered structure can then be accessed conveniently via the `Keys` property.
     *          This method might be called implicitly by the `Keys` property getter if needed.
     */
    // cpdef void ScanKeys(self)

    /**
     * @brief Prepares the ROOT file(s) and C++ backend for event iteration.
     * @details Calls the `root_begin` method on the underlying C++ `io` object (`ptr`).
     *          This involves opening files, accessing specified TTrees (from `Trees` property),
     *          setting up TBranch addresses for requested data (from `Branches`/`Leaves` properties)
     *          to point to internal C++ data buffers (`data_t`), and initializing entry counters.
     *          This method is typically called implicitly by `__iter__` before starting iteration.
     */
    // cpdef void begin(self)

    /**
     * @brief Finalizes ROOT file processing and releases associated C++ resources.
     * @details Calls the `root_end` method on the underlying C++ `io` object (`ptr`).
     *          This ensures proper cleanup by closing ROOT files, deleting internal TTree/TBranch
     *          objects managed by the C++ backend, releasing memory allocated for data buffers,
     *          and resetting the C++ backend's state. This is usually called implicitly by
     *          `__dealloc__` or at the end of iteration in `__next__`.
     */
    // cpdef void end(self)


// --- Implementation Section ---

/**
 * @brief Cython-level constructor for the IO class. Called before `__init__`.
 * @details This is the first step in object creation. It allocates memory for the
 *          underlying C++ `io` object using `new io()` and stores the pointer in `self.ptr`.
 *          It initializes the `self.data_ops` pointer to `NULL` (as data buffers are not yet ready)
 *          and initializes the Python metadata cache `self.meta_data` as an empty dictionary.
 *          It also calls `self.ptr.trigger_pcm()`, likely for initializing performance monitoring
 *          or state tracking in the C++ backend. Handles potential C++ exceptions during
 *          `new io()` via the `except+` mechanism inherited from the C++ declaration.
 */
// def __cinit__(self):

/**
 * @brief Python-level initializer for the IO class. Called after `__cinit__`.
 * @details Initializes Python-specific attributes of the instance. Sets the progress bar
 *          object `self.prg` to `None` initially. It processes the `root` argument,
 *          which specifies the input ROOT files or directories. It uses the `Files`
 *          property setter (`self.Files = root`) to handle the input, allowing `root`
 *          to be either a single file path string or a list of path strings. The setter
 *          will then interact with the C++ backend to validate these paths.
 * @param root Optional[Union[str, List[str]]]. A path string or list of path strings
 *             specifying the ROOT files or directories containing ROOT files to be processed.
 *             Defaults to an empty list (`[]`).
 */
// def __init__(self, root = []):

/**
 * @brief Destructor for the IO class. Called when the Python object is garbage collected.
 * @details Ensures proper cleanup of the associated C++ resources to prevent memory leaks
 *          or dangling file handles. It explicitly calls `self.ptr.root_end()` to finalize
 *          any ongoing ROOT operations and close files gracefully in the C++ backend.
 *          Crucially, it then deletes the C++ `io` object pointed to by `self.ptr` using
 *          `del self.ptr`. This invokes the C++ destructor (`~io()`) and frees the memory
 *          allocated during `__cinit__`.
 */
// def __dealloc__(self):

/**
 * @brief Returns the total number of entries to be iterated over. Used by `len()`.
 * @details Calculates the length based on the information retrieved from the C++ backend.
 *          It calls `self.ptr.root_size()` which returns a C++ map containing entry counts
 *          for the configured files/trees. The implementation iterates through this map
 *          and determines the maximum entry count among all trees being processed. This
 *          assumes that iteration proceeds event-wise up to the length of the longest tree.
 *          Returns 0 if no files/trees are loaded or if the `root_size` map is empty.
 * @return int The maximum number of entries found across all configured TTrees, representing
 *             the total number of iterations expected.
 */
// def __len__(self):

/**
 * @brief Initializes the iterator protocol, preparing the object for use in `for` loops.
 * @details Sets up the necessary state for iterating over events/entries.
 *          - Initializes the progress bar (`self.prg`) using `tqdm` if it hasn't been created yet.
 *            The total number of steps for the progress bar is set using `len(self)`.
 *          - Calls `self.ptr.root_begin()` to prepare the C++ backend for reading data. This
 *            opens files, sets branch addresses to internal buffers, etc.
 *          - Retrieves the pointer to the C++ data map using `self.ptr.get_data()` and stores
 *            it in `self.data_ops` for use by `__next__`.
 *          - Clears the internal C++ `self.skip` map, resetting the status tracking for which
 *            branches have completed their iteration.
 * @return self Returns the iterator object itself, allowing the `for` loop to proceed.
 */
// def __iter__(self):

/**
 * @brief Retrieves the next data entry (event) during iteration. Called repeatedly by `for` loops.
 * @details This method orchestrates fetching data for one event from the C++ backend.
 *          - It iterates through the C++ data map (`self.data_ops`) containing pointers (`data_t*`)
 *            to the data buffers for each active branch/leaf.
 *          - For each branch (`itr.first`) that is not marked to be skipped (`self.skip[itr.first]` is false):
 *              - It calls `switch_board(itr.second)`, a helper function that takes the `data_t*` pointer,
 *                interprets the data type stored within, and converts the C++ data buffer into an
 *                appropriate Python object (e.g., NumPy array, scalar, list of strings).
 *              - The converted Python data is added to the `output` dictionary, keyed by the branch/leaf name.
 *              - It calls `itr.second.next()`. This internal C++ method likely advances the read pointer/index
 *                within that branch's data buffer for the *next* call to `__next__`. It also likely returns
 *                a status indicating if more data is available for that branch, which is used to update
 *                the `self.skip` map for the *next* iteration.
 *              - It stores a pointer (`idx`) to one of the `data_t` objects (usually the first one processed)
 *                to later access common event information like the current filename.
 *          - After checking all branches, if the `output` dictionary is still empty, it means all branches
 *            have been fully read (`skip` is true for all). In this case:
 *              - It calls `self.ptr.root_end()` to clean up C++ resources.
 *              - It resets the progress bar object (`self.prg = None`).
 *              - It raises `StopIteration` to signal the end of the iteration to the `for` loop.
 *          - If data was retrieved (`output` is not empty):
 *              - It retrieves the current filename (`di`, a C++ string) from the stored `data_t` pointer (`idx`).
 *              - It updates the progress bar description (`set_description`) with the current filename.
 *                It uses the `self.fnames` map as a cache to avoid repeated encoding of the C++ filename string
 *                to a Python string (`env(di)`).
 *              - It increments the progress bar by 1 (`self.prg.update(1)`).
 *              - It adds the raw C++ filename string (`di`) to the `output` dictionary under the key `"filename"`.
 * @return dict A dictionary containing the data for the current event. Keys are branch/leaf names (str),
 *              and values are the corresponding data converted to Python types (e.g., NumPy arrays, scalars).
 *              It also includes a `"filename"` key mapping to the C++ `std::string` of the source file for this event.
 * @throw StopIteration When all entries across all configured branches/trees have been processed.
 */
// def __next__(self):

/**
 * @brief Retrieves metadata, optionally processing it with PyAMI. (cpdef implementation)
 * @details Implements the `MetaData` method declared earlier. This version provides the actual logic.
 *          - It first clears the internal Python cache `self.meta_data` to ensure fresh results.
 *          - It then iterates through the C++ metadata map `self.ptr.meta_data`. This map contains
 *            pointers (`meta*`) to C++ objects holding metadata for each file.
 *          - For each entry (C++ file path `itr.first`, C++ `meta*` pointer `itr.second`):
 *              - It creates an instance of the Python `Meta` wrapper class (`data = Meta()`).
 *              - It copies the `metacache_path` setting from the C++ object to the Python wrapper.
 *              - If the `self.EnablePyAMI` property is true, it calls `data.__meta__(itr.second)`.
 *                This special method within the `Meta` class takes the C++ `meta*` pointer, populates
 *                the Python `Meta` object with data from the C++ object, and potentially triggers
 *                further processing using the PyAMI library based on the data found.
 *              - If `self.EnablePyAMI` is false, it likely performs a simpler population without PyAMI.
 *              - It stores the populated Python `Meta` object (`data`) in the `self.meta_data` dictionary.
 *                The key used is the Python string representation of the file path, obtained using `env(itr.first)`.
 * @return dict The populated `self.meta_data` dictionary, containing `Meta` objects keyed by file paths.
 */
// cpdef dict MetaData(self):

    // --- Properties ---

    /**
     * @property Verbose
     * @brief Controls the verbosity level of the underlying C++ notification system.
     * @details
     *   Getter: Returns `True` if the C++ backend is set to produce detailed output (i.e., not "shushed"),
     *           `False` otherwise. It accesses the inverted `shush` flag of the C++ `notification`
     *           base class (`!self.ptr.shush`).
     *   Setter: Sets the verbosity state. Accepts a boolean value. Setting `Verbose = True`
     *           sets the C++ `shush` flag to `False`, enabling messages. Setting `Verbose = False`
     *           sets `shush = True`, suppressing messages.
     * @return bool The current verbosity state (True for verbose, False for quiet).
     * @param val (setter) bool: The desired verbosity state.
     */
    // @property
    // def Verbose(self):
    // @Verbose.setter
    // def Verbose(self, bool val):

    /**
     * @property EnablePyAMI
     * @brief Controls whether PyAMI (Python Analysis Metadata Interface) processing is enabled for metadata extraction.
     * @details
     *   Getter: Returns the current state of the `enable_pyami` flag in the C++ backend (`self.ptr.enable_pyami`).
     *   Setter: Sets the `enable_pyami` flag in the C++ backend. Accepts a boolean value.
     *           Changing this affects subsequent calls to `MetaData()`, determining whether it attempts
     *           richer metadata processing via PyAMI.
     * @return bool True if PyAMI processing is enabled, False otherwise.
     * @param val (setter) bool: The desired state for PyAMI processing.
     */
    // @property
    // def EnablePyAMI(self):
    // @EnablePyAMI.setter
    // def EnablePyAMI(self, val):

    /**
     * @property MetaCachePath
     * @brief Gets or sets the file path used by the C++ backend for caching metadata.
     * @details
     *   Getter: Retrieves the `metacache_path` string from the C++ backend (`self.ptr.metacache_path`),
     *           converts it to a Python string using `env()`, and returns it.
     *   Setter: Accepts a Python string (`val`) representing the desired cache file path. Converts
     *           it to a C++ string using `enc()` and sets the `metacache_path` member in the
     *           C++ backend (`self.ptr.metacache_path`). The C++ backend might use this path
     *           to store/load processed metadata to speed up initialization.
     * @return str The path currently configured for metadata caching.
     * @param val (setter) str: The desired file path for the metadata cache.
     */
    // @property
    // def MetaCachePath(self):
    // @MetaCachePath.setter
    // def MetaCachePath(self, val):

    /**
     * @property Trees
     * @brief Gets or sets the list of TTree names to be processed from the input ROOT files.
     * @details
     *   Getter: Retrieves the `trees` vector (C++ `std::vector<std::string>`) from the C++ backend
     *           (`self.ptr.trees`), converts it to a Python list of strings using `env_vec()`,
     *           and returns it.
     *   Setter: Accepts either a single TTree name (str) or a list of TTree names (list[str]).
     *           It converts the input into a C++ `std::vector<std::string>` using the `enc_list()`
     *           helper function and assigns it to the `trees` member in the C++ backend (`self.ptr.trees`).
     *           Handles type checking to ensure the input is a string or list of strings.
     * @return list[str] A list of the TTree names currently configured for processing.
     * @param val (setter) Union[str, list[str]]: The TTree name(s) to process.
     */
    // @property
    // def Trees(self):
    // @Trees.setter
    // def Trees(self, val):

    /**
     * @property SumOfWeightsTreeName
     * @brief Gets or sets the name of the TTree specifically containing Sum-of-Weights information.
     * @details This is often needed for normalization purposes in physics analysis.
     *   Getter: Retrieves the `sow_name` string from the C++ backend (`self.ptr.sow_name`),
     *           converts it to a Python string using `env()`, and returns it.
     *   Setter: Accepts a Python string (`val`) representing the name of the Sum-of-Weights TTree.
     *           Converts it to a C++ string using `enc()` and sets the `sow_name` member in the
     *           C++ backend (`self.ptr.sow_name`).
     * @return str The name configured for the Sum-of-Weights TTree.
     * @param val (setter) str: The name of the Sum-of-Weights TTree.
     */
    // @property
    // def SumOfWeightsTreeName(self):
    // @SumOfWeightsTreeName.setter
    // def SumOfWeightsTreeName(self, str val):

    /**
     * @property Branches
     * @brief Gets or sets the list of TBranch names (or patterns) to be read from the specified TTrees.
     * @details This determines which data columns will be loaded during iteration.
     *          The C++ backend might support wildcard patterns depending on its implementation.
     *   Getter: Retrieves the `branches` vector from the C++ backend (`self.ptr.branches`),
     *           converts it to a Python list of strings using `env_vec()`, and returns it.
     *   Setter: Accepts either a single TBranch name/pattern (str) or a list (list[str]).
     *           Converts the input into a C++ `std::vector<std::string>` using `enc_list()`
     *           and assigns it to the `branches` member in the C++ backend (`self.ptr.branches`).
     *           Handles type checking for string or list input.
     * @return list[str] A list of the TBranch names/patterns configured for reading.
     * @param val (setter) Union[str, list[str]]: The TBranch name(s) or pattern(s) to read.
     */
    // @property
    // def Branches(self):
    // @Branches.setter
    // def Branches(self, val):

    /**
     * @property Leaves
     * @brief Gets or sets the list of specific TLeaf names to read, allowing finer control than branches.
     * @details Useful when a TBranch contains multiple TLeaves and only specific ones are needed.
     *   Getter: Retrieves the `leaves` vector from the C++ backend (`self.ptr.leaves`),
     *           converts it to a Python list of strings using `env_vec()`, and returns it.
     *   Setter: Accepts either a single TLeaf name (str) or a list (list[str]).
     *           Converts the input into a C++ `std::vector<std::string>` using `enc_list()`
     *           and assigns it to the `leaves` member in the C++ backend (`self.ptr.leaves`).
     *           Handles type checking for string or list input.
     * @return list[str] A list of the specific TLeaf names configured for reading.
     * @param val (setter) Union[str, list[str]]: The TLeaf name(s) to read.
     */
    // @property
    // def Leaves(self):
    // @Leaves.setter
    // def Leaves(self, val):

    /**
     * @property Files
     * @brief Gets or sets the list of input ROOT files or directories containing ROOT files.
     * @details Manages the source data files for the analysis.
     *   Getter: Returns a list of validated input ROOT file paths. It first calls
     *           `self.ptr.check_root_file_paths()` to ensure the C++ backend's file status map
     *           (`root_files`) is up-to-date. It then iterates through this map, converting
     *           each file path (key) to a Python string using `env()` and appending it to the
     *           output list *only* if its associated boolean value in the map is true (indicating
     *           the file is valid and accessible).
     *   Setter: Accepts a single path string or a list of path strings. If the input `val` is empty,
     *           it clears the existing file list in the C++ backend (`self.ptr.root_files.clear()`).
     *           Otherwise, it iterates through the input path(s), converts each to a C++ string using `enc()`,
     *           and adds it to the `self.ptr.root_files` map with an initial status of `False`.
     *           Finally, it calls `self.ptr.check_root_file_paths()`. This C++ method validates
     *           each path, potentially expands directories into constituent ROOT files, and updates
     *           the boolean flags in the `root_files` map accordingly.
     * @return list[str] A list of validated, accessible ROOT file paths.
     * @param val (setter) Union[str, list[str]]: The path(s) to the input ROOT file(s) or directorie(s).
     */
    // @property
    // def Files(self):
    // @Files.setter
    // def Files(self, val):

    /**
     * @property Keys
     * @brief Provides read-only access to the discovered structure (Trees, Branches, Leaves) of the input files.
     * @details Requires the files to have been scanned, which might happen implicitly if not done before.
     *   Getter: Returns a nested Python dictionary representing the file structure. It first ensures
     *           the keys have been scanned by calling `self.ptr.scan_keys()`. It then iterates through
     *           the nested C++ map `self.ptr.keys` (which holds the structure:
     *           `map<string, map<string, map<string, vector<string>>>>`). During iteration, it converts
     *           all C++ strings (filenames, tree names, branch names, leaf names) to Python strings
     *           using `env()` or `env_vec()`. It builds and returns a nested Python dictionary that mirrors
     *           the C++ map structure: `{filepath: {treename: {branchname: [leafname1, ...]}}}`.
     *           Returns an empty dictionary if scanning failed or no keys were found.
     * @return dict A nested dictionary representing the discovered file structure, or an empty dict.
     */
    // @property
    // def Keys(self):

    // --- Method Implementations (already documented with cpdef declarations) ---

    /**
     * @brief Explicitly triggers the key scanning process in the C++ backend.
     * @details Calls `self.ptr.scan_keys()`. See the `cpdef void ScanKeys(self)` documentation block
     *          earlier in the file for more details on what scanning entails (populating internal maps
     *          like `keys`, `tree_entries`, `leaf_typed`). Useful if access to the `Keys` property
     *          or other scan-dependent information is needed before iteration starts.
     */
    // cpdef void ScanKeys(self):

    /**
     * @brief Explicitly prepares the C++ backend for reading data (event iteration).
     * @details Calls `self.ptr.root_begin()`. See the `cpdef void begin(self)` documentation block
     *          earlier in the file for details (opening files, setting branch addresses, etc.).
     *          This is usually called automatically by `__iter__`, but can be called manually
     *          if finer control over the setup process is required.
     */
    // cpdef void begin(self):

    /**
     * @brief Explicitly finalizes processing and releases C++ resources associated with file reading.
     * @details Calls `self.ptr.root_end()`. See the `cpdef void end(self)` documentation block
     *          earlier in the file for details (closing files, freeing buffers, etc.). This is
     *          usually called automatically by `__dealloc__` or at the end of iteration in `__next__`,
     *          but can be called manually to release resources earlier if needed.
     */
    // cpdef void end(self):

