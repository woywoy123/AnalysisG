/**
 * @file plotting.pxd
 * @brief Cython declarations for the C++ plotting library and Python wrapper classes.
 *
 * @details This module defines the interface between the C++ plotting backend
 * (`plotting` class and `roc_t` struct) and the Python plotting classes
 * (`BasePlotting`, `TH1F`, `TH2F`, `TLine`, `ROC`) used within the AnalysisG
 * framework. It leverages Cython to provide efficient bindings, allowing Python
 * code to interact with the high-performance C++ plotting logic. The `nogil`
 * keyword is used extensively for C++ functions to release the Global Interpreter
 * Lock (GIL), enabling potential parallelism.
 */

// distutils: language = c++
// cython: language_level = 3

// --- Cython Imports ---
// (Imports are omitted as requested, but they bring in necessary types
// like notification, tools, C++ standard library types (string, vector, map),
// and Cython utilities.)

// --- C++ External Declarations ---

/**
 * @brief Declaration of the external C++ plotting library header.
 * @details This block declares the C++ entities defined in `<plotting/plotting.h>`.
 * The `nogil` keyword indicates that the GIL can be released when calling
 * these C++ functions, allowing for potential parallelism, especially beneficial
 * for computationally intensive plotting tasks.
 */
cdef extern from "<plotting/plotting.h>" nogil:

    /**
     * @struct roc_t
     * @brief C++ struct to hold data for a single ROC curve component.
     * @details Used internally by the C++ `plotting` class to aggregate
     *          data required for generating Receiver Operating Characteristic curves.
     *          It bundles model information, true labels, and predicted scores.
     */
    cdef struct roc_t:
        /** @var cls
         *  @brief Class index associated with this ROC data point or curve segment. */
        int cls

        /** @var kfold
         *  @brief K-fold index if cross-validation is used, otherwise typically -1. */
        int kfold

        /** @var model
         *  @brief Name or identifier of the machine learning model generating the scores. */
        string model

        /** @var truth
         *  @brief Pointer to a vector of vectors containing the ground truth labels.
         *         The outer vector might represent different datasets or folds,
         *         while the inner vector contains labels for individual samples. */
        vector[vector[int]]* truth

        /** @var scores
         *  @brief Pointer to a vector of vectors containing the predicted scores or probabilities.
         *         Structured similarly to `truth`, aligning scores with labels. */
        vector[vector[double]]* scores

    /**
     * @class plotting
     * @brief C++ class responsible for handling the core plotting logic and data management.
     * @details This class serves as the backend for generating various plot types.
     *          It inherits from `notification` for logging/messaging capabilities and
     *          `tools` for common utility functions. It manages plot data (like histogram
     *          bins, values, errors, ROC data), styling attributes (colors, lines, markers),
     *          and configuration settings (axis ranges, titles, output format).
     *          Methods typically operate `nogil` for performance.
     */
    cdef cppclass plotting(notification, tools):

        /**
         * @brief Constructor for the C++ plotting class.
         * @details Initializes the plotting object. May throw C++ exceptions on failure.
         *          Releases the GIL during execution.
         * @throws C++ exceptions (specific types depend on implementation).
         */
        plotting() except+ nogil

        /**
         * @brief Constructs the full output file path for the plot.
         * @details Combines the `output_path`, `filename`, and `extension` members
         *          to create the complete path where the plot will be saved.
         *          May throw C++ exceptions (e.g., if path components are invalid).
         *          Releases the GIL during execution.
         * @throws C++ exceptions (specific types depend on implementation).
         * @return string The fully constructed output file path.
         */
        string build_path() except+ nogil

        /**
         * @brief Calculates the maximum value for a specified data variable.
         * @details Iterates through the relevant data vector(s) (e.g., `x_data`, `y_data`,
         *          `y_data` + `y_error_up`) to find the maximum value. Used for
         *          determining automatic axis ranges. Releases the GIL.
         * @param var The name of the variable ('x', 'y', 'y_error_up') for which to find the maximum.
         * @throws C++ exceptions (e.g., if `var` is invalid or data is empty).
         * @return float The maximum value found in the specified data.
         */
        float get_max(string var) except+ nogil

        /**
         * @brief Calculates the minimum value for a specified data variable.
         * @details Iterates through the relevant data vector(s) (e.g., `x_data`, `y_data`,
         *          `y_data` - `y_error_down`) to find the minimum value. Used for
         *          determining automatic axis ranges. Releases the GIL.
         * @param var The name of the variable ('x', 'y', 'y_error_down') for which to find the minimum.
         * @throws C++ exceptions (e.g., if `var` is invalid or data is empty).
         * @return float The minimum value found in the specified data.
         */
        float get_min(string var) except+ nogil

        /**
         * @brief Calculates the sum of all weights provided.
         * @details Sums the elements in the `weights` vector. This is often used
         *          for normalization or scaling calculations, especially for histograms.
         *          Releases the GIL.
         * @throws C++ exceptions (specific types depend on implementation, e.g., if weights are invalid).
         * @return float The total sum of the weights. Returns 0 if no weights are present.
         */
        float sum_of_weights() except+ nogil

        /**
         * @brief Placeholder or internal method related to error calculation or building.
         * @details The specific function of this method depends on the C++ implementation.
         *          It might involve calculating statistical errors, propagating uncertainties,
         *          or preparing error representations for plotting. Releases the GIL.
         * @throws C++ exceptions (specific types depend on implementation).
         */
        void build_error() except+ nogil

        /**
         * @brief Adds ROC curve data points to the internal storage.
         * @details Stores the provided true labels and predicted scores, associated with a
         *          given model name and k-fold index, for later processing and plotting
         *          of ROC curves. Uses pointers for efficiency, assuming the data lifetime
         *          is managed externally during the call. Releases the GIL.
         * @param name Identifier for this ROC dataset (e.g., model name or experiment tag).
         * @param kfold The k-fold index (-1 if not applicable).
         * @param label Pointer to the vector of true class labels.
         * @param scores Pointer to the vector of predicted scores/probabilities for each class.
         * @throws C++ exceptions (e.g., memory allocation issues, invalid input).
         */
        void build_ROC(string name, int kfold, vector[int]* label, vector[vector[double]]* scores) except+ nogil

        /**
         * @brief Retrieves the collected ROC data stored internally.
         * @details Returns a vector of `roc_t` structs, each containing the data
         *          added via `build_ROC`. This data is then typically processed by the
         *          Python `ROC` class wrapper to calculate TPR, FPR, and AUC. Releases the GIL.
         * @throws C++ exceptions (specific types depend on implementation).
         * @return vector[roc_t] A vector containing `roc_t` structs with the raw ROC data.
         */
        vector[roc_t] get_ROC() except+ nogil

        // --- Member Variables ---
        // (These variables store the configuration and data for the plot being generated)

        /** @var filename
         *  @brief Base name for the output plot file (without extension). */
        string filename
        /** @var extension
         *  @brief File extension for the output plot (e.g., ".png", ".pdf", ".svg"). */
        string extension
        /** @var output_path
         *  @brief Directory path where the generated plot file will be saved. */
        string output_path

        /** @var title
         *  @brief Main title displayed at the top of the plot. */
        string title
        /** @var ytitle
         *  @brief Label for the Y-axis. */
        string ytitle
        /** @var xtitle
         *  @brief Label for the X-axis. */
        string xtitle
        /** @var style
         *  @brief Plotting style identifier (e.g., "ATLAS", "CMS", "default") influencing overall appearance. */
        string style
        /** @var histfill
         *  @brief Style for filling histograms (e.g., "solid", "hatch", "step"). */
        string histfill
        /** @var overflow
         *  @brief Specifies how to handle histogram overflow bins ("show", "hide", "underflow"). */
        string overflow
        /** @var marker
         *  @brief Marker style for points in scatter plots or line plots (e.g., "o", ".", "s", "^"). */
        string marker
        /** @var linestyle
         *  @brief Line style for line plots (e.g., "-", "--", ":", "-."). */
        string linestyle
        /** @var hatch
         *  @brief Hatch pattern used for filled areas, often in conjunction with `histfill`. */
        string hatch

        /** @var color
         *  @brief Default color for plot elements if not otherwise specified. */
        string color
        /** @var colors
         *  @brief List of colors to cycle through when plotting multiple datasets (e.g., stacked histograms, multiple lines). */
        vector[string] colors

        /** @var stack
         *  @brief If true, stack histograms on top of each other. */
        bool stack
        /** @var density
         *  @brief If true, normalize histograms to unit area (probability density). */
        bool density
        /** @var counts
         *  @brief If true, display bin counts (or values) as text on histogram bins (primarily for TH2F). */
        bool counts
        /** @var x_logarithmic
         *  @brief If true, use a logarithmic scale for the X-axis. */
        bool x_logarithmic
        /** @var y_logarithmic
         *  @brief If true, use a logarithmic scale for the Y-axis. */
        bool y_logarithmic

        /** @var line_width
         *  @brief Width of lines used in the plot. */
        float line_width
        /** @var cap_size
         *  @brief Size of the caps on error bars. */
        float cap_size
        /** @var alpha
         *  @brief Transparency level for plot elements (0.0 fully transparent, 1.0 fully opaque). */
        float alpha
        /** @var x_step
         *  @brief Desired step size between ticks on the X-axis. If 0 or negative, automatic ticking is used. */
        float x_step
        /** @var y_step
         *  @brief Desired step size between ticks on the Y-axis. If 0 or negative, automatic ticking is used. */
        float y_step

        /** @var x_min
         *  @brief Explicitly set minimum value for the X-axis range. Overrides automatic calculation if set. */
        float x_min
        /** @var y_min
         *  @brief Explicitly set minimum value for the Y-axis range. Overrides automatic calculation if set. */
        float y_min
        /** @var x_max
         *  @brief Explicitly set maximum value for the X-axis range. Overrides automatic calculation if set. */
        float x_max
        /** @var y_max
         *  @brief Explicitly set maximum value for the Y-axis range. Overrides automatic calculation if set. */
        float y_max

        /** @var x_bins
         *  @brief Number of bins for the X-axis (used for histograms). */
        int x_bins
        /** @var y_bins
         *  @brief Number of bins for the Y-axis (used for 2D histograms). */
        int y_bins
        /** @var errors
         *  @brief If true, draw error bars or uncertainty bands. */
        bool errors

        /** @var x_data
         *  @brief Vector holding X-axis data points or histogram bin edges/centers. */
        vector[float] x_data
        /** @var y_data
         *  @brief Vector holding Y-axis data points or histogram bin contents. */
        vector[float] y_data

        /** @var roc_data
         *  @brief Internal storage for predicted scores used in ROC curves.
         *         Mapped by model name (string) and then by k-fold index (int).
         *         Stores pointers to the score vectors provided via `build_ROC`. */
        map[string, map[int, vector[vector[double]]*]] roc_data
        /** @var labels
         *  @brief Internal storage for true labels used in ROC curves.
         *         Mapped similarly to `roc_data`, storing pointers to label vectors. */
        map[string, map[int, vector[vector[int]]*]]    labels

        /** @var y_error_up
         *  @brief Vector holding upper uncertainties corresponding to `y_data`. */
        vector[float] y_error_up
        /** @var y_error_down
         *  @brief Vector holding lower uncertainties corresponding to `y_data`. */
        vector[float] y_error_down

        /** @var x_labels
         *  @brief Map allowing custom text labels at specific positions on the X-axis.
         *         Key is the label (string), value is the position (float). */
        unordered_map[string, float] x_labels
        /** @var y_labels
         *  @brief Map allowing custom text labels at specific positions on the Y-axis.
         *         Key is the label (string), value is the position (float). */
        unordered_map[string, float] y_labels

        /** @var variable_x_bins
         *  @brief Vector defining bin edges for variable-width binning on the X-axis.
         *         If non-empty, overrides `x_bins`. */
        vector[float] variable_x_bins
        /** @var variable_y_bins
         *  @brief Vector defining bin edges for variable-width binning on the Y-axis (for TH2F).
         *         If non-empty, overrides `y_bins`. */
        vector[float] variable_y_bins

        /** @var weights
         *  @brief Vector holding weights associated with each data point or histogram entry. */
        vector[float] weights
        /** @var cross_section
         *  @brief Cross-section value (e.g., in pb) used for scaling simulation to data. */
        float cross_section
        /** @var integrated_luminosity
         *  @brief Integrated luminosity value (e.g., in fb^-1) used for scaling simulation to data. */
        float integrated_luminosity

        /** @var font_size
         *  @brief Base font size for text elements in the plot. */
        float font_size
        /** @var axis_size
         *  @brief Font size specifically for axis labels (xtitle, ytitle). */
        float axis_size
        /** @var legend_size
         *  @brief Font size for text within the plot legend. */
        float legend_size
        /** @var title_size
         *  @brief Font size for the main plot title. */
        float title_size
        /** @var use_latex
         *  @brief If true, attempt to use LaTeX for rendering text elements (requires LaTeX installation). */
        bool use_latex

        /** @var dpi
         *  @brief Dots Per Inch resolution for saving raster image formats (like PNG, JPG). */
        int dpi
        /** @var xscaling
         *  @brief Manual scaling factor applied to the X-axis data or range. */
        float xscaling
        /** @var yscaling
         *  @brief Manual scaling factor applied to the Y-axis data or range. */
        float yscaling
        /** @var auto_scale
         *  @brief If true, automatically determine axis ranges based on data min/max.
         *         Can be overridden by explicitly setting x_min, x_max, y_min, y_max. */
        bool auto_scale


// --- Python Wrapper Classes ---

/**
 * @class BasePlotting
 * @brief Base Python class providing common functionality for all plot type wrappers.
 * @details This class acts as an interface between the Python user and the C++ `plotting`
 *          object. It holds a pointer (`ptr`) to the C++ backend instance. It manages
 *          the Matplotlib figure (`_fig`) and axes (`_ax`) objects used for rendering,
 *          imports the necessary Matplotlib module (`matpl`), handles common plot setup
 *          tasks (like figure creation, axis limits), and defines internal helper methods
 *          (`__ticks__`, `__compile__`, `__resetplt__`, `__figure__`) used by subclasses.
 *          It also tracks whether axis limits have been explicitly set by the user.
 */
cdef class BasePlotting:
    /** @var ptr
     *  @brief Pointer to the underlying C++ `plotting` object instance. */
    cdef plotting* ptr
    /** @var matpl
     *  @brief Reference to the imported `matplotlib.pyplot` module (or a compatible interface). */
    cdef matpl
    /** @var _ax
     *  @brief Reference to the Matplotlib `Axes` object where the plot is drawn. */
    cdef _ax
    /** @var _fig
     *  @brief Reference to the Matplotlib `Figure` object containing the axes. */
    cdef _fig

    /** @var set_xmin
     *  @brief Internal flag: True if `x_min` was explicitly set by the user via Python properties. */
    cdef bool set_xmin
    /** @var set_xmax
     *  @brief Internal flag: True if `x_max` was explicitly set by the user via Python properties. */
    cdef bool set_xmax

    /** @var set_ymin
     *  @brief Internal flag: True if `y_min` was explicitly set by the user via Python properties. */
    cdef bool set_ymin
    /** @var set_ymax
     *  @brief Internal flag: True if `y_max` was explicitly set by the user via Python properties. */
    cdef bool set_ymax

    /**
     * @brief Internal helper method to generate tick positions within a range.
     * @details Creates a list of numerical tick locations based on a start, end, and step value.
     *          Used for setting custom axis ticks if `x_step` or `y_step` are provided.
     * @param s The starting value of the range.
     * @param e The ending value of the range.
     * @param st The step size between consecutive ticks.
     * @return list A list of float values representing the calculated tick positions.
     */
    cdef list __ticks__(self, float s, float e, float st)

    /**
     * @brief Internal method to compile plot settings into a dictionary.
     * @details Gathers relevant settings from the C++ `plotting` object (via `ptr`)
     *          and formats them into a Python dictionary. This dictionary is then typically
     *          passed to Matplotlib functions or helper libraries (like mplhep) to configure
     *          the plot appearance. Subclasses override this to add type-specific settings.
     * @param raw If True, may return less processed or formatted data (behavior depends on subclass implementation).
     * @return dict A dictionary containing compiled plot settings (e.g., titles, labels, ranges, styles).
     */
    cdef dict __compile__(self, bool raw = *)

    /**
     * @brief Internal method to reset the Matplotlib state.
     * @details Clears the current Matplotlib figure (`_fig`) and axes (`_ax`) to prepare
     *          for drawing a new plot or updating the existing one. Typically called
     *          before `__figure__` or the main plotting routine.
     */
    cdef void __resetplt__(self)

    /**
     * @brief Internal method to set up the Matplotlib figure and axes.
     * @details Creates or retrieves the Matplotlib figure and axes objects (`_fig`, `_ax`).
     *          Applies common settings like figure size, titles, axis labels, log scales,
     *          and limits based on the compiled settings dictionary.
     * @param com A dictionary of compiled plot settings, usually obtained from `__compile__`.
     *            If not provided, `__compile__` might be called internally.
     */
    cdef void __figure__(self, dict com = *)

/**
 * @class TH1F
 * @brief Python wrapper class for creating and plotting 1-dimensional histograms.
 * @details Simulates the behavior of ROOT's TH1F class. Inherits from `BasePlotting`.
 *          It manages data for one or more 1D histograms, potentially for stacking
 *          or comparison. Provides methods to handle scaling (by luminosity, cross-section,
 *          weights), error calculation/display, and interaction with histogramming libraries.
 *          The actual plotting is performed by the `__build__` method using Matplotlib,
 *          configured via `__compile__` and `__figure__`.
 */
cdef class TH1F(BasePlotting):
    /** @var ApplyScaling
     *  @brief Public flag. If True, the histogram values and errors will be scaled
     *         using the `scale_f` method (based on lumi, xs, weights) before plotting. */
    cdef public bool ApplyScaling
    /** @var Histograms
     *  @brief Public list. Can hold multiple `TH1F` instances, typically used when
     *         stacking histograms or plotting several histograms on the same axes for comparison. */
    cdef public list Histograms
    /** @var Histogram
     *  @brief Public reference to a single `TH1F` instance. Often used to define
     *         the denominator histogram when creating ratio plots. */
    cdef public TH1F Histogram
    /** @var fx
     *  @brief Placeholder for potential future integration with function fitting results. */
    cdef fx

    /**
     * @brief Internal method to draw uncertainty bands on the histogram plot.
     * @details Uses Matplotlib's `fill_between` or similar functions to draw shaded
     *          regions representing the statistical or systematic uncertainties.
     * @param xarr Vector of X-coordinates defining the vertices of the band polygon (often bin edges or centers).
     * @param up Vector of Y-coordinates for the upper edge of the uncertainty band.
     * @param low Vector of Y-coordinates for the lower edge of the uncertainty band.
     * @param label Optional label for the uncertainty band in the legend.
     * @param color Optional color for the uncertainty band fill.
     */
    cdef __error__(self, vector[float] xarr, vector[float] up, vector[float] low, str label = *, str color = *)

    /**
     * @brief Internal helper method related to calculating or retrieving error segments/bands.
     * @details Likely used internally by `__error__` or `__build__` to process uncertainty
     *          data (e.g., from the C++ object or a statistics library) into a format
     *          suitable for plotting the error bands.
     * @param plot The histogram data object (potentially from `hepstats` or similar).
     * @param label Optional label associated with the error source.
     * @param color Optional color associated with the error band.
     */
    cdef __get_error_seg__(self, plot, str label = *, str color = *)

    /**
     * @brief Calculates the scaling factor for the histogram.
     * @details If `ApplyScaling` is True, computes a scale factor based on the
     *          `cross_section`, `integrated_luminosity`, and `sum_of_weights` stored
     *          in the C++ `plotting` object. Typically used to scale Monte Carlo simulation
     *          to expected data yields (Scale = Lumi * XS / SumOfWeights).
     * @return float The calculated scale factor. Returns 1.0 if `ApplyScaling` is False or
     *           if necessary components (lumi, xs, weights) are missing or zero.
     */
    cdef float scale_f(self)

    /**
     * @brief Creates a dictionary representing the histogram data.
     * @details Extracts bin edges, bin values (contents), and uncertainties from the
     *          C++ `plotting` object (`ptr`). Applies scaling using `scale_f` if
     *          `ApplyScaling` is True. Formats the data into a dictionary structure
     *          compatible with libraries like `hist` or `mplhep` for plotting.
     * @return dict A dictionary containing histogram data, typically with keys like
     *           'bins' (edges), 'vals' (contents), and 'unc' (uncertainties).
     */
    cdef dict factory(self)

    /**
     * @brief Internal method responsible for building the final histogram plot.
     * @details This method orchestrates the actual drawing using Matplotlib. It calls
     *          `factory()` to get the prepared data, `__compile__()` for settings,
     *          `__figure__()` to set up the axes. It handles plotting the histogram bars/steps,
     *          drawing error bars/bands (using `__error__`), managing stacked histograms
     *          (iterating through `Histograms`), applying styles, and potentially adding a ratio plot.
     */
    cdef __build__(self)

    /**
     * @brief Overrides `BasePlotting.__compile__` for TH1F specific settings.
     * @details Compiles plot settings relevant to 1D histograms. It retrieves general
     *          settings from the base class method and adds or modifies settings specific
     *          to TH1F, such as histogram styling (`histtype`), stacking information,
     *          scaling status, and data prepared by `factory()`.
     * @param raw If True, may return less processed data (e.g., raw bin contents before scaling). Defaults to False.
     * @return dict A dictionary containing compiled settings tailored for TH1F plotting.
     */
    cdef dict __compile__(self, bool raw = *)

/**
 * @class TH2F
 * @brief Python wrapper class for creating and plotting 2-dimensional histograms.
 * @details Simulates the behavior of ROOT's TH2F class. Inherits from `BasePlotting`.
 *          Manages data (bin edges, contents) for a 2D histogram stored in the C++
 *          `plotting` object. Handles plotting using Matplotlib's `pcolormesh` or
 *          similar functions, including color maps, normalization, and optional display
 *          of bin contents as text.
 */
cdef class TH2F(BasePlotting):
    /** @var ApplyScaling
     *  @brief Public flag. If True, potentially apply scaling to the 2D histogram's
     *         bin contents before plotting (though scaling is less common for TH2F than TH1F). */
    cdef public bool ApplyScaling

    /**
     * @brief Internal method responsible for building the final 2D histogram plot.
     * @details Uses Matplotlib functions (like `pcolormesh`) to draw the 2D histogram.
     *          It retrieves settings from `__compile__()` and data from the C++ object.
     *          Handles setting the color map (`cmap`), normalization (`norm`), color bar,
     *          aspect ratio, and optionally overlays bin contents as text if `counts` is True.
     */
    cdef __build__(self)

    /**
     * @brief Overrides `BasePlotting.__compile__` for TH2F specific settings.
     * @details Compiles plot settings relevant to 2D histograms. Retrieves general settings
     *          and adds TH2F specifics like 2D binning information (X and Y), color map preferences,
     *          normalization range (min/max for the color scale), and whether to display counts.
     * @param raw If True, may return less processed data. Defaults to False.
     * @return dict A dictionary containing compiled settings tailored for TH2F plotting.
     */
    cdef dict __compile__(self, bool raw = *)

/**
 * @class TLine
 * @brief Python wrapper class for plotting lines and scatter plots (TGraph/TLine-like).
 * @details Simulates ROOT's TGraph or TLine functionality. Inherits from `BasePlotting`.
 *          Used for plotting data points (x, y) connected by lines, optionally with markers
 *          at each point and error bars. Can manage multiple lines/scatter sets via the `Lines` list.
 *          Also serves as the base class for `ROC` curves, as they are essentially line plots.
 */
cdef class TLine(BasePlotting):
    /** @var Lines
     *  @brief Public list. Can hold multiple `TLine` instances or data dictionaries,
     *         allowing several lines or scatter plots to be drawn on the same axes. */
    cdef public list Lines
    /** @var ApplyScaling
     *  @brief Public flag. If True, potentially apply scaling to Y-values or errors.
     *         Less common for TLine/TGraph than for histograms, but available. */
    cdef public bool ApplyScaling

    /**
     * @brief Prepares the data for plotting lines or scatter points.
     * @details Organizes the x, y, and optional error data (`y_error_up`, `y_error_down`)
     *          retrieved from the C++ `plotting` object (`ptr`) or from the datasets
     *          contained within the `Lines` list. Ensures data is in a format suitable
     *          for Matplotlib's `plot` or `errorbar` functions.
     */
    cdef void factory(self)

    /**
     * @brief Overrides `BasePlotting.__compile__` for TLine specific settings.
     * @details Compiles settings relevant to line and scatter plots. Retrieves general
     *          settings and adds specifics like line style (`linestyle`), line width (`line_width`),
     *          marker style (`marker`), marker size, color (`color` or `colors`), and error bar
     *          settings (`cap_size`, `errors`). Includes data prepared by `factory()`.
     * @param raw If True, may return less processed data. Defaults to False.
     * @return dict A dictionary containing compiled settings tailored for TLine/scatter plotting.
     */
    cdef dict __compile__(self, bool raw = *)


/**
 * @class ROC
 * @brief Python wrapper class for plotting Receiver Operating Characteristic (ROC) curves.
 * @details Inherits from `TLine` because an ROC curve is fundamentally a line plot
 *          (True Positive Rate vs. False Positive Rate). Adds specialized functionality
 *          for processing multi-class classification results, calculating the Area Under
 *          the Curve (AUC), and formatting the plot accordingly.
 */
cdef class ROC(TLine):
    /** @var num_cls
     *  @brief Number of classes involved in the classification task for which the ROC is generated. */
    cdef int num_cls
    /** @var inits
     *  @brief Internal flag, likely indicating whether the ROC data has been processed by `factory()`. */
    cdef bool inits
    /** @var verbose
     *  @brief Flag to control the level of console output during ROC calculation/processing. */
    cdef bool verbose
    /** @var Binary
     *  @brief Public flag. If True, assumes a binary classification problem, simplifying some calculations. */
    cdef public bool Binary
    /** @var auc
     *  @brief Public dictionary storing the calculated Area Under Curve (AUC) values.
     *         Keys might represent class indices or model names, values are the AUC scores. */
    cdef public dict auc

    /**
     * @brief Overrides `TLine.factory` to process ROC-specific data.
     * @details Retrieves the raw score and label data collected by the C++ object
     *          (via `ptr.get_ROC()`). It then iterates through this data, calculating
     *          the True Positive Rate (TPR) and False Positive Rate (FPR) for various
     *          thresholds for each class (and potentially each k-fold). It computes the
     *          AUC for each curve. The calculated TPR and FPR arrays are stored internally,
     *          effectively becoming the 'x' and 'y' data for the underlying `TLine` plot.
     *          Handles both binary (`Binary=True`) and multi-class scenarios (e.g., one-vs-rest).
     */
    cdef void factory(self)

    /**
     * @brief Overrides `TLine.__compile__` for ROC specific settings and data.
     * @details Compiles settings for plotting ROC curves. It calls the base `TLine.__compile__`
     *          to get general line plot settings. Then, it retrieves the TPR, FPR, and AUC
     *          values calculated by the `factory()` method. It formats this data, potentially
     *          adding AUC scores to legend labels, and includes it in the settings dictionary
     *          passed to the Matplotlib plotting functions. Ensures axes are typically labeled "False Positive Rate"
     *          and "True Positive Rate" and the plot range is [0, 1] for both axes.
     * @param raw If True, may return raw TPR/FPR arrays without formatting. Defaults to False.
     * @return dict A dictionary containing compiled settings and data specifically for ROC curve plotting.
     */
    cdef dict __compile__(self, bool raw = *)/**
 * @file plotting.pyx
 * @brief High-Performance Plotting Module using Matplotlib, Boost-Histogram, and Cython.
 *
 * @details This module provides a Cython-optimized toolkit for generating various scientific plots,
 * primarily focused on histogramming and analysis tasks common in High Energy Physics (HEP).
 * It leverages `matplotlib` for rendering, `boost-histogram` for efficient histogram
 * creation and manipulation, and Cython for performance enhancements by interfacing
 * with underlying C++ structures.
 *
 * Core functionalities include creating 1D and 2D histograms, generating ratio plots
 * to compare histograms, calculating chi-squared differences, plotting line graphs
 * with error bars, and generating Receiver Operating Characteristic (ROC) curves.
 * The module is designed with a class-based structure, where `BasePlotting` provides
 * common attributes and methods, and specialized classes like `TH1F`, `TH2F`, `TLine`,
 * and `ROC` inherit from it.
 */

/**
 * @brief Calculates and plots the ratio of two histograms (H1 / H2).
 * @details Divides the contents of histogram H1 by the contents of histogram H2 bin by bin.
 *          The result, including propagated errors if requested, is stored back into H1.
 *          The function prepares parameters suitable for plotting this ratio using `mplhep.histplot`.
 * @param[out] H1 The numerator histogram (boost_histogram.Histogram). Modified in-place
 *                to hold the ratio values and errors.
 * @param[in] H2 The denominator histogram (boost_histogram.Histogram).
 * @param[in] axis The matplotlib axes (`matplotlib.axes._axes.Axes`) to draw the ratio plot on.
 * @param[in] ylabel Y-axis label for the ratio plot (default: "Ratio").
 * @param[in] normalize If True, normalize histograms by area before calculating the ratio (default: False).
 * @param[in] yerror If True, calculate and display propagated statistical errors on the ratio (default: False).
 * @param[in] this_hist An optional instance of a plotting class (like TH1F)
 *                      to inherit style properties (e.g., FontSize). Defaults to None.
 * @return A dictionary containing plotting parameters for `mplhep.histplot`,
 *         including the modified H1 histogram ('H'), the target axes ('ax'),
 *         color, histtype, and markersize.
 */
def ratio(H1, H2, axis, ylabel="Ratio", normalize=False, yerror=False, this_hist=None):
    # Implementation replaced by documentation
    pass

/**
 * @brief Calculates and plots a chi-squared-like difference ((O-E)/|E|) between two histograms.
 * @details Computes the bin-wise fractional difference between an "observed" histogram (H1)
 *          and an "expected" histogram (H2). The result is stored back into H1.
 *          It also calculates the total chi-squared value for the comparison.
 *          The function prepares parameters suitable for plotting this difference using `mplhep.histplot`.
 * @param[out] H1 The "observed" histogram (O) (boost_histogram.Histogram). Modified in-place
 *                to hold the difference values.
 * @param[in] H2 The "expected" histogram (E) (boost_histogram.Histogram).
 * @param[in] axis The matplotlib axes (`matplotlib.axes._axes.Axes`) to draw the plot on.
 * @param[in] ylabel Y-axis label. Defaults to "Ratio", but the plot shows the fractional difference.
 *                   The default label set internally is "$\\frac{O_i - E_i}{|E_i|}$".
 * @param[in] normalize If True, normalize histograms by area before calculating the difference (default: False).
 * @param[in] yerror If True, includes error bars (though the calculation in the current implementation
 *                   doesn't seem to propagate errors for chi2) (default: False).
 * @param[in] this_hist An optional instance of a plotting class (like TH1F) to inherit style
 *                      properties (e.g., FontSize, Marker). Defaults to None.
 * @return A dictionary containing plotting parameters for `mplhep.histplot`,
 *         including the modified H1 histogram ('H'), the target axes ('ax'),
 *         color, marker style, histtype, markersize, and an additional string ('add')
 *         containing the calculated total chi-squared value.
 */
def chi2(H1, H2, axis, ylabel="Ratio", normalize=False, yerror=False, this_hist=None):
    # Implementation replaced by documentation
    pass

/**
 * @brief Base class providing common plotting functionalities and properties.
 * @details Handles figure/axes creation, styling (via mplhep), saving plots to various
 *          formats (including pickle for the object state), and managing common plot
 *          attributes like titles, labels, axis ranges, log scales, colors, etc. It uses
 *          an underlying C++ `plotting` object (`ptr`) to store configuration.
 */
class BasePlotting:
    /**
     * @fn __init__(self, inpt=None)
     * @brief Initializes the BasePlotting object.
     * @details Sets up default values and optionally loads configuration data from a dictionary `inpt`.
     *          Initializes the connection to the underlying C++ plotting object if applicable.
     * @param[in] inpt Optional dictionary containing initial configuration parameters.
     */
    # def __init__(self, inpt=None): pass # Declaration assumed

    /**
     * @fn __figure__(self, com={"nrows": 1, "ncols": 1})
     * @brief Creates matplotlib figure and axes objects.
     * @details Generates a new figure and a grid of axes based on the provided configuration.
     *          Stores the figure and axes handles within the object.
     * @param[in] com Dictionary specifying the layout (e.g., number of rows/columns).
     */
    # def __figure__(self, com={"nrows": 1, "ncols": 1}): pass # Declaration assumed

    /**
     * @fn __resetplt__(self)
     * @brief Resets matplotlib state and creates a new figure.
     * @details Clears the current matplotlib figure (`plt.clf()`) and calls `__figure__`
     *          to generate a fresh plotting canvas.
     */
    # def __resetplt__(self): pass # Declaration assumed

    /**
     * @fn __compile__(self, raw=False)
     * @brief Placeholder for plot data generation; overridden by subclasses.
     * @details This method is intended to be implemented by derived classes (like TH1F, TH2F)
     *          to prepare the specific data structures needed for plotting (e.g., build histograms).
     * @param[in] raw If True, might return raw data structures instead of plotting directly (subclass dependent).
     * @return Typically None, or raw data if `raw=True` (subclass dependent).
     */
    # def __compile__(self, raw=False): pass # Declaration assumed

    /**
     * @fn dump(self, path="", name="")
     * @brief Saves the object state to a pickle file.
     * @details Serializes the current state of the plotting object (its configuration and potentially data)
     *          into a pickle file for later reloading.
     * @param[in] path Directory where the file should be saved.
     * @param[in] name Base name for the pickle file (defaults to Filename property).
     */
    # def dump(self, path="", name=""): pass # Declaration assumed

    /**
     * @fn load(self, path="", name="")
     * @brief Loads object state from a pickle file.
     * @details Deserializes the object state from a previously saved pickle file, restoring its
     *          configuration and data.
     * @param[in] path Directory where the file is located.
     * @param[in] name Base name of the pickle file to load.
     */
    # def load(self, path="", name=""): pass # Declaration assumed

    /**
     * @fn __add__(self, other)
     * @brief Combines data from another BasePlotting object.
     * @details Intended for combining data, primarily for histogram or line objects.
     *          The exact behavior depends on the subclass implementation (e.g., adding histograms).
     * @param[in] other Another BasePlotting-derived object to combine with this one.
     * @return A new object representing the combination, or modifies self in-place (subclass dependent).
     */
    # def __add__(self, other): pass # Declaration assumed

    /**
     * @fn SaveFigure(self)
     * @brief Configures and saves the generated plot to files.
     * @details Orchestrates the final steps of plotting:
     *          1. Configures matplotlib parameters (fonts, LaTeX usage, etc.).
     *          2. Calls `__compile__` to generate the plot elements.
     *          3. Sets titles, labels, axis scales (log/linear), limits, and ticks.
     *          4. Applies mplhep styles.
     *          5. Saves the figure to various formats (e.g., PDF, PGF) based on object properties.
     */
    # def SaveFigure(self): pass # Declaration assumed

    # --- Properties ---
    /** @property Style
     *  @brief Plot style (e.g., "ATLAS"). Uses `mplhep.style`. */
    # property Style: pass # Declaration assumed

    /** @property Filename
     *  @brief Base name for output files. */
    # property Filename: pass # Declaration assumed

    /** @property OutputDirectory
     *  @brief Directory to save output files. */
    # property OutputDirectory: pass # Declaration assumed

    /** @property DPI
     *  @brief Dots per inch for raster image saving. */
    # property DPI: pass # Declaration assumed

    /** @property FontSize
     *  @brief Base font size. */
    # property FontSize: pass # Declaration assumed

    /** @property AxisSize
     *  @brief Font size for axis labels/ticks. */
    # property AxisSize: pass # Declaration assumed

    /** @property LegendSize
     *  @brief Font size for the legend. */
    # property LegendSize: pass # Declaration assumed

    /** @property TitleSize
     *  @brief Font size for the figure/axes title. */
    # property TitleSize: pass # Declaration assumed

    /** @property UseLateX
     *  @brief Whether to use LaTeX for text rendering. */
    # property UseLateX: pass # Declaration assumed

    /** @property xScaling
     *  @brief Figure width scaling factor. */
    # property xScaling: pass # Declaration assumed

    /** @property yScaling
     *  @brief Figure height scaling factor. */
    # property yScaling: pass # Declaration assumed

    /** @property AutoScaling
     *  @brief Whether axes should autoscale their limits. */
    # property AutoScaling: pass # Declaration assumed

    /** @property Title
     *  @brief Main plot title. Appends total count for TH1F if ShowCount is True. */
    # property Title: pass # Declaration assumed

    /** @property xTitle
     *  @brief X-axis title. */
    # property xTitle: pass # Declaration assumed

    /** @property yTitle
     *  @brief Y-axis title. `<units>` is replaced by bin width for TH1F. */
    # property yTitle: pass # Declaration assumed

    /** @property xLogarithmic
     *  @brief Set logarithmic scale for the X-axis. */
    # property xLogarithmic: pass # Declaration assumed

    /** @property yLogarithmic
     *  @brief Set logarithmic scale for the Y-axis. */
    # property yLogarithmic: pass # Declaration assumed

    /** @property xMin
     *  @brief Manually set the lower limit for the X-axis. */
    # property xMin: pass # Declaration assumed

    /** @property xMax
     *  @brief Manually set the upper limit for the X-axis. */
    # property xMax: pass # Declaration assumed

    /** @property yMin
     *  @brief Manually set the lower limit for the Y-axis. */
    # property yMin: pass # Declaration assumed

    /** @property yMax
     *  @brief Manually set the upper limit for the Y-axis. */
    # property yMax: pass # Declaration assumed

    /** @property xStep
     *  @brief Set specific tick steps for the X-axis. */
    # property xStep: pass # Declaration assumed

    /** @property yStep
     *  @brief Set specific tick steps for the Y-axis. */
    # property yStep: pass # Declaration assumed

    /** @property Color
     *  @brief Default color for the primary plot element. */
    # property Color: pass # Declaration assumed

    /** @property Colors
     *  @brief List of colors for multiple plot elements. */
    # property Colors: pass # Declaration assumed

    /** @property LineStyle
     *  @brief Matplotlib line style string (e.g., '-', '--', ':'). */
    # property LineStyle: pass # Declaration assumed

    /** @property LineWidth
     *  @brief Line width for plot elements. */
    # property LineWidth: pass # Declaration assumed

    /** @property ErrorBars
     *  @brief Whether to display error bars. */
    # property ErrorBars: pass # Declaration assumed

    /** @property CapSize
     *  @brief Size of error bar caps. */
    # property CapSize: pass # Declaration assumed

    /** @property Hatch
     *  @brief Hatch pattern for filled areas (e.g., TH1F uncertainty bands). */
    # property Hatch: pass # Declaration assumed

    /** @property Overflow
     *  @brief How boost-histogram handles overflow ('sum' or 'none'). */
    # property Overflow: pass # Declaration assumed

/**
 * @brief Class for creating and plotting 1D histograms.
 * @details Inherits from `BasePlotting`. Manages 1D data, binning, weights, styling
 *          (including stacking, density normalization), uncertainty bands, and comparison
 *          plots (ratio/chi2). Can hold multiple histograms for comparison or stacking.
 * @inherits BasePlotting
 */
class TH1F(BasePlotting):
    /** @property Histogram
     *  @brief A primary histogram (TH1F instance), often used as data or the numerator/observed
     *         histogram in comparisons. */
    # property Histogram: pass # Declaration assumed

    /** @property Histograms
     *  @brief A list of additional TH1F instances, often used as MC simulations or
     *         denominators/expected histograms for comparison or stacking. */
    # property Histograms: pass # Declaration assumed

    /**
     * @fn __init__(self, inpt=None, **kwargs)
     * @brief Initializes the TH1F object.
     * @details Sets up default values for 1D histogramming and accepts initial data and
     *          configuration via an optional dictionary `inpt` or keyword arguments `kwargs`.
     * @param[in] inpt Optional dictionary containing initial configuration and data.
     * @param[in] kwargs Keyword arguments for configuration and data (e.g., xData, Weights, xBins).
     */
    # def __init__(self, inpt=None, **kwargs): pass # Declaration assumed

    /**
     * @fn __build__(self)
     * @brief Creates a `boost_histogram.Histogram` object from stored data.
     * @details Uses the object's properties (xData, Weights, xBins, xLabels, Overflow, etc.)
     *          to construct and return a `boost_histogram.Histogram` instance. Applies scaling
     *          based on CrossSection and IntegratedLuminosity if ApplyScaling is True.
     * @return A configured `boost_histogram.Histogram` object.
     */
    # def __build__(self): pass # Declaration assumed

    /**
     * @fn __compile__(self, raw=False)
     * @brief Orchestrates the plotting of the 1D histogram(s).
     * @details This method performs the core plotting logic:
     *          1. Builds the primary histogram (`self.Histogram`) and any additional histograms (`self.Histograms`) using `__build__`.
     *          2. Handles stacking if `Stacked` is True.
     *          3. Calculates and prepares uncertainty bands if `ErrorBars` is True (using internal `__error__` and `__get_error_seg__`).
     *          4. Sets up and prepares data for ratio or chi2 comparison plots if `FX` is set, using the module-level `ratio` or `chi2` functions.
     *          5. Calls `mplhep.histplot` to draw the histogram(s) and uncertainty bands onto the main axes.
     *          6. Calls the appropriate function (`ratio` or `chi2`) to draw the comparison plot on the lower axes if applicable.
     * @param[in] raw If True, returns a dictionary of plot arguments prepared for `mplhep.histplot` instead of drawing the plot.
     * @return None, or a dictionary of plot arguments if `raw=True`.
     */
    # def __compile__(self, raw=False): pass # Declaration assumed

    /**
     * @fn KStest(self, TH1F hist)
     * @brief Performs a Kolmogorov-Smirnov test between this histogram and another.
     * @details Compares the distribution of the unbinned `xData` of this histogram
     *          against the `xData` of the provided `hist` object using `scipy.stats.kstest`.
     *          Note: This compares the raw data, not the binned histogram contents.
     * @param[in] hist Another TH1F object whose `xData` will be compared against.
     * @return The result of the `scipy.stats.kstest` function (typically a KS statistic and a p-value).
     */
    # def KStest(self, hist): pass # Declaration assumed

    /**
     * @fn FX(self, val=None)
     * @brief Sets or gets the function used for the lower comparison panel.
     * @details Configures which comparison plot (ratio or chi-squared difference) is generated
     *          in the lower panel when plotting `self.Histogram` against `self.Histograms`.
     * @param[in] val Can be the string "ratio", the string "chi2", a callable function that performs
     *                the comparison, or None to disable the comparison panel. If None is passed
     *                when getting, it returns the currently set function or identifier string.
     * @return The function or identifier string ("ratio", "chi2") currently set for the comparison panel.
     */
    # def FX(self, val=None): pass # Declaration assumed

    # --- Properties Specific to TH1F ---
    /** @property xData
     *  @brief Input data values (list of floats) for the histogram X-axis. */
    # property xData: pass # Declaration assumed

    /** @property Weights
     *  @brief Weights (list of floats) corresponding to xData entries. */
    # property Weights: pass # Declaration assumed

    /** @property xBins
     *  @brief Number of bins (int) or a list/array of bin edges (list[float]). */
    # property xBins: pass # Declaration assumed

    /** @property xLabels
     *  @brief Dictionary for categorical axes {label_str: weight}. If set,
     *         xData/xBins are ignored for axis definition. */
    # property xLabels: pass # Declaration assumed

    /** @property CrossSection
     *  @brief Cross section value (float), used with Lumi for scaling event yields. */
    # property CrossSection: pass # Declaration assumed

    /** @property IntegratedLuminosity
     *  @brief Integrated luminosity value (float), used with CS for scaling event yields. */
    # property IntegratedLuminosity: pass # Declaration assumed

    /** @property ApplyScaling
     *  @brief Internal flag (bool), True if scaling factor (CS * Lumi) should be applied during `__build__`. */
    # property ApplyScaling: pass # Declaration assumed

    /** @property Density
     *  @brief If True (bool), normalize the histogram to unit area. */
    # property Density: pass # Declaration assumed

    /** @property Stacked
     *  @brief If True (bool), histograms in `Histograms` list should be stacked visually. */
    # property Stacked: pass # Declaration assumed

    /** @property HistFill
     *  @brief `histtype` argument for `mplhep.histplot` (e.g., 'fill', 'step'). Controls histogram appearance. */
    # property HistFill: pass # Declaration assumed

    /** @property Marker
     *  @brief Marker style (str) for error bar plots or data points. */
    # property Marker: pass # Declaration assumed

    /** @property Alpha
     *  @brief Transparency level (float, 0.0 to 1.0) for histogram fill/line. */
    # property Alpha: pass # Declaration assumed

    /** @property ShowCount
     *  @brief If True (bool), append the total weighted count (sum of weights) to the plot title. */
    # property ShowCount: pass # Declaration assumed

    /** @property counts
     *  @brief Returns the bin counts (list[float]) of the built histogram (read-only). */
    # property counts: pass # Declaration assumed


/**
 * @brief Class for creating and plotting 2D histograms.
 * @details Inherits from `BasePlotting`. Manages 2D data (xData, yData), binning,
 *          weights, and colormap plotting using `mplhep.hist2dplot`.
 * @inherits BasePlotting
 */
class TH2F(BasePlotting):
    /**
     * @fn __init__(self, inpt=None, **kwargs)
     * @brief Initializes the TH2F object.
     * @details Sets up default values for 2D histogramming and accepts initial data and
     *          configuration via an optional dictionary `inpt` or keyword arguments `kwargs`.
     * @param[in] inpt Optional dictionary containing initial configuration and data.
     * @param[in] kwargs Keyword arguments for configuration and data (e.g., xData, yData, Weights, xBins, yBins).
     */
    # def __init__(self, inpt=None, **kwargs): pass # Declaration assumed

    /**
     * @fn __build__(self)
     * @brief Creates a 2D `boost_histogram.Histogram` object from stored data.
     * @details Uses the object's properties (xData, yData, Weights, xBins, yBins, xLabels, yLabels, Overflow, etc.)
     *          to construct and return a 2D `boost_histogram.Histogram` instance.
     * @return A configured 2D `boost_histogram.Histogram` object.
     */
    # def __build__(self): pass # Declaration assumed

    /**
     * @fn __compile__(self, raw=False)
     * @brief Builds and plots the 2D histogram.
     * @details This method performs the core plotting logic for 2D histograms:
     *          1. Builds the 2D histogram using `__build__`.
     *          2. Calls `mplhep.hist2dplot` to draw the histogram onto the axes using a colormap.
     *          3. Adds a colorbar to the plot.
     * @param[in] raw If True, might return raw data structures instead of plotting (currently seems unused for TH2F).
     * @return None.
     */
    # def __compile__(self, raw=False): pass # Declaration assumed

    # --- Properties Specific to TH2F ---
    /** @property xData
     *  @brief Input data values (list of floats) for the histogram X-axis. */
    # property xData: pass # Declaration assumed

    /** @property yData
     *  @brief Input data values (list of floats) for the histogram Y-axis. */
    # property yData: pass # Declaration assumed

    /** @property Weights
     *  @brief Weights (list of floats) corresponding to (xData, yData) entries. */
    # property Weights: pass # Declaration assumed

    /** @property xBins
     *  @brief Number of bins (int) or a list/array of bin edges (list[float]) for the X-axis. */
    # property xBins: pass # Declaration assumed

    /** @property yBins
     *  @brief Number of bins (int) or a list/array of bin edges (list[float]) for the Y-axis. */
    # property yBins: pass # Declaration assumed

    /** @property xLabels
     *  @brief Dictionary for a categorical X-axis {label_str: weight}. */
    # property xLabels: pass # Declaration assumed

    /** @property yLabels
     *  @brief Dictionary for a categorical Y-axis {label_str: weight}. */
    # property yLabels: pass # Declaration assumed

    /** @property Color
     *  @brief Colormap name (str) (e.g., 'plasma', 'viridis'). Overrides BasePlotting.Color. */
    # property Color: pass # Declaration assumed


/**
 * @brief Class for creating and plotting line graphs (scatter plots with connecting lines).
 * @details Inherits from `BasePlotting`. Manages X-Y data points and optional asymmetric
 *          error bars. Can hold multiple lines (`self.Lines`) for plotting on the same axes.
 * @inherits BasePlotting
 */
class TLine(BasePlotting):
    /** @property Lines
     *  @brief A list of additional TLine objects to plot together on the same axes. */
    # property Lines: pass # Declaration assumed

    /**
     * @fn __init__(self, inpt=None, **kwargs)
     * @brief Initializes the TLine object.
     * @details Sets up default values for line plotting and accepts initial data and
     *          configuration via an optional dictionary `inpt` or keyword arguments `kwargs`.
     * @param[in] inpt Optional dictionary containing initial configuration and data.
     * @param[in] kwargs Keyword arguments for configuration and data (e.g., xData, yData, yDataUp, yDataDown).
     */
    # def __init__(self, inpt=None, **kwargs): pass # Declaration assumed

    /**
     * @fn factory(self)
     * @brief Plots a single line using matplotlib.
     * @details Draws the line represented by this TLine object onto the current axes.
     *          Uses `matplotlib.pyplot.plot` for lines without errors or
     *          `matplotlib.pyplot.errorbar` if `ErrorBars` is True or if `yDataUp`/`yDataDown`
     *          data is provided. Applies styling properties like Color, LineStyle, LineWidth, Marker.
     * @return The result from the `plt.plot` or `plt.errorbar` call (typically a list of Line2D objects).
     */
    # def factory(self): pass # Declaration assumed

    /**
     * @fn __compile__(self, bool raw = False)
     * @brief Plots this line and any additional lines stored in `self.Lines`.
     * @details Orchestrates the plotting for potentially multiple lines:
     *          1. Calls `factory()` for the main TLine object (`self`).
     *          2. Iterates through the `self.Lines` list and calls `factory()` for each TLine object within it.
     *          3. Sets the final axis limits based on all plotted data (unless AutoScaling is False).
     *          4. Creates and displays a legend based on the `Title` property of each plotted line.
     * @param[in] raw This parameter seems unused in the TLine context (inherited).
     * @return None.
     */
    # def __compile__(self, bool raw = False): pass # Declaration assumed

    # --- Properties Specific to TLine ---
    /** @property xData
     *  @brief X coordinates (list[float]) of the points on the line. */
    # property xData: pass # Declaration assumed

    /** @property yData
     *  @brief Y coordinates (list[float]) of the points on the line. */
    # property yData: pass # Declaration assumed

    /** @property yDataUp
     *  @brief Upper vertical error bar lengths (list[float], positive values). Used if ErrorBars=True. */
    # property yDataUp: pass # Declaration assumed

    /** @property yDataDown
     *  @brief Lower vertical error bar lengths (list[float], positive values). Used if ErrorBars=True. */
    # property yDataDown: pass # Declaration assumed

    /** @property Marker
     *  @brief Matplotlib marker style string (e.g., 'o', 's', '.') for the points. */
    # property Marker: pass # Declaration assumed

    /** @property LineWidth
     *  @brief Width of the connecting line. Set to 0 to show only markers. */
    # property LineWidth: pass # Declaration assumed


/**
 * @brief Class for creating and plotting Receiver Operating Characteristic (ROC) curves.
 * @details Inherits from `TLine`. Uses `scikit-learn` (if available) to calculate
 *          True Positive Rate (TPR) vs. False Positive Rate (FPR) from prediction scores
 *          and true labels. Plots multiple ROC curves if multiple sets of scores/truths
 *          are provided. Requires `scikit-learn` to be installed.
 * @inherits TLine
 */
class ROC(TLine):
    /**
     * @fn __init__(self, inpt=None, **kwargs)
     * @brief Initializes the ROC object.
     * @details Sets up default values, including appropriate axis labels ("False Positive Rate", "True Positive Rate")
     *          for ROC curves. Accepts initial configuration via `inpt` or `kwargs`.
     * @param[in] inpt Optional dictionary containing initial configuration.
     * @param[in] kwargs Keyword arguments for configuration (e.g., Scores, Truth).
     */
    # def __init__(self, inpt=None, **kwargs): pass # Declaration assumed

    /**
     * @fn __compile__(self, bool raw = False)
     * @brief Calculates ROC curves and AUC values.
     * @details This method performs the ROC analysis:
     *          1. Uses `sklearn.metrics.roc_curve` to calculate FPR and TPR for each set of
     *             scores and truth labels provided via the `Scores` and `Truth` properties.
     *          2. Uses `sklearn.metrics.auc` to calculate the Area Under the Curve (AUC) for each ROC curve.
     *          3. Stores the calculated FPR, TPR, and AUC values internally.
     *          4. Prepares the calculated FPR/TPR data for plotting using the TLine infrastructure
     *             (assigns them to xData/yData of internal TLine objects).
     *          5. Calls the parent `TLine.__compile__` method to handle the actual plotting of the curves.
     * @param[in] raw This parameter seems unused in the ROC context (inherited).
     * @return None.
     */
    # def __compile__(self, bool raw = False): pass # Declaration assumed

    # --- Properties Specific to ROC ---
    /** @property Scores
     *  @brief Input prediction scores. Can be set using various formats:
     *         - `list[list[float]]`: A list where each inner list contains scores for one class/curve.
     *         - `dict {name: list[list[float]]}`: Scores for different models/sets, keyed by name.
     *         - `dict {name: (cls_idx, list[list[float]])}`: Specify class index if needed (for multi-class).
     *         - `tuple (name, cls_idx, list[list[float]])`: Single score set with name/index.
     *         The setter parses these formats and stores the data internally for processing by `__compile__`. */
    # property Scores: pass # Declaration assumed

    /** @property Truth
     *  @brief Input true labels (e.g., list[int], typically 0 or 1 for binary classification).
     *         Format mirrors `Scores` property (list, dict, or tuple) to match corresponding scores.
     *         The setter parses these formats and stores the data internally. */
    # property Truth: pass # Declaration assumed

    /** @property Titles
     *  @brief List of labels (list[str]) for the different ROC curves plotted, used in the legend.
     *         Often derived from the keys/names provided in the `Scores`/`Truth` dictionaries/tuples. */
    # property Titles: pass # Declaration assumed

    /** @property AUC
     *  @brief Dictionary storing the calculated Area Under Curve (AUC) for each plotted ROC curve,
     *         keyed by an internal identifier or index (read-only). Populated after `__compile__` is called. */
    # property AUC: pass # Declaration assumed

    /** @property xData
     *  @brief Disabled for direct setting in ROC; derived from Scores/Truth (read-only None). */
    # property xData: pass # Declaration assumed

    /** @property yData
     *  @brief Disabled for direct setting in ROC; derived from Scores/Truth (read-only None). */
    # property yData: pass # Declaration assumed

# distutils: language = c++
# cython: language_level = 3

from AnalysisG.core.notification cimport notification
from AnalysisG.core.tools cimport *
from libcpp.string cimport string
from libcpp.vector cimport vector
from libcpp.unordered_map cimport unordered_map
from libcpp.map cimport map
from libcpp cimport bool, float

from cython.operator cimport dereference as deref
from cython.parallel import prange

cdef extern from "<plotting/plotting.h>" nogil:

    cdef struct roc_t:
        int cls
        int kfold
        string model
        vector[vector[int]]*     truth
        vector[vector[double]]* scores

    cdef cppclass plotting(notification, tools):
        plotting() except+ nogil
        string build_path() except+ nogil
        float get_max(string) except+ nogil
        float get_min(string) except+ nogil
        float sum_of_weights() except+ nogil
        void build_error() except+ nogil
        void build_ROC(string name, int kfold, vector[int]* label, vector[vector[double]]* scores) except+ nogil
        vector[roc_t] get_ROC() except+ nogil

        string filename
        string extension
        string output_path

        string title
        string ytitle
        string xtitle
        string style
        string histfill
        string overflow
        string marker
        string linestyle
        string hatch

        string color
        vector[string] colors

        bool stack
        bool density
        bool counts
        bool x_logarithmic
        bool y_logarithmic

        float line_width
        float cap_size
        float alpha
        float x_step
        float y_step

        float x_min
        float y_min
        float x_max
        float y_max

        int x_bins
        int y_bins
        bool errors

        vector[float] x_data
        vector[float] y_data

        map[string, map[int, vector[vector[double]]*]] roc_data
        map[string, map[int, vector[vector[int]]*]]    labels


        vector[float] y_error_up
        vector[float] y_error_down

        unordered_map[string, float] x_labels
        unordered_map[string, float] y_labels

        vector[float] variable_x_bins
        vector[float] variable_y_bins

        vector[float] weights
        float cross_section
        float integrated_luminosity

        float font_size
        float axis_size
        float legend_size
        float title_size
        bool use_latex

        int dpi
        float xscaling
        float yscaling
        bool auto_scale

cdef class BasePlotting:
    cdef plotting* ptr
    cdef matpl
    cdef _ax
    cdef _fig

    cdef bool set_xmin
    cdef bool set_xmax

    cdef bool set_ymin
    cdef bool set_ymax

    cdef list __ticks__(self, float s, float e, float st)
    cdef dict __compile__(self, bool raw = *)
    cdef void __resetplt__(self)
    cdef void __figure__(self, dict com = *)

cdef class TH1F(BasePlotting):
    cdef public bool ApplyScaling
    cdef public list Histograms
    cdef public TH1F Histogram
    cdef fx

    cdef __error__(self, vector[float] xarr, vector[float] up, vector[float] low, str label = *, str color = *)
    cdef __get_error_seg__(self, plot, str label = *, str color = *)

    cdef float scale_f(self)
    cdef dict factory(self)
    cdef __build__(self)
    cdef dict __compile__(self, bool raw = *)

cdef class TH2F(BasePlotting):
    cdef public bool ApplyScaling
    cdef __build__(self)
    cdef dict __compile__(self, bool raw = *)

cdef class TLine(BasePlotting):
    cdef public list Lines
    cdef public bool ApplyScaling

    cdef void factory(self)
    cdef dict __compile__(self, bool raw = *)


cdef class ROC(TLine):
    cdef int num_cls
    cdef bool inits
    cdef bool verbose
    cdef public bool Binary
    cdef public dict auc

    cdef void factory(self)
    cdef dict __compile__(self, bool raw = *)

# distutils: language = c++
# cython: language_level = 3

from libcpp.string cimport string
from libcpp.vector cimport vector
from libcpp.map cimport map
from libcpp cimport bool, float

from cython.operator cimport dereference as dref
from scipy.stats import ks_2samp
import matplotlib.pyplot as plt
import boost_histogram as bh
import mplhep as hep
import numpy as np
import random
import pathlib
import pickle


def ratio(H1, H2, axis, ylabel = "Ratio", normalize = False, yerror = False, this_hist = None):
    cdef dict out = {}
    axis.set_ylim(0, 2)
    axis.set_ylabel(ylabel, fontsize = this_hist.FontSize * (35 / len(ylabel)), loc = "center")

    if normalize:
        t1, t2 = H1.values(), H2.values()
        w1, w2 = H1.axes[0].widths, H2.axes[0].widths
        t1, t2 = (t1*w1)/((t1*w1).sum()), (t2*w2)/((t2*w2).sum())
        H1.reset()
        H2.reset()
        H1.view().value = t1
        H2.view().value = t2

    cdef float v1, v2
    cdef vector[float] h1 = H1.counts().tolist()
    cdef vector[float] h2 = H2.counts().tolist()
    cdef vector[float] s1 = H1.variances().tolist()
    cdef vector[float] s2 = H2.variances().tolist()
    for i in range(h2.size()):
        v1 = (h1[i] if h1[i] else 1)**2
        v2 = (h2[i] if h2[i] else 1)**2
        h2[i] = h1[i]/(h2[i] if h2[i] else 1)
        if not yerror: s2[i] = 0
        else: s2[i] = (h2[i]**2)*( (s1[i]/v1) + (s2[i]/v2) )

    H1.reset()
    H1.view().value    = [v1 if v1 > 0 else -1 for v1 in h2]
    H1.view().variance = [s2[i] if h2[i] > 0 else 0 for i in range(s2.size())]
    out["H"] = H1
    out["ax"] = axis
    out["color"] = "black"
    out["histtype"] = "errorbar"
    out["markersize"] = 5
    axis.axhline(1, linestyle = "--", color = "grey")
    return out

def chi2(H1, H2, axis, ylabel = "Ratio", normalize = False, yerror = False, this_hist = None):
    cdef dict out = {}
    axis.set_ylim(-1.2, 1.2)
    axis.set_ylabel("$\\frac{O_i - E_i}{|E_i|}$", fontsize = this_hist.FontSize, labelpad = 0.1)

    if normalize:
        t1, t2 = H1.values(), H2.values()
        w1, w2 = H1.axes[0].widths, H2.axes[0].widths
        t1, t2 = (t1*w1)/((t1*w1).sum()), (t2*w2)/((t2*w2).sum())
        H1.reset()
        H2.reset()
        H1.view().value = t1
        H2.view().value = t2

    cdef float _chi2 = 0
    cdef vector[float] h1 = H1.counts().tolist()
    cdef vector[float] h2 = H2.counts().tolist()
    for i in range(h2.size()):
        _chi2 += (h1[i] - h2[i])**2/(h2[i] if h2[i] else 1)
        h2[i] = (h1[i] - h2[i])/abs(h2[i] if h2[i] else 1) - 100*((h1[i] + h2[i]) == 0)
    H1.reset()
    H1.view().value = h2

    out["H"] = H1
    out["ax"] = axis
    out["color"] = "black"
    out["marker"] = this_hist.Marker
    out["histtype"] = "errorbar"
    out["markersize"] = 5
    out["add"] = "$\\left(\\chi^2 = " + "{:e}".format(_chi2) + "\\right)$"
    axis.axhline(0, linestyle = "--", color = "grey", linewidth = 1.0)
    return out

cdef class BasePlotting:
    def __cinit__(self):
        self.ptr = new plotting()
        self.matpl = plt

        self.ApplyScaling = False
        self.set_xmin = False
        self.set_xmax = False
        self.set_ymin = False
        self.set_ymax = False

    cdef void __figure__(self, dict com = {"nrows" : 1, "ncols" : 1}):
        com["figsize"] = (self.ptr.xscaling, self.ptr.yscaling)
        if "sharex" in com: com["figsize"][0]*1.5
        self._fig, self._ax = self.matpl.subplots(**com)
        try: self._ax.set_autoscale_on(self.ptr.auto_scale)
        except: self._ax[0].set_autoscale_on(self.ptr.auto_scale)

    cdef void __resetplt__(self):
        self.matpl.clf()
        self.matpl.cla()
        self.matpl.close("all")

        self.matpl = plt
        self.matpl.rcdefaults()
        self.__figure__()

    cdef dict __compile__(self, bool raw = False): return {}

    def __dealloc__(self): del self.ptr
    def __init__(self, inpt = None):
        if inpt is None: return
        cdef list keys = [i for i in self.__dir__() if not i.startswith("__")]
        for i in keys:
            try: setattr(self, i, inpt["data"][i])
            except KeyError: continue
            except AttributeError: continue

    def __reduce__(self):
        cdef bool cls
        cdef dict out = {"data" : {}}
        cdef list keys = [i for i in self.__dir__() if not i.startswith("__")]
        for i in keys:
            try: cls = callable(getattr(self, i))
            except: cls = False
            if cls: continue
            try: out["data"][i] = getattr(self, i)
            except: pass
        return self.__class__, (out,)

    def dump(self, str path = "", str name = ""):
        if not len(name): name = env(self.ptr.filename)
        if not len(path): path = env(self.ptr.output_path)
        pathlib.Path(path).mkdir(parents = True, exist_ok = True)
        try: pickle.dump(self, open(path + "/" + name + ".pkl", "wb"))
        except OSError: self.ptr.failure(b"Failed to save the Plotting Object")

    def load(self, str path = "", str name = ""):
        if not len(name): name = env(self.ptr.filename)
        if not len(path): path = env(self.ptr.output_path)
        try: return pickle.load(open(path + "/" + name + ".pkl", "rb"))
        except OSError: print("Failed to load the Plotting Object")
        except EOFError: print("Failed to load the Plotting Object")
        return None

    def __add__(self, BasePlotting other):
        self.ptr.x_data.insert( self.ptr.x_data.end() , other.ptr.x_data.begin() , other.ptr.x_data.end())
        self.ptr.y_data.insert( self.ptr.y_data.end() , other.ptr.y_data.begin() , other.ptr.y_data.end())
        self.ptr.weights.insert(self.ptr.weights.end(), other.ptr.weights.begin(), other.ptr.weights.end())
        return self

    def __radd__(self, other):
        if isinstance(other, BasePlotting): return self.__add__(other)
        cdef BasePlotting s = self.__class__()
        return s.__add__(self)

    @property
    def Hatch(self): return env(self.ptr.hatch)
    @Hatch.setter
    def Hatch(self, str val): self.ptr.hatch = enc(val)

    @property
    def DPI(self): return self.ptr.dpi
    @DPI.setter
    def DPI(self, int val): self.ptr.dpi = val

    @property
    def Style(self): return env(self.ptr.style)
    @Style.setter
    def Style(self, str val): self.ptr.style = enc(val)

    @property
    def CapSize(self): return self.ptr.cap_size
    @CapSize.setter
    def CapSize(self, float val): self.ptr.cap_size = val

    @property
    def ErrorBars(self): return self.ptr.errors
    @ErrorBars.setter
    def ErrorBars(self, bool val): self.ptr.errors = val

    @property
    def Filename(self): return env(self.ptr.filename)
    @Filename.setter
    def Filename(self, str val): self.ptr.filename = enc(val)

    @property
    def OutputDirectory(self): return env(self.ptr.output_path)
    @OutputDirectory.setter
    def OutputDirectory(self, str val): self.ptr.output_path = enc(val)

    @property
    def FontSize(self): return self.ptr.font_size
    @FontSize.setter
    def FontSize(self, float val): self.ptr.font_size = val

    @property
    def AxisSize(self): return self.ptr.axis_size
    @AxisSize.setter
    def AxisSize(self, float val): self.ptr.axis_size = val

    @property
    def LegendSize(self): return self.ptr.legend_size
    @LegendSize.setter
    def LegendSize(self, float val): self.ptr.legend_size = val

    @property
    def TitleSize(self): return self.ptr.title_size
    @TitleSize.setter
    def TitleSize(self, float val): self.ptr.title_size = val

    @property
    def UseLateX(self): return self.ptr.use_latex
    @UseLateX.setter
    def UseLateX(self, bool val): self.ptr.use_latex = val

    @property
    def xScaling(self): return self.ptr.xscaling
    @xScaling.setter
    def xScaling(self, float val): self.ptr.xscaling = val

    @property
    def yScaling(self): return self.ptr.yscaling
    @yScaling.setter
    def yScaling(self, float val): self.ptr.yscaling = val

    @property
    def AutoScaling(self): return self.ptr.auto_scale
    @AutoScaling.setter
    def AutoScaling(self, bool val): self.ptr.auto_scale = val

    @property
    def LineStyle(self): return env(self.ptr.linestyle)
    @LineStyle.setter
    def LineStyle(self, str val): self.ptr.linestyle = enc(val)

    @property
    def Title(self):
        cdef str titl = env(self.ptr.title)
        if not self.ptr.counts: return titl
        if not self.ptr.x_data.size(): return titl
        return titl + " (" + str(round(float(sum(self.counts)), 3)) + ")"

    @Title.setter
    def Title(self, str val): self.ptr.title = enc(val)

    @property
    def xTitle(self): return env(self.ptr.xtitle)
    @xTitle.setter
    def xTitle(self, str val): self.ptr.xtitle = enc(val)

    @property
    def yTitle(self): return env(self.ptr.ytitle)
    @yTitle.setter
    def yTitle(self, str val): self.ptr.ytitle = enc(val)

    @property
    def xLogarithmic(self): return self.ptr.x_logarithmic
    @xLogarithmic.setter
    def xLogarithmic(self, bool val): self.ptr.x_logarithmic = val

    @property
    def yLogarithmic(self): return self.ptr.y_logarithmic
    @yLogarithmic.setter
    def yLogarithmic(self, bool val): self.ptr.y_logarithmic = val

    @property
    def xStep(self): return self.ptr.x_step
    @xStep.setter
    def xStep(self, float val): self.ptr.x_step = val

    @property
    def yStep(self): return self.ptr.y_step
    @yStep.setter
    def yStep(self, float val): self.ptr.y_step = val

    @property
    def xMin(self): return self.ptr.x_min
    @xMin.setter
    def xMin(self, float val):
        self.set_xmin = True
        self.ptr.x_min = val

    @property
    def yMin(self): return self.ptr.y_min
    @yMin.setter
    def yMin(self, float val):
        self.set_ymin = True
        self.ptr.y_min = val

    @property
    def xMax(self): return self.ptr.x_max
    @xMax.setter
    def xMax(self, float val):
        self.set_xmax = True
        self.ptr.x_max = val

    @property
    def yMax(self): return self.ptr.y_max
    @yMax.setter
    def yMax(self, float val):
        self.set_ymax = True
        self.ptr.y_max = val

    @property
    def Overflow(self): return env(self.ptr.overflow)
    @Overflow.setter
    def Overflow(self, val):
        if isinstance(val, int): self.ptr.overflow = enc("sum" if val else "none")
        else: self.ptr.overflow = enc(val)

    @property
    def Color(self):
        if len(self.ptr.color): return env(self.ptr.color)
        self.Color = "#"+''.join([random.choice('0123456789ABCDEF') for j in range(6)])
        return self.Color

    @Color.setter
    def Color(self, str val): self.ptr.color = enc(val)

    @property
    def Colors(self): return [env(i) for i in self.ptr.colors]
    @Colors.setter
    def Colors(self, vals):
        if not isinstance(vals, list): return
        self.ptr.colors = enc_list(vals)

    cdef list __ticks__(self, float s, float e, float st):
        cdef list tick = []
        cdef float step = s
        while step <= e:
            tick.append(step)
            step += st
        return tick

    def SaveFigure(self):
        self.__resetplt__()
        if self.Style == "ATLAS": 
            self.matpl.style.use(hep.style.ATLAS)
            self.DPI = 800

        cdef string out = self.ptr.build_path()
        cdef str raw = env(out).replace(self.Filename + env(self.ptr.extension), "raw/" + self.Filename + ".pgf")
        cdef dict com = {}
        com["font.size"] = self.ptr.font_size
        com["axes.labelsize"] = self.ptr.axis_size
        com["legend.fontsize"] = self.ptr.legend_size
        com["figure.titlesize"] = self.ptr.title_size
        com["hatch.linewidth"] = self.ptr.line_width
        com["text.usetex"] = self.ptr.use_latex
        if self.ptr.use_latex:
            com["pgf.texsystem"] = "lualatex"
            com["text.latex.preamble"] = r"\usepackage{amsmath}"
            com["pgf.preamble"] = r"\usepackage{amsmath}"

        try: 
            self.matpl.rcParams.update(**com)
            self.__compile__()

            try: self._ax.set_title(self.Title, fontsize = self.ptr.title_size)
            except AttributeError: self.matpl.suptitle(self.Title, fontsize = self.ptr.font_size, y = 1.0)
            self.matpl.xlabel(self.xTitle, fontsize = self.ptr.font_size, labelpad = 0.1)

            if "<units>" not in self.yTitle: yl = self.yTitle
            else: yl = self.yTitle.replace("<units>", str(round((self.xMax - self.xMin)/self.xBins, 3)))

            try: self._ax.set_ylabel(yl, fontsize = self.ptr.font_size)
            except AttributeError: self._ax[0].set_ylabel(yl, fontsize = self.ptr.font_size)

            if self.xLogarithmic: self.matpl.xscale("log")
            if self.yLogarithmic: self.matpl.yscale("log")

            if self.ptr.variable_x_bins.size(): self.matpl.xticks(self.ptr.variable_x_bins, fontsize = self.ptr.axis_size)
            elif self.xStep > 0: self.matpl.xticks(self.__ticks__(self.xMin, self.xMax, self.xStep), fontsize = self.ptr.axis_size)
            else: self.matpl.xticks(fontsize = self.ptr.axis_size)

            if self.ptr.variable_y_bins.size(): self.matpl.yticks(self.ptr.variable_y_bins, fontsize = self.ptr.axis_size)
            elif self.yStep > 0: self.matpl.yticks(self.__ticks__(self.yMin, self.yMax, self.yStep), fontsize = self.ptr.axis_size)
            else: self.matpl.yticks(fontsize = self.ptr.axis_size)

            self.matpl.gcf().set_size_inches(self.ptr.xscaling, self.ptr.yscaling)

            com = {}
            com["dpi"] = self.ptr.dpi
            com["bbox_inches"] = "tight"
            com["pad_inches"] = 0
            com["transparent"] = True
            com["backend"] = "pgf"

            self.matpl.savefig(env(out), **com)
            self.matpl.savefig(raw, **com)
            self.matpl.close("all")
            self.ptr.success(b"Finished Plotting: " + out)
        except Exception as error:
            self.ptr.failure(b"Failed Plotting... Dumping State...")
            self.ptr.failure(enc(str(error)))
            self.dump()

cdef class TH1F(BasePlotting):

    def __cinit__(self): self.ptr.prefix = b"TH1F"

    def __init__(self, inpt = None, **kwargs):
        self.Histograms = []
        self.Histogram = None
        if len(kwargs): inpt = {"data" : dict(kwargs)}
        if inpt is None: return
        cdef list keys = [i for i in self.__dir__() if not i.startswith("__")]
        for i in keys:
            try: setattr(self, i, inpt["data"][i])
            except KeyError: continue
            except AttributeError: continue
            except: pass

    @property
    def xData(self): return self.ptr.x_data;
    @xData.setter
    def xData(self, list val): self.ptr.x_data = <vector[float]>(val)

    @property
    def xBins(self):
        if not self.ptr.variable_x_bins.size(): return self.ptr.x_bins
        else: return self.ptr.variable_x_bins

    @xBins.setter
    def xBins(self, val):
        if isinstance(val, int): self.ptr.x_bins = val
        elif isinstance(val, list): self.ptr.variable_x_bins = <vector[float]>(val)
        else: self.ptr.warning(b"Invalid Bins specified")

    @property
    def CrossSection(self): return self.ptr.cross_section
    @CrossSection.setter
    def CrossSection(self, val): self.ptr.cross_section = val

    @property
    def IntegratedLuminosity(self): return self.ptr.integrated_luminosity
    @IntegratedLuminosity.setter
    def IntegratedLuminosity(self, val): self.ptr.integrated_luminosity = val

    @property
    def HistFill(self): return env(self.ptr.histfill)
    @HistFill.setter
    def HistFill(self, str val): self.ptr.histfill = enc(val)

    @property
    def Stacked(self): return self.ptr.stack
    @Stacked.setter
    def Stacked(self, bool val): self.ptr.stack = val

    @property
    def LineWidth(self): return self.ptr.line_width
    @LineWidth.setter
    def LineWidth(self, float val): self.ptr.line_width = val

    @property
    def Alpha(self): return self.ptr.alpha
    @Alpha.setter
    def Alpha(self, float v): self.ptr.alpha = v

    @property
    def Density(self): return self.ptr.density
    @Density.setter
    def Density(self, bool val): self.ptr.density = val

    @property
    def counts(self):
        try: return sum(self.__compile__(True)["H"]).counts()
        except ValueError: return []

    @property
    def Marker(self): return env(self.ptr.marker)
    @Marker.setter
    def Marker(self, str v): self.ptr.marker = enc(v)

    @property
    def xLabels(self): return as_basic_udict(&self.ptr.x_labels)
    @xLabels.setter
    def xLabels(self, dict val): as_umap(val, &self.ptr.x_labels)

    @property
    def Weights(self): return self.ptr.weights
    @Weights.setter
    def Weights(self, list val): self.ptr.weights = <vector[float]>(val)

    @property
    def ShowCount(self): return self.ptr.counts
    @ShowCount.setter
    def ShowCount(self, bool val): self.ptr.counts = val

    def FX(self, val = None):
        if isinstance(val, str):
            if   val.lower() == "ratio": self.fx = ratio
            elif val.lower() == "chi2": self.fx = chi2
            else: self.ptr.warning(b"Input Option: " + enc(val) + " is an invalid option! (ratio, ratio_chi2)")
        elif val is None: self.fx = ratio
        else: self.fx = val

    def KStest(self, TH1F hist):
        hist_min = self.xMin
        hist_max = self.xMax
        hist_bin = self.xBins

        cdef float i
        cdef vector[float] h1 = [i for i in self.ptr.x_data if i >= hist_min and i <= hist_max]
        cdef vector[float] h2 = [i for i in hist.ptr.x_data if i >= hist_min and i <= hist_max]
        return ks_2samp(h1, h2)

    cdef __error__(self, vector[float] xarr, vector[float] up, vector[float] low, str label = "Uncertainty", str color = "k"):
        try: ax = self._ax[0]
        except: ax = self._ax
        cdef dict apl = {"step" : "post", "hatch" : "///", "alpha" : 0.15, "linewidth" : 0.0}
        if len(label): apl["label"] = label
        apl["facecolor"] = color if len(color) else None
        apl["edgecolor"] = ("k", 1.0)
        ax.fill_between(xarr, low, up, **apl)

        apl = {"hatch" : "///", "step": "post", "alpha" : 0.00}
        return self.matpl.fill_between(xarr, low, up, **apl)

    cdef __get_error_seg__(self, plot, str label = "Uncertainty", str color = "k"):
        error = plot.errorbar.lines[2][0]
        cdef list k
        cdef int ix = 0
        cdef vector[float] w_arr = []
        cdef vector[float] x_arr = []
        cdef vector[float] y_err_up = []
        cdef vector[float] y_err_lo = []
        for i in error.get_segments():
            k = i.tolist()
            x_arr.push_back(k[0][0])
            y_err_lo.push_back(k[0][1])
            if k[0][1] == 0: y_err_up.push_back(0.0)
            else: y_err_up.push_back(k[1][1])
            if ix: w_arr.push_back(abs(x_arr[ix-1] - x_arr[ix]))
            ix += 1
        ix -= 1
        for i in range(ix): x_arr[i] = x_arr[i] - w_arr[i]*0.5
        x_arr[ix] = x_arr[ix] - w_arr[ix-1]*0.5
        x_arr.push_back(x_arr[ix] + w_arr[ix-1])
        y_err_lo.push_back(y_err_lo[ix])
        y_err_up.push_back(y_err_up[ix])
        return self.__error__(x_arr, y_err_lo, y_err_up, label, color)

    cdef float scale_f(self): return self.CrossSection * self.IntegratedLuminosity

    cdef dict factory(self):
        cdef dict histpl = {}
        histpl["histtype"] = self.HistFill
        histpl["yerr"] = self.ErrorBars
        histpl["stack"] = self.Stacked
        histpl["hatch"] = [] if not len(self.Hatch) else [self.Hatch]
        histpl["linewidth"] = self.LineWidth
        histpl["edgecolor"] = "black"
        histpl["alpha"] =  []
        histpl["binticks"] = True
        histpl["edges"] = True
        histpl["density"] = self.Density
        histpl["flow"] = self.Overflow
        histpl["label"] = []
        histpl["H"] = []
        histpl["color"] = []
        if self.ptr.x_data.size(): histpl["color"] += [self.Color]
        return histpl

    cdef __build__(self):
        cdef dict labels = self.xLabels
        cdef float _max, _min

        if len(labels): pass
        elif self.set_xmin: _min = self.ptr.x_min
        elif not len(labels) and not len(self.xData): pass
        else: _min = self.ptr.get_min(b"x")

        if len(labels): pass
        elif self.set_xmax: _max = self.ptr.x_max
        elif not len(labels) and not len(self.xData): pass
        else: _max = self.ptr.get_max(b"x")

        if len(labels):
            ax_ = bh.axis.StrCategory(list(labels))
            self.ptr.weights = <vector[float]>(list(labels.values()))
        elif self.ptr.variable_x_bins.size(): ax_ = bh.axis.Variable(self.ptr.variable_x_bins)
        else: ax_ = bh.axis.Regular(self.ptr.x_bins, _min, _max)
        h = bh.Histogram(ax_, storage = bh.storage.Weight())

        if not self.ptr.weights.size(): h.fill(self.ptr.x_data)
        elif len(labels): h.fill(list(labels), weight = self.ptr.weights)
        else: h.fill(self.ptr.x_data, weight = self.ptr.weights)
        cdef float norm = float(sum(h.counts()))

        if self.Density: h *= 1/(norm if norm != 0 else 1)
        if self.ApplyScaling: h *= self.scale_f()
        return h

    cdef dict __compile__(self, bool raw = False):
        cdef dict labels = self.xLabels
        cdef float x_max, x_min

        if len(labels): pass
        elif self.set_xmin: x_min = self.ptr.x_min
        elif not len(labels) and not len(self.xData): pass
        elif self.ptr.variable_x_bins.size(): x_min = self.ptr.variable_x_bins.front()
        else: x_min = self.ptr.get_min(b"x")

        if len(labels): pass
        elif self.set_xmax: x_max = self.ptr.x_max
        elif not len(labels) and not len(self.xData): pass
        elif self.ptr.variable_x_bins.size(): x_max = self.ptr.variable_x_bins.back()
        else: x_max = self.ptr.get_max(b"x")

        y_max, y_min = None, None
        if self.set_ymin: y_min = self.ptr.y_min
        if self.set_ymax: y_max = self.ptr.y_max

        cdef TH1F h
        cdef dict histpl = self.factory()
        if self.Histogram is not None:
            if not len(labels): self.Histogram.xMin  = self.xMin
            if not len(labels): self.Histogram.xMax  = self.xMax
            if not len(labels): self.Histogram.xBins = self.xBins
            if self.ShowCount:  self.Histogram.ShowCount = self.ShowCount

            histpl["H"]     += [self.Histogram.__build__()]
            histpl["label"] += [self.Histogram.Title]
            histpl["color"] += [self.Histogram.Color]
            histpl["hatch"] += [self.Histogram.Hatch]
            histpl["alpha"] += [self.Histogram.Alpha]

        if len(self.xData) or len(labels):
            histpl = self.factory()
            if len(self.Histograms) and not len(self.xData): histpl["label"] = []
            else:
                histpl["label"] = None
                histpl["H"]     = [self.__build__()]
                if raw: return histpl
                hep.histplot(**histpl)

        for h in self.Histograms:
            if not len(labels): h.xMin  = self.xMin
            if not len(labels): h.xMax  = self.xMax
            if not len(labels): h.xBins = self.xBins
            if self.ShowCount:  h.ShowCount = self.ShowCount
            histpl["label"] += [h.Title]
            histpl["H"]     += [h.__build__()]
            histpl["color"] += [h.Color]
            histpl["hatch"] += [h.Hatch]
            histpl["alpha"] += [h.Alpha]

        if raw: return histpl
        if not len(histpl["H"]): return {}

        if self.ErrorBars and self.Histogram is not None and self.fx is None:
            l = list(histpl["label"])
            lg = list(histpl["H"])
            del histpl["edgecolor"]
            histpl["histtype"] = "step"
            histpl["H"] = [self.Histogram.__build__()]
            histpl["label"] = [self.Histogram.Title + " (Uncertainty)"]
            error = hep.histplot(**histpl)

            histpl["histtype"] = "fill"
            histpl["edgecolor"] = "black"
            histpl["label"] = l
            histpl["H"] = lg
            hep.histplot(**histpl)
            self.__get_error_seg__(error[0])

        elif self.Histogram is not None and len(self.Histograms) and self.Stacked:
            self.__figure__({
                "nrows" : 2, "ncols" : 1, "sharex" : True,
                "gridspec_kw" : {
                    "height_ratios" : [4, 1], "hspace" : 0.05
                }
            })

            cpy = {}
            cpy["linewidth"] = 0
            cpy["histtype"]  = "step"
            cpy["yerr"]      = True
            cpy["ax"]        = self._ax[0]
            cpy["H"]         = sum(histpl["H"][1:])
            error            = hep.histplot(**cpy)

            cpy = {}
            cpy["color"]      = "black"
            cpy["H"]          = histpl["H"].pop(0)
            cpy["label"]      = histpl["label"].pop(0)
            cpy["alpha"]      = histpl["alpha"].pop(0)
            cpy["histtype"]   = "errorbar"
            cpy["markersize"] = 5
            cpy["linewidth"]  = 2
            cpy["stack"]      = False
            cpy["ax"]         = self._ax[0]
            hep.histplot(**cpy)

            del histpl["hatch"]
            histpl["color"].pop(0)
            histpl["ax"] = self._ax[0]

            hep.histplot(**histpl)
            self.__get_error_seg__(error[0])
            self._ax[0].legend(loc = "upper right")
            self._ax[0].set_xlim(x_min, x_max, auto = True)
            self._ax[0].set_ylim(y_min, y_max, auto = True)

            if self.fx is None: self.FX()
            cpy = self.fx(
                    sum(histpl["H"]), cpy["H"], self._ax[1],
                    "Ratio - (" + self.Histogram.Title + "/" + cpy["label"],
                    self.Density, self.ErrorBars
            )
            hep.histplot(**cpy)
            return {}

        elif self.Histogram is not None and len(self.Histograms) and not self.Stacked:
            self.__figure__({
                "nrows" : 2, "ncols" : 1, "sharex" : True,
                "gridspec_kw" : {
                    "height_ratios" : [4, 1], "hspace" : 0.03
                }
            })

            histpl["ax"] = self._ax[0]
            hep.histplot(**histpl)
            self._ax[0].legend(loc = "upper right")
            if self.fx is None: self.FX()

            if len(self.Histograms) > 1: yl = "$\\frac{\\text{" + self.Histogram.Title + "}}{H_{X}})$"
            else: yl = "$\\frac{\\text{" + self.Histogram.Title + "}}{\\text{" + self.Histograms[0].Title + "}}$"

            for i in range(1, len(histpl["H"])):
                try: cpy = self.fx(histpl["H"][0].copy(), histpl["H"][i].copy(), self._ax[1], yl, self.Density, histpl["yerr"], self.Histograms[i-1])
                except: cpy = self.fx(histpl["H"][0].copy(), histpl["H"][i].copy(), self._ax[1], self.Histograms[i-1])
                cpy["color"] = histpl["color"][i]
                if "label" not in cpy: cpy["label"] = histpl["label"][i]
                if "add" in cpy: cpy["label"] += " " + cpy["add"]; del cpy["add"]
                hep.histplot(**cpy)
            self._ax[1].legend(loc = "best")
            return {}

        elif self.Histogram is None and len(self.Histograms) and self.ErrorBars:
            hts = dict(histpl)
            del hts["hatch"]
            del hts["edgecolor"]
            del hts["label"]

            hts["alpha"] = 0.0
            hts["histtype"] = "errorbar"
            error = hep.histplot(**hts)
            hep.histplot(**histpl)

            ix = 0
            hdl = []
            for i in range(len(error)):
                if not len(error[i]): continue
                hd = self.__get_error_seg__(error[i], histpl["label"][ix] + " (Uncertainty)", histpl["color"][ix])
                hdl.append(hd)
                ix+=1
            #self._ax.legend(handles = hdl, ncol = 2)

        elif self.ErrorBars:
            histpl["H"] = [self.__build__()]
            hts = dict(histpl)
            if "hatch" in histpl: del hts["hatch"]
            if "label" in histpl: del hts["label"]
            if "edgecolor" in histpl: del hts["edgecolor"]

            hts["alpha"] = 0.0
            hts["binticks"] = True
            hts["histtype"] = "errorbar"
            error = hep.histplot(**hts)
            hep.histplot(**histpl)
            self.__get_error_seg__(error[0])
        else: hep.histplot(**histpl)

        if not len(labels):
            self._ax.set_xlim(x_min, x_max, auto = True)
            self._ax.set_ylim(y_min, y_max, auto = True)
        self._ax.legend(loc = "upper right", ncol = 2 * (1 - 0.5*(not self.ErrorBars)))
        return {}

cdef class TH2F(BasePlotting):
    def __cinit__(self): self.ptr.prefix = b"TH2F"
    def __init__(self, inpt = None, **kwargs):
        self.Color = "plasma"
        if len(kwargs): inpt = {"data" : dict(kwargs)}
        if inpt is None: return
        cdef list keys = [i for i in self.__dir__() if not i.startswith("__")]
        for i in keys:
            try: setattr(self, i, inpt["data"][i])
            except KeyError: continue
            except AttributeError: continue

    @property
    def yBins(self):
        if not self.ptr.variable_y_bins.size(): return self.ptr.y_bins
        else: return self.ptr.variable_y_bins

    @yBins.setter
    def yBins(self, val):
        if isinstance(val, int): self.ptr.y_bins = val
        elif isinstance(val, list): self.ptr.variable_y_bins = <vector[float]>(val)
        else: self.ptr.warning(b"Invalid Bins specified")

    @property
    def xBins(self):
        if not self.ptr.variable_x_bins.size(): return self.ptr.x_bins
        else: return self.ptr.variable_x_bins

    @xBins.setter
    def xBins(self, val):
        if isinstance(val, int): self.ptr.x_bins = val
        elif isinstance(val, list): self.ptr.variable_x_bins = <vector[float]>(val)
        else: self.ptr.warning(b"Invalid Bins specified")

    @property
    def xLabels(self): return as_basic_udict(&self.ptr.x_labels)
    @xLabels.setter
    def xLabels(self, dict val): as_umap(val, &self.ptr.x_labels)

    @property
    def yLabels(self): return as_basic_udict(&self.ptr.y_labels)
    @yLabels.setter
    def yLabels(self, dict val): as_umap(val, &self.ptr.y_labels)

    @property
    def xData(self): return self.ptr.x_data;
    @xData.setter
    def xData(self, list val): self.ptr.x_data = <vector[float]>(val)

    @property
    def yData(self): return self.ptr.y_data;
    @yData.setter
    def yData(self, list val): self.ptr.y_data = <vector[float]>(val)

    @property
    def Weights(self): return self.ptr.weights
    @Weights.setter
    def Weights(self, list val): self.ptr.weights = <vector[float]>(val)

    cdef __build__(self):
        cdef float x_max, x_min
        cdef dict xlabels = self.xLabels

        if len(xlabels): pass
        elif self.set_xmin: x_min = self.ptr.x_min
        elif not len(xlabels) and not len(self.xData): pass
        elif self.ptr.variable_x_bins.size(): x_min = self.ptr.variable_x_bins.front()
        else: x_min = self.ptr.get_min(b"x")

        if len(xlabels): pass
        elif self.set_xmax: x_max = self.ptr.x_max
        elif not len(xlabels) and not len(self.xData): pass
        elif self.ptr.variable_x_bins.size(): x_max = self.ptr.variable_x_bins.back()
        else: x_max = self.ptr.get_max(b"x")

        cdef float y_max, y_min
        cdef dict ylabels = self.yLabels

        if len(ylabels): pass
        elif self.set_ymin: y_min = self.ptr.y_min
        elif not len(ylabels) and not len(self.yData): pass
        elif self.ptr.variable_y_bins.size(): y_min = self.ptr.variable_y_bins.front()
        else: y_min = self.ptr.get_min(b"y")

        if len(ylabels): pass
        elif self.set_xmax: y_max = self.ptr.y_max
        elif not len(ylabels) and not len(self.yData): pass
        elif self.ptr.variable_x_bins.size(): y_max = self.ptr.variable_y_bins.back()
        else: y_max = self.ptr.get_max(b"y")


        if self.ptr.variable_x_bins.size(): ax_ = bh.axis.Variable(self.ptr.variable_x_bins)
        else: ax_ = bh.axis.Regular(self.ptr.x_bins, x_min, x_max)

        if self.ptr.variable_y_bins.size(): ay_ = bh.axis.Variable(self.ptr.variable_y_bins)
        else: ay_ = bh.axis.Regular(self.ptr.y_bins, y_min, y_max)

        h = bh.Histogram(ax_, ay_, storage = bh.storage.Weight())
        if not self.ptr.weights.size(): h.fill(self.ptr.x_data, self.ptr.y_data)
        else: h.fill(self.ptr.x_data, self.ptr.y_data, weight = self.ptr.weights)
        return h

    cdef dict __compile__(self, bool raw = False):
        cdef dict histpl = {}
        histpl["H"] = self.__build__()
        if len(self.Color): histpl["cmap"] = self.Color
        histpl["alpha"] = 1
        histpl["antialiased"] = True
        histpl["linewidth"] = 0
        histpl["zorder"] = -1
        histpl["cbarpad"] = 0.1
        hst = hep.hist2dplot(**histpl)
        cbar = hst.cbar
        cbar.set_label('Bin Content', loc = "center", rotation=270, labelpad = 20)

        cdef float x_max, x_min
        if self.set_xmin: x_min = self.ptr.x_min
        else: x_min = self.ptr.get_min(b"x")

        if self.set_xmax: x_max = self.ptr.x_max
        else: x_max = self.ptr.get_max(b"x")

        cdef float y_max, y_min
        if self.set_ymin: y_min = self.ptr.y_min
        else: y_min = self.ptr.get_min(b"y")

        if self.set_ymax: y_max = self.ptr.y_max
        else: y_max = self.ptr.get_max(b"y")
        self.matpl.xlim(x_min, x_max)
        self.matpl.ylim(y_min, y_max)
        return {}

cdef class TLine(BasePlotting):
    def __cinit__(self): self.ptr.prefix = b"TLine"

    def __init__(self, inpt = None, **kwargs):
        self.Lines = []
        self.Marker = ""
        if len(kwargs): inpt = {"data" : dict(kwargs)}
        if inpt is None: return
        cdef list keys = [i for i in self.__dir__() if not i.startswith("__")]
        for i in keys:
            try: setattr(self, i, inpt["data"][i])
            except KeyError: continue
            except AttributeError: continue

    @property
    def xData(self): return self.ptr.x_data;

    @xData.setter
    def xData(self, list val): self.ptr.x_data = <vector[float]>(val)

    @property
    def yData(self): return self.ptr.y_data;

    @yData.setter
    def yData(self, list val): self.ptr.y_data = <vector[float]>(val)

    @property
    def Marker(self): return env(self.ptr.marker)

    @Marker.setter
    def Marker(self, str v): self.ptr.marker = enc(v)

    @property
    def yDataUp(self): return self.ptr.y_error_up

    @yDataUp.setter
    def yDataUp(self, val): self.ptr.y_error_up = <vector[float]>(val)

    @property
    def yDataDown(self): return self.ptr.y_error_down

    @yDataDown.setter
    def yDataDown(self, val): self.ptr.y_error_down = <vector[float]>(val)

    @property
    def LineWidth(self): return self.ptr.line_width

    @LineWidth.setter
    def LineWidth(self, float val): self.ptr.line_width = val

    cdef void factory(self):
        cdef dict coms = {}
        coms["linestyle"] = self.LineStyle
        if len(self.Color): coms["color"] = self.Color
        coms["marker"] = self.Marker
        coms["linewidth"] = self.LineWidth
        coms["label"] = self.Title

        if not len(self.xData): return
        elif self.ErrorBars:
            self.ptr.build_error()
            coms["yerr"] = [self.yDataDown, self.yDataUp]
            coms["capsize"] = self.ptr.cap_size
            self.matpl.errorbar(self.xData, self.yData, **coms)
        elif len(self.yDataDown) == len(self.yDataUp) == len(self.xData):
            coms["yerr"] = [self.yDataDown, self.yDataUp]
            coms["capsize"] = self.ptr.cap_size
            self.matpl.errorbar(self.xData, self.yData, **coms)
        else: self.matpl.plot(self.xData, self.yData, **coms)

    cdef dict __compile__(self, bool raw = False):

        cdef float x_max, x_min
        if self.set_xmin: x_min = self.ptr.x_min
        elif not self.ptr.x_data.size(): x_min = 0
        else: x_min = self.ptr.get_min(b"x")

        if self.set_xmax: x_max = self.ptr.x_max
        elif not self.ptr.x_data.size(): x_max = 0
        else: x_max = self.ptr.get_max(b"x")

        cdef float y_max, y_min
        if self.set_ymin: y_min = self.ptr.y_min
        elif not self.ptr.y_data.size(): y_min = 0
        else: y_min = self.ptr.get_min(b"y")

        if self.set_ymax: y_max = self.ptr.y_max
        elif not self.ptr.y_data.size(): y_max = 0
        else: y_max = self.ptr.get_max(b"y")

        if not len(self.Lines) and not self.ptr.x_data.size(): return {}
        cdef TLine i

        cdef vector[float] dy = []
        cdef vector[float] dx = []
        for i in self.Lines: 
            i.factory()
            merge_data(&dy, &i.ptr.y_data)
            merge_data(&dx, &i.ptr.x_data)

        self._ax.tick_params(axis = "x", which = "minor", bottom = False)
        self.matpl.legend(loc = "best", ncol = 2 * (1 - 0.5*(not len(self.Lines) > 3)))
        self.factory()

        if not self.set_ymin: y_min = self.ptr.min(&dy);
        if not self.set_ymax: y_max = self.ptr.max(&dy); y_max = y_max*(1 + 0.1)
        if not self.set_xmin: x_min = self.ptr.min(&dx); 
        if not self.set_xmax: x_max = self.ptr.max(&dx); x_max = x_max*(1 + 0.1)

        if x_max > x_min: self.matpl.xlim(x_min, x_max)
        if y_max > y_min: self.matpl.ylim(y_min, y_max)
        self.matpl.title(self.Title)
        return {}


cdef class ROC(TLine):
    def __cinit__(self):
        self.num_cls = 0
        self.inits = True
        self.Binary = False
        self.verbose = False
        self.ptr.prefix = b"ROC Curve"
        try: from sklearn import metrics; return
        except: self.inits = False
        self.ptr.warning(b"Failed to import sklearn.")

    def __init__(self, inpt = None, **kwargs):
        self.Lines = []
        self.Marker = ""
        self.auc = {}
        if len(kwargs): inpt = {"data" : dict(kwargs)}
        if inpt is None: return
        cdef list keys = [i for i in self.__dir__() if not i.startswith("__")]
        for i in keys:
            try: setattr(self, i, inpt["data"][i])
            except KeyError: continue
            except AttributeError: continue
        self.xTitle = "False Positive Rate"
        self.yTitle = "True Positive Rate"
        self.xMax = 1
        self.yMax = 1
        self.xMin = 0
        self.yMin = 0
    cdef void factory(self): return

    cdef dict __compile__(self, bool raw = False):
        if not self.inits: return {}
        if not self.ptr.roc_data.size(): return {}
        from sklearn.metrics import roc_curve, auc

        cdef int i
        cdef TLine pl
        cdef string model_mode 
        cdef map[string, vector[double]] auc_ntops
        cdef map[string, vector[vector[double]]] fpr_
        cdef map[string, vector[vector[double]]] tpr_
        cdef vector[roc_t] points = self.ptr.get_ROC()

        for i in range(points.size()):
            model_mode = points[i].model
            self.num_cls = points[i].cls
            data  = np.array(dref(points[i].scores))
            truth = np.array(dref(points[i].truth))
            for i in range(self.num_cls):
                fpr, tpr, _ = roc_curve(truth[:, i], data[:, i])
                auc_ntops[model_mode] = <vector[double]>(auc(fpr, tpr))
                fpr_[model_mode].push_back(<vector[double]>(fpr))
                fpr_[model_mode].push_back(<vector[double]>(tpr))
            print(auc_ntops)

        #cdef list lines = [TLine() for i in range(self.num_cls)]
        #if not len(self.Lines): self.Lines = ["label-" + str(i) for i in range(self.num_cls)]
        #for i in range(self.Binary, self.num_cls):
        #    pl = lines[i]
        #    pl.matpl = self.matpl
        #    pl.Title = self.Lines[i] + " AUC: " + str(auc_ntops[i])
#       #     pl.xData = fpr[i].tolist()
#       #     pl.yData = tpr[i].tolist()
        #    pl.factory()
        #    self.auc[i] = auc_ntops[i]

        #self.matpl.title(self.Title)
        #self._ax.tick_params(axis = "x", which = "minor", bottom = False)
        #self.matpl.legend(loc = "best")
        return {}

    @property
    def Scores(self): return None
    @property
    def Truth(self): return None

    @Scores.setter
    def Scores(self, val):
        cdef vector[vector[double]] data
        cdef vector[int]* vc = NULL

        if not self.inits: return
        if isinstance(val, list):
            data = <vector[vector[double]]>(val) 
            self.ptr.build_ROC(b"name", -1, vc, &data)
        elif isinstance(val, dict):
            for k in val:
                if isinstance(k, str) and isinstance(val[k], list): 
                    data = <vector[vector[double]]>(val[k]) 
                    self.ptr.build_ROC(enc(k), -1, vc, &data)
                elif isinstance(k, int) and isinstance(val[k], list):
                    data = <vector[vector[double]]>(val[k]) 
                    self.ptr.build_ROC(enc(k), -1, vc, &data)
                elif isinstance(k, str) and isinstance(val[k], tuple):
                    data = <vector[vector[double]]>(val[k][1]) 
                    self.ptr.build_ROC(enc(k), int(val[k][0]), vc, &data)
                else: return
        elif isinstance(val, tuple):
            data = <vector[vector[double]]>(val[2])
            self.ptr.build_ROC(enc(val[0]), int(val[1]), <vector[int]*>(NULL), &data)
        else: self.failure(b"Expected: dict(str, tuple(int, list[list[float]]")

    @Truth.setter
    def Truth(self, val): 
        cdef vector[int] data
        cdef vector[vector[double]]* vc = NULL

        if not self.inits: return
        if isinstance(val, list):
            data = <vector[int]>(val)
            self.ptr.build_ROC(b"name", -1, &data, vc)
        elif isinstance(val, dict):
            for k in val:
                if isinstance(k, str) and isinstance(val[k], list): 
                    data = <vector[int]>(val[k])
                    self.ptr.build_ROC(enc(k), -1, &data, vc)
                elif isinstance(k, int) and isinstance(val[k], list):
                    data = <vector[int]>(val[k])
                    self.ptr.build_ROC(enc(k), -1, &data, vc)
                elif isinstance(k, str) and isinstance(val[k], tuple):
                    data = <vector[int]>(val[k][1])
                    self.ptr.build_ROC(enc(k), int(val[k][0]), &data, vc)
        elif isinstance(val, tuple):
            data = <vector[int]>(val[2])
            self.ptr.build_ROC(enc(val[0]), int(val[1]), &data, vc)
        else: self.failure(b"Expected: dict(str, tuple(int, list[list[float]]")

    @property
    def Titles(self): return self.Lines
    @Titles.setter
    def Titles(self, list val): self.Lines = val

    @property
    def AUC(self): return self.auc

    @property
    def xData(self): return None
    @xData.setter
    def xData(self, val): self.ptr.warning(b"Wrong Input. Use Scores")

    @property
    def yData(self): return None
    @yData.setter
    def yData(self, val): self.ptr.warning(b"Wrong Input. Use Truth")


