/**
 * @file particle_template.dox
 * @brief Defines the Cython interface and Python wrapper for C++ particle template classes.
 * @details This file serves as the bridge between high-performance C++ particle objects and the Python analysis environment.
 *          It contains Cython declarations (`.pxd` style) that mirror the C++ `particle_template` class interface,
 *          allowing Cython code to interact directly with the C++ objects. It also implements a Python wrapper class,
 *          `ParticleTemplate` (`.pyx` style), which provides a user-friendly, Pythonic interface to the underlying C++ functionality.
 *          This wrapper handles crucial aspects like memory management (ownership tracking), attribute access (mapping Python properties
 *          to C++ members), method invocation (calling C++ methods like kinematic calculations or relationship management),
 *          and serialization (enabling pickling of particle objects and their relationships). The documentation herein aims to clarify
 *          both the exposed C++ features and the behavior of the Python wrapper, facilitating the use of these efficient particle
 *          representations within Python-based high-energy physics analysis workflows. Key features include lazy-loaded caching
 *          for parent/child relationships and robust handling of object lifetimes in the mixed C++/Python environment.
 */

// --- Cython Imports ---

/**
 * @brief Imports the C++ standard library map template (`std::map`).
 * @details This template is fundamental for representing associative containers within the C++ `particle_template` class.
 *          It is specifically used to manage the relationships between particles, such as storing pointers to parent
 *          and child particles, typically keyed by unique identifiers like particle hashes. The `cppmap` alias is used
 *          within the Cython code to refer to `std::map`.
 */
from libcpp.map cimport map as cppmap

/**
 * @brief Imports the C++ standard library string class (`std::string`).
 * @details Used extensively within the C++ `particle_template` class to store textual information. This includes
 *          unique particle identifiers (hashes), particle type classifications (e.g., "Lepton", "Jet"), and symbolic
 *          representations (e.g., "e-", "gamma"). It's also used as the key type in relationship maps (parents, children)
 *          and the key/value type in the `leaves` metadata map.
 */
from libcpp.string cimport string as std_string

/**
 * @brief Imports the C++ standard library boolean type (`bool`).
 * @details Represents boolean flags within the C++ `particle_template` class, such as `is_lep`, `is_nu`, `is_b`, `is_add`,
 *          `lep_decay`, and the internal serialization flag `_is_serial`. Cython maps this directly to the C++ `bool` type.
 */
from libcpp cimport bool

/**
 * @brief Imports the C++ standard library map (`std::map`) and pair (`std::pair`) templates.
 * @details Re-imports `std::map` and explicitly imports `std::pair`. `std::pair` is implicitly used as the value type
 *          in map iterations (e.g., when iterating over `self.ptr.leaves` or the map returned by C++ `__reduce__`).
 *          These are essential components for handling the structure of C++ relationship maps and serialization data.
 */
from libcpp.map cimport map, pair

/**
 * @brief Imports the C++ standard library string class (`std::string`) again.
 * @details This import statement appears redundant as `std::string` was already imported earlier. It doesn't harm functionality
 *          but could be removed for clarity. It reaffirms the availability of the `string` type for Cython declarations.
 */
from libcpp.string cimport string

/**
 * @brief Imports the C++ standard library vector template (`std::vector`).
 * @details Used within the C++ `particle_t` data structure (part of `particle_template`) to store sequences of integers.
 *          Specifically, it's used for the `lepdef` and `nudef` members, which likely hold definition codes or flags related
 *          to lepton and neutrino identification or origin within the analysis framework.
 */
from libcpp.vector cimport vector

/**
 * @brief Imports helper functions and potentially types from the AnalysisG tools module.
 * @details This imports necessary utility functions used for bridging Python and C++. It is assumed to contain functions like:
 *          - `enc()`: Encodes Python objects (especially strings) into a suitable C++ representation (likely `std::string` or `char*`).
 *          - `env()`: Decodes C++ data (like `std::string`) back into Python objects (typically Python strings).
 *          These are crucial for transferring string data (like hashes, types, symbols, leaf values) between the Python wrapper and the C++ object.
 */
from AnalysisG.core.tools cimport *

/**
 * @brief Imports the C definition of the `particle_t` struct.
 * @details This struct represents the core, low-level data associated with a particle. The C++ `particle_template` class
 *          contains a member of this type (`data`) to hold fundamental information like the particle's index, type string,
 *          and potentially vectors like `lepdef` and `nudef`. Importing its definition allows Cython to understand the structure
 *          and access its members when interacting with the C++ object's `data` member (e.g., in property setters/getters like `index`, `Type`).
 */
from AnalysisG.core.structs cimport particle_t

/**
 * @brief Imports the C definition of the `particle_template` class itself.
 * @details This import makes the C++ class `particle_template` known to Cython. It allows the Python wrapper class (`ParticleTemplate`)
 *          to declare pointers (`particle_template* ptr`) to instances of the C++ class, which is the fundamental mechanism for linking
 *          the Python wrapper to the underlying C++ object it manages.
 */
from AnalysisG.core.particle_template cimport particle_template


// --- C++ Interface Declaration (pxd style) ---

/**
 * @brief Declares the external C++ interface from the "particle_template.h" header file.
 * @param YourCppNamespace The namespace where the C++ `particle_template` class resides. **Note:** This should be replaced with the actual C++ namespace if one is used; otherwise, it might refer to the global namespace.
 * @details This `cdef extern from` block provides Cython with a blueprint of the C++ `particle_template` class. It lists the members
 *          (attributes and methods) that the Cython code intends to access, along with their C++ types and signatures. This allows Cython
 *          to generate the correct C/C++ code to interact with the C++ object via pointers. This initial declaration block might contain
 *          placeholder types (like `int` keys for maps) that are refined in later declarations or inferred by Cython. It establishes the
 *          basic structure expected from the C++ side.
 */
cdef extern from "particle_template.h" namespace "YourCppNamespace": // Replace YourCppNamespace if applicable

    /**
     * @class particle_template
     * @brief Represents a generic particle within a physics analysis context, implemented in C++.
     * @details This C++ class serves as the core data structure for particles. It encapsulates essential properties like kinematics
     *          (four-momentum components: E, Px, Py, Pz, and derived quantities like Pt, Eta, Phi, Mass), identification information
     *          (PDG ID, charge, type string, symbol), boolean flags indicating particle characteristics (is_lep, is_nu, is_b, etc.),
     *          and relationships with other particles (parents, children, leaves). It manages these relationships using `std::map` containers,
     *          typically storing pointers to related `particle_template` objects keyed by their unique hash strings. The class provides
     *          methods for common physics calculations (e.g., `DeltaR`), coordinate system conversions (`to_cartesian`, `to_polar`),
     *          relationship management (`register_parent`, `register_child`), and potentially operator overloading for particle addition.
     *          It relies on an underlying `particle_t` struct (`data` member) for storing some core information like index and type.
     *          This Cython declaration outlines the members intended to be accessed from the Python wrapper.
     */
    cdef cppclass particle_template:

        // --- C++ Attributes ---

        /**
         * @var double mass
         * @brief The invariant mass (M) of the particle, typically in units of GeV.
         * @details Represents the relativistic mass calculated from the particle's four-momentum (M = sqrt(E^2 - |P|^2)).
         *          This value is expected to be kept consistent with the energy and momentum components by the C++ class methods.
         */
        double mass

        /**
         * @var double e
         * @brief The total energy (E) of the particle, typically in units of GeV.
         * @details This is the time component (0th component) of the particle's four-momentum vector (E, Px, Py, Pz).
         */
        double e

        /**
         * @var double pt
         * @brief The transverse momentum (pT) of the particle, typically in units of GeV.
         * @details Calculated as the magnitude of the momentum component perpendicular to the beam axis (pT = sqrt(px^2 + py^2)).
         *          This value is expected to be kept consistent with `px` and `py` by the C++ class methods.
         */
        double pt

        /**
         * @var double eta
         * @brief The pseudorapidity (η) of the particle, a dimensionless measure of the angle relative to the beam axis.
         * @details Defined as η = -ln(tan(θ/2)), where θ is the polar angle with respect to the beam direction (z-axis).
         *          It is related to the longitudinal momentum component (`pz`) and the total momentum or transverse momentum.
         *          This value is expected to be kept consistent with the momentum components by the C++ class methods.
         */
        double eta

        /**
         * @var double phi
         * @brief The azimuthal angle (φ) of the particle, typically in units of radians.
         * @details Represents the angle in the transverse (xy) plane, measured from the positive x-axis. Usually defined in the range [-π, π] or [0, 2π].
         *          Calculated from `px` and `py` (φ = atan2(py, px)). This value is expected to be kept consistent by the C++ class methods.
         */
        double phi

        /**
         * @var double px
         * @brief The x-component of the particle's three-momentum vector, typically in units of GeV.
         */
        double px

        /**
         * @var double py
         * @brief The y-component of the particle's three-momentum vector, typically in units of GeV.
         */
        double py

        /**
         * @var double pz
         * @brief The z-component (longitudinal) of the particle's three-momentum vector, typically in units of GeV.
         * @details Represents the momentum component along the beam axis.
         */
        double pz

        /**
         * @var int pdgid
         * @brief The Particle Data Group (PDG) identifier.
         * @details An integer code standardized by the PDG to uniquely identify particle types (e.g., 11 for electron, -11 for positron, 22 for photon).
         *          Fundamental for particle identification in analysis.
         */
        int pdgid

        /**
         * @var std_string hash
         * @brief A unique string identifier generated for this specific particle instance.
         * @details This hash serves as a primary key for identifying and referencing this particle object, especially within
         *          complex event structures, relationship maps (parents, children), and during serialization/deserialization (pickling)
         *          to correctly reconstruct object graphs. Its generation mechanism is internal to the C++ class.
         */
        std_string hash

        /**
         * @var std_string type
         * @brief A string describing the general category or classification of the particle (e.g., "Lepton", "Quark", "Jet", "MET").
         * @details This classification is often user-defined or assigned during analysis steps and provides a higher-level grouping
         *          than the PDG ID. Note: This `type` member at the class level might be distinct from the `type` member within the `data` struct
         *          (`particle_t data`), potentially serving different classification purposes. Its exact role should be clarified by the C++ implementation.
         */
        std_string type

        /**
         * @var std_string symbol
         * @brief A common, human-readable symbolic representation of the particle type (e.g., "e-", "p+", "gamma", "jet").
         * @details Provides a convenient textual representation often used in plots or logs.
         */
        std_string symbol

        /**
         * @var double charge
         * @brief The electric charge of the particle, typically expressed in units of the elementary charge |e|.
         * @details For example, +1.0 for a proton, -1.0 for an electron, 0.0 for a photon or neutrino.
         */
        double charge

        /**
         * @var bool is_lep
         * @brief A boolean flag indicating whether the particle is classified as a lepton (electron, muon, or tau).
         * @details This flag is typically set based on the particle's PDG ID or specific analysis criteria during object creation or processing.
         *          Useful for quick lepton identification.
         */
        bool is_lep

        /**
         * @var bool is_nu
         * @brief A boolean flag indicating whether the particle is classified as a neutrino.
         * @details Set based on PDG ID or other criteria. Useful for identifying neutrinos in analysis, particularly relevant for missing energy calculations.
         */
        bool is_nu

        /**
         * @var bool is_b
         * @brief A boolean flag indicating whether the particle is related to a b-quark.
         * @details This could signify that the particle is a B-hadron, a jet originating from a b-quark (b-jet), or otherwise associated
         *          with bottom quark physics. Crucial for b-tagging algorithms and heavy flavor analysis.
         */
        bool is_b

        /**
         * @var bool is_add
         * @brief A boolean flag indicating whether this particle instance was created by combining other particles.
         * @details This flag is typically set to `True` when a particle is the result of an addition operation (e.g., `p1 + p2`),
         *          signifying it represents a composite system (like the sum of decay products or a combined object). Helps track the origin of particles.
         */
        bool is_add

        /**
         * @var bool lep_decay
         * @brief A boolean flag indicating whether the particle originates from or is involved in a leptonic decay process.
         * @details This flag can be used to tag particles associated with specific decay channels involving leptons (e.g., W -> l nu, Z -> ll).
         *          Its exact meaning depends on the analysis context where it's set.
         */
        bool lep_decay

        /**
         * @var bool _is_serial
         * @brief Internal flag used during the serialization (pickling) process to prevent infinite recursion. (Conventionally marked as protected/private).
         * @details When serializing a graph of interconnected particles (parents/children), this flag is used by the `__reduce__` mechanism
         *          to track whether a particular particle object's state has already been processed and added to the serialization dictionary.
         *          This prevents entering infinite loops if cyclic relationships exist and avoids redundant data storage. Cython maps this to C++ `bool`.
         */
        bool _is_serial # Mapped to Cython's bool

        // --- C++ Relationships ---

        /**
         * @var cppmap[int, particle_template*] parents
         * @brief Map storing pointers to the parent particles from which this particle originated (e.g., in a decay).
         * @details Represents the "mother" particles in a decay chain or event history. The keys are identifiers for the parents,
         *          and the values are raw C++ pointers (`particle_template*`) to the parent objects.
         *          **Note:** The key type `int` here is likely a placeholder from an initial declaration. Based on later refined declarations
         *          and usage (especially with `hash`), the actual key type in the C++ implementation is almost certainly `std::string` (the parent's hash).
         */
        cppmap[int, particle_template*] parents # Placeholder types - Actual key/value types depend on C++ implementation. Likely map[string, particle_template*]

        /**
         * @var cppmap[int, particle_template*] children
         * @brief Map storing pointers to the child particles produced by this particle (e.g., if it decays).
         * @details Represents the "daughter" particles in a decay chain or fragmentation process. The keys are identifiers for the children,
         *          and the values are raw C++ pointers (`particle_template*`) to the child objects.
         *          **Note:** Similar to `parents`, the key type `int` is likely a placeholder. The actual key type is expected to be `std::string` (the child's hash).
         */
        cppmap[int, particle_template*] children # Placeholder types - Actual key/value types depend on C++ implementation. Likely map[string, particle_template*]

        /**
         * @var cppmap[int, particle_template*] leaves
         * @brief Map storing associated "leaf" objects or metadata. The exact nature depends on usage (e.g., jet constituents, arbitrary attributes).
         * @details This map provides a flexible mechanism to associate arbitrary data with the particle. Initially declared with `int` keys and `particle_template*` values,
         *          later refined declarations and the `add_leaf(string, string)` method strongly indicate that the actual C++ implementation uses
         *          `std::map<std::string, std::string>`. It's used to store custom key-value string pairs as metadata.
         */
        cppmap[int, particle_template*] leaves # Placeholder types - Actual key/value types depend on C++ implementation. Likely map[string, string]

        // --- C++ Data ---

        // /**
        //  * @var particle_t data
        //  * @brief Holds the underlying raw particle data, likely defined in `structs.h`.
        //  * @details Contains core information potentially not directly exposed as top-level class members, such as `index`, `type` string, `lepdef`, `nudef`.
        //  *          Requires the `particle_t` struct definition to be available via `cimport`. Access is through `self.ptr.data`.
        //  */
        // particle_t data # Assumed to exist based on later code and refined declarations.

        // --- C++ Constructors (Assumed based on later extern block) ---
        // /**
        //  * @brief Default constructor (assumed). Creates a particle with default (likely zero) kinematics and flags.
        //  */
        // particle_template()
        // /**
        //  * @brief Constructor from a pointer to a `particle_t` struct (assumed). Initializes state from the struct's data.
        //  * @param p Pointer to the `particle_t` data source.
        //  */
        // particle_template(particle_t* p)
        // /**
        //  * @brief Copy/Clone constructor (assumed). Creates a new particle based on an existing one.
        //  * @param p Pointer to the source `particle_template` object.
        //  * @param dump Boolean flag, potentially controlling deep vs. shallow copy of relationships or debug output.
        //  */
        // particle_template(particle_template* p, bool dump)
        // /**
        //  * @brief Constructor from Cartesian momentum components and energy (assumed). Initializes four-momentum from (px, py, pz, e).
        //  * @param px Momentum x-component.
        //  * @param py Momentum y-component.
        //  * @param pz Momentum z-component.
        //  * @param e Total energy.
        //  */
        // particle_template(double px, double py, double pz, double e)
        // /**
        //  * @brief Constructor from Cartesian momentum components only (assumed). Initializes three-momentum (px, py, pz). Energy/mass likely calculated.
        //  * @param px Momentum x-component.
        //  * @param py Momentum y-component.
        //  * @param pz Momentum z-component.
        //  */
        // particle_template(double px, double py, double pz)

        // --- C++ Methods ---

        /**
         * @brief Calculates the angular separation ΔR (Delta R) between this particle and another particle.
         * @details ΔR is a crucial Lorentz-invariant measure in particle physics, defined as ΔR = sqrt(Δη^2 + Δφ^2),
         *          where Δη is the difference in pseudorapidity and Δφ is the difference in azimuthal angle (handled correctly for 2π periodicity).
         *          This method provides an efficient C++ implementation of the calculation.
         * @param other A constant reference to another `particle_template` object against which the separation is calculated.
         * @return double The calculated ΔR value.
         * @note The `nogil` specifier indicates that this method releases Python's Global Interpreter Lock (GIL) during execution.
         *       This allows other Python threads to run concurrently, potentially improving performance in multi-threaded applications
         *       if this C++ calculation is time-consuming.
         */
        double DeltaR(const particle_template& other) nogil

        /**
         * @brief Converts the particle's internal kinematic representation to Cartesian coordinates (px, py, pz).
         * @details Ensures the `px`, `py`, and `pz` member variables are consistent with the particle's current state,
         *          which might be stored internally in polar coordinates (pt, eta, phi, mass/energy). This method performs
         *          the necessary calculations (e.g., px = pt * cos(phi), py = pt * sin(phi), pz = pt * sinh(eta))
         *          to update the Cartesian components. Called internally or explicitly to ensure coordinate system consistency.
         * @note Marked `nogil`, allowing the GIL to be released during the calculation.
         */
        void to_cartesian() nogil

        /**
         * @brief Converts the particle's internal kinematic representation to polar coordinates (pt, eta, phi).
         * @details Ensures the `pt`, `eta`, and `phi` member variables are consistent with the particle's current state,
         *          which might be stored internally in Cartesian coordinates (px, py, pz, energy/mass). This method performs
         *          the necessary calculations (e.g., pt = sqrt(px^2 + py^2), eta = -ln(tan(atan2(pt, pz)/2)), phi = atan2(py, px))
         *          to update the polar components. Called internally or explicitly to ensure coordinate system consistency.
         * @note Marked `nogil`, allowing the GIL to be released during the calculation.
         */
        void to_polar() nogil

        /**
         * @brief Adds information about an associated "leaf" particle or metadata attribute as a key-value pair.
         * @details This method is used to store arbitrary associated data in the `leaves` map.
         *          **Note:** The signature `(int key, particle_template* leaf)` shown here is based on the initial, potentially placeholder,
         *          declaration of the `leaves` map. The later, refined declaration and usage strongly suggest the actual C++ method signature
         *          is `void add_leaf(std::string key, std::string leaf)`, designed to store string-based key-value metadata.
         * @param key An identifier (key) for the leaf information. (Type likely `std::string` in actual implementation).
         * @param leaf A pointer to the leaf particle or, more likely, the string value associated with the key. (Type likely `std::string` in actual implementation).
         * @note Marked `nogil`. The types shown are placeholders based on the initial `leaves` map declaration.
         */
        void add_leaf(int key, particle_template* leaf) nogil # Placeholder types, later refined to (string, string)

        /**
         * @brief Registers a parent particle for this particle, establishing the relationship in the C++ object graph.
         * @details Adds the provided `parent` particle pointer to this particle's `parents` map. The key used in the map
         *          is typically the hash string of the `parent` particle (`parent->hash`). This method is also expected
         *          to handle the bi-directional nature of the relationship, likely by calling `parent->register_child(this)`
         *          internally to add this particle to the parent's `children` map.
         * @param key An identifier for the parent. (Type `int` is likely a placeholder; the key is implicitly derived from the `parent` pointer, usually its hash).
         * @param parent A pointer to the `particle_template` object to be registered as a parent.
         * @note Marked `nogil`. The `key` parameter is likely unused in the refined implementation, which takes only `particle_template*`.
         */
        void register_parent(int key, particle_template* parent) nogil # Placeholder types, later refined to take only particle*

        /**
         * @brief Registers a child particle for this particle, establishing the relationship in the C++ object graph.
         * @details Adds the provided `child` particle pointer to this particle's `children` map, typically using the child's
         *          hash string (`child->hash`) as the key. It's also expected to establish the reverse link by calling
         *          `child->register_parent(this)` internally, adding this particle to the child's `parents` map.
         * @param key An identifier for the child. (Type `int` is likely a placeholder; the key is implicitly derived from the `child` pointer, usually its hash).
         * @param child A pointer to the `particle_template` object to be registered as a child.
         * @note Marked `nogil`. The `key` parameter is likely unused in the refined implementation, which takes only `particle_template*`.
         */
        void register_child(int key, particle_template* child) nogil # Placeholder types, later refined to take only particle*

        /**
         * @brief Overloads the addition operator (`+`) for combining two particles kinematically.
         * @details Implements the addition of the four-vectors (E, px, py, pz) of this particle and the `other` particle.
         *          It returns a *new* `particle_template` object representing the kinematic sum. The properties of the resulting
         *          particle (e.g., charge, type, flags like `is_add`, relationships) are determined by the specific C++ implementation.
         *          For instance, the `is_add` flag on the new particle is likely set to `True`. Relationships might be combined or ignored.
         * @param other A constant reference to the other `particle_template` object to be added.
         * @return particle_template A new `particle_template` object representing the four-vector sum.
         * @note Marked `nogil`. This operator creates and returns a new object by value.
         */
        particle_template operator+(const particle_template& other) nogil

        /**
         * @brief Overloads the in-place addition operator (`+=`), exposed to Cython as `iadd`.
         * @details Performs four-vector addition, but modifies *this* particle instance directly by adding the four-vector
         *          of the `other` particle to its own. Other properties (like charge, flags, type) might or might not be updated,
         *          depending on the C++ implementation's logic for in-place addition. Relationships are typically not modified by this operation.
         * @param other A constant reference to the other `particle_template` object whose kinematics are added to this one.
         * @return particle_template& A reference to *this* modified `particle_template` object.
         * @note Marked `nogil`. Renamed from `operator+=` to `iadd` for unambiguous direct access from Cython, avoiding potential complexities
         *       with binding C++ operator overloads directly in some Cython contexts. Modifies the object in place.
         */
        particle_template& iadd(const particle_template& other) nogil


// --- Refined C++ Interface Declaration (pxd style, from second extern block) ---

/**
 * @brief Declares the external C++ interface from "<templates/particle_template.h>" with more precise and complete signatures.
 * @details This second `cdef extern from` block provides a more accurate reflection of the actual C++ header file, refining the signatures
 *          of constructors, methods, and operators. Key additions include:
 *          - `except+`: This specifier tells Cython that the corresponding C++ function can throw C++ exceptions. Cython will automatically
 *            generate code to catch these C++ exceptions and translate them into appropriate Python exceptions (e.g., `RuntimeError`, `MemoryError`).
 *          - `nogil`: Retained from the previous block, indicating GIL release for potentially parallel execution.
 *          - Refined parameter types (e.g., using pointers `particle_template*` instead of references where appropriate for binding).
 *          - Corrected types for maps (`map[string, ...]`) and methods (`add_leaf`, `register_parent`, `register_child`).
 *          - Inclusion of the C++ `__reduce__` method for serialization support.
 *          This declaration is likely the one that most closely matches the C++ code being wrapped.
 */
cdef extern from "<templates/particle_template.h>" nogil:

    /**
     * @class particle_template
     * @brief Represents a generic particle in a physics analysis context (C++ implementation).
     * @details This refined Cython declaration focuses on the specific C++ method signatures directly used by the Python wrapper (`ParticleTemplate`).
     *          It includes detailed specifications for constructors, operators (`+`, `==`), relationship management methods (`register_parent`, `register_child`),
     *          kinematic methods (`DeltaR`, `to_cartesian`, `to_polar`), metadata handling (`add_leaf`), and serialization support (`__reduce__`).
     *          The use of `except+` and `nogil` provides crucial information for correct exception handling and potential parallelism via GIL release.
     *          It also clarifies the types used in relationship maps (`map[string, particle_template*]`) and the `leaves` map (`map[string, string]`).
     */
    cdef cppclass particle_template:
        /**
         * @brief Default constructor for the C++ `particle_template` class.
         * @details Creates a new particle instance, initializing its kinematic properties (likely to zero or default values),
         *          flags (to default states, e.g., `False`), and potentially generating a unique hash. Relationship maps (`parents`, `children`, `leaves`)
         *          are initialized as empty.
         * @throw May throw standard C++ exceptions (e.g., `std::bad_alloc` if memory allocation fails), which Cython (`except+`) will translate into Python exceptions.
         * @note Marked `nogil`. Called by the Python wrapper's `__cinit__` when a new base `ParticleTemplate` instance is created.
         */
        particle_template() except+ nogil

        /**
         * @brief Constructor initializing the particle from a raw `particle_t` data structure pointer.
         * @details Creates a new particle instance and populates its state (kinematics, IDs, flags, potentially `data` members like index, type, lepdef, nudef)
         *          using the information provided within the `particle_t` struct pointed to by `p`. This allows creating C++ particles from pre-existing data structures.
         * @param p A pointer to a `particle_t` struct containing the initial data for the particle. The struct's lifetime must be managed appropriately.
         * @throw May throw C++ exceptions (e.g., if `p` is null or invalid, or during internal calculations), translated by Cython (`except+`).
         * @note Marked `nogil`. Potentially used internally or if creating particles directly from C-style data.
         */
        particle_template(particle_t* p) except+ nogil

        /**
         * @brief Copy/Clone constructor (potentially). Creates a new particle instance based on an existing one.
         * @details Initializes a new `particle_template` object as a copy of the object pointed to by `p`. The `dump` flag's
         *          exact purpose is specific to the C++ implementation; it might control:
         *          - Deep vs. Shallow Copy: Whether relationship pointers (parents/children) are copied, or if the new particle starts with empty relationships.
         *          - Debug Output: Enabling verbose output during the copy process.
         *          - Specific State Transfer: Copying only certain aspects of the source particle.
         *          This constructor is essential for implementing a proper `clone` method in the Python wrapper.
         * @param p Pointer to the source `particle_template` object to copy from.
         * @param dump A boolean flag whose behavior depends on the C++ implementation (e.g., controlling copy depth, debug info).
         * @throw May throw C++ exceptions (e.g., memory allocation failure), translated by Cython (`except+`).
         * @note Marked `nogil`. A potential candidate for use within the Python `clone` method.
         */
        particle_template(particle_template* p, bool dump) except+ nogil

        /**
         * @brief Constructor initializing the particle from Cartesian momentum components and total energy.
         * @details Creates a new particle instance and sets its four-momentum using the provided (px, py, pz, E) values.
         *          Other kinematic properties like invariant mass (M), transverse momentum (pt), pseudorapidity (eta), and azimuthal angle (phi)
         *          are likely calculated and set internally based on these inputs to ensure consistency. Default values might be assigned to other properties like PDG ID, charge, etc.
         * @param px The x-component of the momentum vector.
         * @param py The y-component of the momentum vector.
         * @param pz The z-component (longitudinal) of the momentum vector.
         * @param e The total energy of the particle.
         * @throw May throw C++ exceptions (e.g., if inputs lead to invalid kinematic states like negative mass squared), translated by Cython (`except+`).
         * @note Marked `nogil`. Provides a way to construct particles directly from four-vector components.
         */
        particle_template(double px, double py, double pz, double e) except+ nogil

        /**
         * @brief Constructor initializing the particle from Cartesian momentum components only.
         * @details Creates a new particle instance and sets its three-momentum (px, py, pz). The energy (E) and invariant mass (M)
         *          must be determined based on these components. The C++ implementation might assume the particle is massless (E = |P|)
         *          or require the mass to be set separately using a setter method. Alternatively, it might calculate E based on a default mass assumption.
         *          Other kinematic variables (pt, eta, phi) are calculated from px, py, pz.
         * @param px The x-component of the momentum vector.
         * @param py The y-component of the momentum vector.
         * @param pz The z-component (longitudinal) of the momentum vector.
         * @throw May throw C++ exceptions, translated by Cython (`except+`).
         * @note Marked `nogil`. Useful when only the three-momentum is known initially.
         */
        particle_template(double px, double py, double pz) except+ nogil

        /**
         * @brief C++ method supporting Python's pickle protocol for serialization.
         * @details This method is designed to be called by the Python wrapper's `__reduce__` method when a `ParticleTemplate` object needs to be pickled.
         *          Its role is to gather the essential state of the C++ `particle_template` object required for its reconstruction during unpickling.
         *          Crucially, it must handle the potentially complex graph structure formed by parent/child relationships. It typically works in conjunction
         *          with the `_is_serial` flag to avoid infinite recursion.
         *          It returns a nested map structure: `map[string, map[string, particle_t]]`.
         *          - The outer map's key (`string`) is the unique hash of a particle involved in the serialization (this particle and potentially direct relatives).
         *          - The inner map (`map[string, particle_t]`) contains the core data needed for reconstruction associated with that hash. The inner map's key (`string`)
         *            might distinguish between the primary particle's data (e.g., key "data") and potentially other serializable state components if needed. The value (`particle_t`)
         *            is the fundamental data struct holding index, type, etc.
         *          This structure allows the Python `__reduce__` method to collect the state of multiple related particles into a single dictionary, ensuring that shared
         *          objects are serialized only once and relationships can be correctly restored during unpickling.
         * @return map[string, map[string, particle_t]] A nested map containing the serialized state (primarily the `particle_t` data) of this particle and potentially
         *         closely related particles, keyed by their unique hashes. This structure facilitates reconstruction of the object graph.
         * @throw May throw C++ exceptions (e.g., during data access or map operations), translated by Cython (`except+`).
         * @note Marked `nogil`. This method is fundamental for enabling the pickling (serialization) of `ParticleTemplate` objects and their relationships.
         */
        map[string, map[string, particle_t]] __reduce__() except+ nogil

        // --- C++ Attributes (Re-declared for completeness in this refined block) ---
        /** @copydoc particle_template::mass */
        double mass
        /** @copydoc particle_template::e */
        double e
        /** @copydoc particle_template::pt */
        double pt
        /** @copydoc particle_template::eta */
        double eta
        /** @copydoc particle_template::phi */
        double phi
        /** @copydoc particle_template::px */
        double px
        /** @copydoc particle_template::py */
        double py
        /** @copydoc particle_template::pz */
        double pz
        /** @copydoc particle_template::pdgid */
        int pdgid
        /** @copydoc particle_template::hash */
        string hash
        /** @copydoc particle_template::type */
        string type // Note: This 'type' string at the class level seems distinct from 'data.type' accessed later via the Type property. Clarification needed on its specific role vs data.type. Might be a broader category.
        /** @copydoc particle_template::symbol */
        string symbol
        /** @copydoc particle_template::charge */
        double charge
        /** @copydoc particle_template::is_lep */
        bool is_lep
        /** @copydoc particle_template::is_nu */
        bool is_nu
        /** @copydoc particle_template::is_b */
        bool is_b
        /** @copydoc particle_template::is_add */
        bool is_add
        /** @copydoc particle_template::lep_decay */
        bool lep_decay
        /** @copydoc particle_template::_is_serial */
        bool _is_serial

        // --- C++ Methods (Refined Signatures) ---

        /**
         * @brief Calculates the ΔR separation between this particle and another particle specified by a pointer.
         * @details This is a refined signature for the `DeltaR` calculation, taking a pointer (`particle_template*`) to the other particle
         *          instead of a reference. The core functionality remains the same: compute ΔR = sqrt(Δη^2 + Δφ^2) efficiently in C++.
         *          This pointer-based signature might be more convenient for calling from Cython when dealing with pointers obtained from maps or other sources.
         * @param p Pointer to the other `particle_template` object.
         * @return double The calculated ΔR value.
         * @throw May throw C++ exceptions (e.g., if `p` is null), translated by Cython (`except+`).
         * @note Marked `nogil`.
         */
        double DeltaR(particle_template* p) except+ nogil

        /**
         * @brief Converts the particle's kinematics to Cartesian coordinates (px, py, pz). (Refined signature).
         * @details Ensures the `px`, `py`, `pz` members are updated based on the current polar representation (pt, eta, phi, mass/energy).
         *          This version includes the `except+` specifier, indicating potential C++ exceptions during the calculation.
         * @throw May throw C++ exceptions (e.g., numerical issues), translated by Cython (`except+`).
         * @note Marked `nogil`.
         */
        void to_cartesian() except+ nogil

        /**
         * @brief Converts the particle's kinematics to polar coordinates (pt, eta, phi). (Refined signature).
         * @details Ensures the `pt`, `eta`, `phi` members are updated based on the current Cartesian representation (px, py, pz, mass/energy).
         *          This version includes the `except+` specifier.
         * @throw May throw C++ exceptions (e.g., numerical issues like division by zero if pt=0 for eta calculation), translated by Cython (`except+`).
         * @note Marked `nogil`.
         */
        void to_polar() except+ nogil

        /**
         * @brief Adds a key-value string pair as a "leaf" attribute to the particle's metadata.
         * @details This method provides the concrete implementation for storing arbitrary string-based metadata. It takes a string `key`
         *          and a string `leaf` (value) and inserts them into the `leaves` map (`std::map<std::string, std::string>`).
         *          This allows attaching custom information (e.g., detector region flags, quality criteria strings, algorithm identifiers)
         *          directly to the C++ particle object in a flexible way. Called by Python property setters as a fallback and potentially by `__getleaves__`.
         * @param key The string key under which the metadata value will be stored.
         * @param leaf The string value of the metadata.
         * @throw May throw C++ exceptions (e.g., `std::bad_alloc` during map insertion), translated by Cython (`except+`).
         * @note Marked `nogil`. This signature clarifies that the `leaves` map stores string key-value pairs.
         */
        void add_leaf(string key, string leaf) except+ nogil

        /**
         * @brief Overloads the equality operator (`==`) for comparing two particle_template objects.
         * @details Defines how equality is determined between two `particle_template` instances in C++. The comparison criteria
         *          are specific to the C++ implementation. It could be based on:
         *          - Uniqueness: Comparing only the `hash` strings.
         *          - Kinematic Equality: Comparing `px`, `py`, `pz`, `e` within some tolerance.
         *          - Full State Equality: Comparing all relevant members (kinematics, IDs, flags).
         *          The Python wrapper's `__eq__` method delegates the comparison to this C++ operator.
         * @param p A reference to the other `particle_template` object to compare against.
         * @return bool `True` if the particles are considered equal according to the C++ implementation's criteria, `False` otherwise.
         * @throw May throw C++ exceptions, translated by Cython (`except+`).
         * @note Marked `nogil`. The choice of comparison logic in C++ dictates the behavior of `==` in Python.
         */
        bool operator == (particle_template& p) except+ nogil

        /**
         * @brief Overloads the addition operator (`+`) using pointers for kinematic combination.
         * @details Performs four-vector addition similar to the reference-based overload, but takes a pointer to the other particle.
         *          Crucially, this version returns a *pointer* (`particle_template*`) to a *newly allocated* `particle_template` object
         *          that represents the kinematic sum. The caller (specifically, the Python wrapper's `__add__` method) becomes responsible
         *          for managing the memory of this returned object (e.g., by creating a new owning Python wrapper around the pointer or deleting it).
         *          Returning a pointer might be preferred in some C++ designs or for specific Cython binding strategies.
         * @param p Pointer to the other `particle_template` object to add.
         * @return particle_template* A pointer to the newly created particle representing the sum. Returns `NULL` or throws an exception on allocation failure.
         * @throw May throw C++ exceptions (e.g., `std::bad_alloc`), translated by Cython (`except+`).
         * @note Marked `nogil`. The caller must handle the memory management of the returned pointer.
         */
        particle_template* operator+(particle_template* p) except+ nogil

        /**
         * @brief Performs in-place four-vector addition (`+=`) using a pointer to the other particle.
         * @details Modifies the kinematics of *this* particle instance by adding the kinematics of the particle pointed to by `p`.
         *          This is the pointer-based equivalent of the `iadd` method that took a reference. It directly updates the `px, py, pz, e`
         *          (and potentially derived variables) of the current object. Called by the Python wrapper's `__add__` method (after cloning)
         *          or potentially by a future `__iadd__` implementation.
         * @param p Pointer to the other `particle_template` object whose kinematics are to be added to this one.
         * @throw May throw C++ exceptions (e.g., if `p` is null), translated by Cython (`except+`).
         * @note Marked `nogil`. Modifies the current object directly.
         */
        void iadd(particle_template* p) except+ nogil

        /**
         * @brief Registers a parent particle using a pointer, establishing the bi-directional relationship.
         * @details This is the refined signature for registering a parent. It takes a pointer `p` to the parent `particle_template` object.
         *          Inside this method, the C++ code adds `p` to this particle's `parents` map (likely keyed by `p->hash`) and, crucially,
         *          calls `p->register_child(this)` to add this particle to the parent's `children` map, thus ensuring the link is correctly
         *          established in both directions within the C++ object graph.
         * @param p Pointer to the `particle_template` object to be registered as a parent.
         * @return bool Typically returns `True` if the parent was successfully registered (e.g., it wasn't already listed as a parent), and `False` otherwise (e.g., if it's a duplicate). The Python wrapper uses this return value.
         * @throw May throw C++ exceptions (e.g., if `p` is null or map operations fail), translated by Cython (`except+`).
         * @note Marked `nogil`. This method encapsulates the logic for maintaining consistent parent-child links in C++.
         */
        bool register_parent(particle_template* p) except+ nogil

        /**
         * @brief Registers a child particle using a pointer, establishing the bi-directional relationship.
         * @details This is the refined signature for registering a child. It takes a pointer `p` to the child `particle_template` object.
         *          It adds `p` to this particle's `children` map (keyed by `p->hash`) and calls `p->register_parent(this)` to add this
         *          particle to the child's `parents` map, ensuring the bi-directional link.
         * @param p Pointer to the `particle_template` object to be registered as a child.
         * @return bool Typically returns `True` if the child was successfully registered (e.g., not a duplicate), `False` otherwise. Used by the Python wrapper.
         * @throw May throw C++ exceptions (e.g., if `p` is null or map operations fail), translated by Cython (`except+`).
         * @note Marked `nogil`. Encapsulates the logic for maintaining consistent child-parent links in C++.
         */
        bool register_child(particle_template* p) except+ nogil

        // --- C++ Relationships & Data (Refined Types) ---

        /**
         * @var map[string, particle_template*] parents
         * @brief Map storing pointers to parent particles, keyed by the parent's unique hash string.
         * @details This refined declaration confirms that the `parents` map uses `std::string` (specifically, the hash of the parent particle)
         *          as the key and stores raw C++ pointers (`particle_template*`) to the parent objects. This map represents the direct ancestry of the particle.
         */
        map[string, particle_template*] parents

        /**
         * @var map[string, particle_template*] children
         * @brief Map storing pointers to child particles, keyed by the child's unique hash string.
         * @details This refined declaration confirms that the `children` map uses the child particle's hash (`std::string`) as the key
         *          and stores raw C++ pointers (`particle_template*`) to the child objects. This map represents the direct descendants of the particle.
         */
        map[string, particle_template*] children

        /**
         * @var map[string, string] leaves
         * @brief Map storing arbitrary string key-value metadata associated with the particle.
         * @details This refined declaration confirms that the `leaves` map is implemented as `std::map<std::string, std::string>`.
         *          It is used by the `add_leaf(string, string)` method to store custom attributes as simple string pairs, providing a flexible metadata mechanism.
         */
        map[string, string] leaves

        /**
         * @var particle_t data
         * @brief The underlying raw particle data structure (`particle_t`).
         * @details This member holds the core, potentially lower-level, particle information defined by the `particle_t` struct.
         *          Based on property accessors (`index`, `Type`, `lepdef`, `nudef`), this struct likely contains members like `index` (int),
         *          `type` (std::string), `lepdef` (vector<int>), and `nudef` (vector<int>). Accessing these requires interacting with `self.ptr.data`.
         */
        particle_t data


// --- Python Wrapper Class Definition ---

/**
 * @class ParticleTemplate
 * @brief Python wrapper providing a high-level interface to the C++ `particle_template` class using Cython.
 * @details This `cdef class` defines the Python object that users interact with. Its primary purpose is to bridge the gap between Python and C++,
 *          offering a seamless, Pythonic experience while leveraging the performance of the underlying C++ implementation. Key responsibilities include:
 *          - **Lifecycle Management:** Manages the creation and destruction of the associated C++ `particle_template` object. It uses an `is_owner` flag
 *            to track whether the Python instance is responsible for deleting the C++ object upon garbage collection, preventing memory leaks or double-frees.
 *          - **Pointer Management:** Holds a raw C++ pointer (`particle_template* ptr`) to the underlying C++ object.
 *          - **Interface Exposure:** Exposes C++ attributes (kinematics, IDs, flags) as Python properties (e.g., `pt`, `eta`, `pdgid`, `is_lep`) with appropriate type conversions (e.g., `std::string` to Python `str`).
 *          - **Method Binding:** Makes C++ methods available as Python methods (e.g., `DeltaR`, `clone`).
 *          - **Relationship Handling:** Provides access to parent and child particles through the `Parents` and `Children` properties. It uses Python lists (`parents`, `children`)
 *            as lazy-loading caches for the Python wrappers of related C++ objects, improving performance by avoiding repeated wrapper creation. The setters for these properties
 *            interact with the C++ `register_parent`/`register_child` methods to maintain consistency in the C++ object graph.
 *          - **Serialization:** Implements the Python pickle protocol (`__reduce__`) by coordinating with the C++ `__reduce__` method and handling Python-level state,
 *            allowing complex particle graphs to be saved and loaded.
 *          - **Operator Overloading:** Implements Python operators like `+` (`__add__`, `__radd__`) and `==` (`__eq__`) by calling the corresponding C++ operators or methods.
 *          - **Metadata:** Allows access and modification of string-based metadata via the `leaves` map and potentially direct attribute access.
 *
 * @property children A Python list caching wrapper objects (`ParticleTemplate` instances) for direct child particles. Managed internally and accessed via the `Children` property getter/setter.
 * @property parents A Python list caching wrapper objects (`ParticleTemplate` instances) for direct parent particles. Managed internally and accessed via the `Parents` property getter/setter.
 * @property is_owner A boolean flag indicating if this Python instance owns the memory of the underlying C++ `particle_template` object (`ptr`). `True` means `__dealloc__` will delete `ptr`, `False` means it won't. Crucial for managing shared C++ objects.
 * @property keys An internal list of attribute names, primarily used during serialization (`__reduce__`) to identify Python-level state (stored in `__dict__`) that needs to be saved alongside the core C++ data. Populated dynamically if needed.
 * @property ptr A raw C++ pointer (`particle_template*`) to the underlying C++ object instance that this Python wrapper manages or references. This is the core link between Python and C++.
 */
cdef class ParticleTemplate:

    /**
     * @var particle_template* ptr
     * @brief Raw C++ pointer to the managed `particle_template` instance.
     * @details This pointer is the essential link connecting the Python `ParticleTemplate` wrapper object to its corresponding C++ `particle_template` object in memory.
     *          All interactions with the C++ object's data and functionality occur through this pointer. For example:
     *          - Accessing C++ attributes: `self.ptr.px`, `self.ptr.hash`
     *          - Calling C++ methods: `self.ptr.DeltaR(other.ptr)`, `self.ptr.register_child(child_ptr)`
     *          - Accessing nested data: `self.ptr.data.index`
     *          The pointer is initialized either in `__cinit__` (allocating a new C++ object for owning instances) or in `set_particle` (pointing to an existing C++ object for non-owning instances, like cached parents/children). Direct manipulation of this pointer from user Python code is strongly discouraged; the wrapper's properties and methods provide the safe and intended interface.
     */
    cdef particle_template* ptr

    /**
     * @var bool is_owner
     * @brief Flag controlling the memory ownership of the C++ object pointed to by `ptr`.
     * @details This boolean flag is critical for correct memory management in the mixed Python/C++ environment.
     *          - If `is_owner` is `True`: This Python `ParticleTemplate` instance is responsible for the lifetime of the C++ object `*ptr`. When this Python object is garbage collected, its `__dealloc__` method will execute `del self.ptr`, calling the C++ destructor and freeing the memory. This is the default state when a `ParticleTemplate` is created directly in Python (e.g., `p = ParticleTemplate()`), as `__cinit__` allocates a new C++ object and sets `is_owner = True`.
     *          - If `is_owner` is `False`: This Python instance merely holds a reference (pointer) to a C++ object whose lifetime is managed elsewhere. This could be another Python `ParticleTemplate` instance (e.g., a parent particle owning its children) or external C++ code. In this case, the `__dealloc__` method will *not* delete `self.ptr`, preventing double-free errors. This state is typically set by the `set_particle` method, which is used internally (e.g., by `make_particle`) to create non-owning wrappers for existing C++ objects retrieved from relationship maps (parents, children).
     *          Correctly managing this flag is essential to avoid memory leaks (if owning objects are not deleted) and crashes (if non-owning objects attempt deletion).
     */
    cdef bool is_owner

    /**
     * @var list keys
     * @brief Internal list storing the names of Python-level attributes relevant for serialization and state management.
     * @details This list primarily serves the `__reduce__` (pickling) and `__init__` (unpickling) methods. It helps identify which attributes belonging to the Python wrapper instance itself (i.e., stored in the instance's `__dict__`, not directly mapped to C++ members) should be saved as part of the object's state.
     *          - During pickling (`__reduce__`), the method iterates through `self.keys` to find attributes in `self.__dict__` and saves them into the `b"extra"` part of the state dictionary.
     *          - During unpickling (`__init__`), the method uses the keys stored in the pickled state's `b"extra"` dictionary (which originated from `self.keys`) to restore these Python-level attributes onto the newly created instance using `setattr`.
     *          The `keys` list is often populated dynamically the first time it's needed (e.g., in `__init__` or `__reduce__`) by introspecting the object's attributes using `self.__dir__`, filtering for relevant (e.g., non-callable) attributes. This allows custom attributes added to a `ParticleTemplate` instance in Python to be potentially included in the pickling process.
     */
    cdef list keys

    /**
     * @var list children
     * @brief Python-level cache holding `ParticleTemplate` wrapper instances for the direct children of this particle.
     * @details This list serves as a performance optimization for accessing child particles. Instead of creating new Python wrapper objects every time the `Children` property is accessed, this list stores previously created wrappers.
     *          - **Lazy Loading:** The list is typically populated only when the `Children` property getter is called for the first time. The getter calls `self.make_particle(self.ptr.children)`, which iterates through the C++ `children` map, creates a *non-owning* (`is_owner=False`) `ParticleTemplate` wrapper for each C++ child pointer using `set_particle`, and returns them in a list. This list is then stored in `self.children`.
     *          - **Caching:** Subsequent calls to the `Children` getter retrieve the wrappers directly from this cached list, avoiding the overhead of C++ map iteration and Python object creation.
     *          - **Setter Interaction:** The `Children` property setter modifies both the underlying C++ `children` map (via `self.ptr.register_child`) and this Python cache list (`self.children`) to maintain consistency. When clearing children, this list is emptied. When adding children, successfully registered children (wrappers) are appended to this list.
     *          The wrappers stored here do not own the underlying C++ child objects; the C++ objects' lifetimes are typically managed by their parent (this particle) or the overall C++ event structure.
     */
    cdef list children

    /**
     * @var list parents
     * @brief Python-level cache holding `ParticleTemplate` wrapper instances for the direct parents of this particle.
     * @details This list functions identically to the `children` cache but for parent particles. It optimizes access to parent wrappers.
     *          - **Lazy Loading:** Populated by the `Parents` property getter on first access by calling `self.make_particle(self.ptr.parents)`. This creates non-owning (`is_owner=False`) wrappers for the C++ parent objects found in the `self.ptr.parents` map.
     *          - **Caching:** Subsequent accesses to the `Parents` property retrieve wrappers from this list.
     *          - **Setter Interaction:** The `Parents` property setter updates the C++ `parents` map (via `self.ptr.register_parent`) and this Python cache list (`self.parents`) accordingly.
     *          Wrappers stored in this list reference C++ parent objects whose lifetimes are managed elsewhere.
     */
    cdef list parents

    // --- Cython Methods ---

    /**
     * @brief C-level initialization method (Cython constructor phase 1). Automatically called *before* `__init__`.
     * @details This special Cython method handles the earliest phase of object initialization, ensuring the C-level structure is set up before any Python-level initialization (`__init__`) occurs. It cannot accept Python arguments. Its key actions are:
     *          1.  **Initialize Caches:** Sets the Python list attributes `self.children` and `self.parents` to new empty lists (`[]`).
     *          2.  **Set Default Ownership:** Sets the memory ownership flag `self.is_owner` to `True`. This assumes that, by default, a newly created Python instance will be responsible for managing the lifetime of the C++ object it's associated with.
     *          3.  **Initialize Keys List:** Sets `self.keys` to an empty Python list (`[]`).
     *          4.  **Initialize Pointer:** Sets the C++ pointer `self.ptr` to `NULL` (or `nullptr` in C++11 onwards) to indicate it doesn't point to a valid object yet.
     *          5.  **Allocate C++ Object (Base Class Only):** This is a crucial step for memory management. It checks if the object being created is *exactly* of type `ParticleTemplate` (i.e., `type(self) is ParticleTemplate`). If it is (and not an instance of a subclass), it allocates a *new* C++ `particle_template` object on the heap using the C++ default constructor (`new particle_template()`) and assigns the resulting pointer to `self.ptr`. This ensures that base class instances automatically create and own their underlying C++ object.
     *          6.  **Subclass Handling:** If the object being created is an instance of a *subclass* of `ParticleTemplate`, the C++ allocation step (5) is skipped. This allows subclasses to potentially:
     *              - Manage their own C++ object creation (e.g., using a different C++ constructor).
     *              - Wrap an existing C++ pointer provided externally, using `set_particle` later in their initialization, without the base `__cinit__` unnecessarily allocating (and potentially leaking) a default C++ object.
     * @note This method guarantees the basic C attributes (`ptr`, `is_owner`, list caches) are initialized before `__init__` runs, making the object safe for subsequent setup. The conditional allocation based on type is key to supporting inheritance correctly.
     */
    def __cinit__(self): pass

    /**
     * @brief Python-level initialization method (Cython constructor phase 2). Called *after* `__cinit__`.
     * @details This method handles the Python-level initialization of the `ParticleTemplate` instance. Its primary role in this implementation is to reconstruct the object's state from a dictionary (`inpt`), which is typically provided during deserialization (unpickling) when an object is loaded from a pickled representation. The structure of the `inpt` dictionary is expected to match the format created by the `__reduce__` method.
     *
     *          **Behavior when `inpt` dictionary is provided:**
     *          1.  **Populate Keys (if needed):** If the internal `self.keys` list is empty, it populates it by introspecting the object's attributes using `self.__dir__`. This captures the names of potential Python-level attributes that might need to be restored. (Note: This introspection might capture more than intended; refining the key population might be necessary).
     *          2.  **Restore Python-Level State (`b"extra"`):** It iterates through the attribute names stored in `self.keys`. For each key `i`:
     *              - It attempts to retrieve the corresponding value from `inpt[b"extra"][i]`. The `b"extra"` sub-dictionary within the input holds the saved state of Python-level attributes (those not directly mapped to C++ members).
     *              - It attempts to set this retrieved value onto the current object instance using `setattr(self, i, value)`.
     *              - **Error Handling:** It includes `try...except` blocks to gracefully handle `KeyError` (if an attribute listed in `self.keys` wasn't actually saved in the `b"extra"` dictionary of this specific pickled object) and `AttributeError` (if the current class definition no longer has the attribute `i` that was saved previously). This makes unpickling more robust to class evolution or variations in pickled state.
     *          3.  **Restore Core C++ State (`b"data"`):**
     *              - It retrieves the core particle data, which is expected to be stored under the key `b"data"` in the `inpt` dictionary. This data should be in a format compatible with the C `particle_t` struct (e.g., a tuple or a compatible C structure representation).
     *              - It performs a C-level cast of this retrieved data to the `particle_t` type: `<particle_t>(inpt[b"data"])`.
     *              - It assigns this cast `particle_t` struct directly to the `data` member of the underlying C++ object: `self.ptr.data = ...`. This step restores the fundamental state (like index, type string, lepdef, nudef) stored within the C++ object's `data` member.
     *
     *          **Behavior when `inpt` is `None` (Default):**
     *          - If no input dictionary is provided (e.g., `p = ParticleTemplate()`), this method does nothing, and the object retains the default state established by `__cinit__` (which includes a default-constructed C++ particle if it's a base class instance).
     *
     * @param inpt An optional dictionary containing the serialized state of the particle, typically generated by `__reduce__` during pickling. Expected structure: `{b"data": <particle_t_compatible_data>, b"extra": {py_attr_name1: value1, ...}}`. Defaults to `None`.
     * @note This method is crucial for enabling the unpickling of `ParticleTemplate` objects, correctly restoring both the core C++ state and any additional Python-level attributes that were saved.
     */
    def __init__(self, inpt = None): pass

    /**
     * @brief C-level deallocation method (Cython destructor). Called when the Python object is garbage collected.
     * @details This special Cython method is automatically invoked when the reference count of the `ParticleTemplate` Python object drops to zero, just before the Python object's memory is freed. Its sole and critical responsibility is to manage the cleanup of the associated C++ `particle_template` object to prevent memory leaks.
     *
     *          **Behavior:**
     *          1.  **Subclass Check:** It first checks if the type of the object being deallocated is *exactly* `ParticleTemplate` (`type(self) is ParticleTemplate`). If it's an instance of a subclass, the method returns immediately without doing anything further. This is a safety measure to prevent the base class `__dealloc__` from interfering with potentially different C++ resource management implemented by a subclass. Subclasses are responsible for their own C++ cleanup if they manage resources differently.
     *          2.  **Ownership Check:** If it is a base class instance, it then checks the `self.is_owner` flag. If `self.is_owner` is `False`, it means this Python wrapper does not own the C++ object (`self.ptr`), so it returns immediately. This prevents attempts to delete C++ objects whose lifetimes are managed elsewhere (e.g., cached parent/child wrappers).
     *          3.  **Null Pointer Check:** If `self.is_owner` is `True`, it performs a final check to ensure `self.ptr` is not `NULL`. If it is `NULL` (which shouldn't normally happen for an owning instance after `__cinit__` but is a safe check), it returns.
     *          4.  **C++ Object Deletion:** If the instance is a `ParticleTemplate` (not a subclass), `self.is_owner` is `True`, and `self.ptr` is not `NULL`, then the method proceeds to delete the C++ object using the C++ `delete` operator applied to the pointer: `del self.ptr`. This invokes the C++ destructor (`~particle_template()`) for the object pointed to by `self.ptr` and frees the memory that was allocated for it (typically in `__cinit__`).
     *
     * @note This method ensures that C++ memory associated with *owning* `ParticleTemplate` instances is correctly released when the corresponding Python wrapper object is destroyed. The combination of the type check and the `is_owner` flag check is crucial for correct memory management in scenarios involving inheritance and shared C++ objects (non-owning wrappers).
     */
    def __dealloc__(self): pass

    /**
     * @brief Implements Python's serialization (pickling) protocol. Called by `pickle.dump` or similar.
     * @details This method is responsible for gathering all the necessary information to reconstruct the `ParticleTemplate` object (and potentially its related graph of parents/children) later during unpickling. It coordinates with the C++ `__reduce__` method and handles Python-level state. It uses a shared dictionary (`dictout`) to manage the serialization of potentially interconnected objects, preventing infinite loops and redundancy.
     *
     *          **Serialization Process:**
     *          1.  **Shared State Dictionary (`dictout`):** Uses a dictionary `dictout` passed recursively (or initialized empty on the first call) to store the serialized state of all particle objects encountered during the pickling of a potentially complex graph. The keys of `dictout` are the C++ hash strings of the particles, and the values are dictionaries containing their state.
     *          2.  **Check for Prior Serialization:** It first checks if the C++ hash of the current particle (`self.ptr.hash`) already exists as a key in `dictout`.
     *              - If **Yes**: This means the particle's state has already been processed (likely because it's a parent/child of another particle already visited in this pickle operation). It sets the internal C++ flag `self.ptr._is_serial = True` (signaling to the C++ `__reduce__` that this object is already handled) and proceeds directly to step 6 (preparing the return tuple).
     *              - If **No**: This is the first time encountering this specific particle in this pickle operation.
     *          3.  **Call C++ `__reduce__`:**
     *              - Sets `self.ptr._is_serial = False` initially.
     *              - Calls the C++ method `self.ptr.__reduce__()`. This C++ method gathers the core state (`particle_t`) of the current particle and potentially its direct neighbors (if needed for reconstruction, although typically only the current particle's core data is needed here) and returns it in a nested map: `map[string, map[string, particle_t]] mx`. The outer key is the particle hash, the inner map holds the data (e.g., under key `"data"`).
     *              - **Merge C++ State:** It iterates through the `mx` map returned by C++ and merges the state information (the inner `map[string, particle_t]`) into the shared `dictout` dictionary, keyed by the particle hash (`itx.first`). This populates `dictout` with the core C++ data for this particle.
     *              - Sets `self.ptr._is_serial = True` to mark this particle as processed for the current pickle operation.
     *          4.  **Prepare Python-Level State (`b"extra"`):**
     *              - Ensures `self.keys` is populated (if empty) by introspecting `self.__dir__` to get potential Python attribute names.
     *              - Retrieves the state dictionary for the *current* particle from `dictout` using its hash (`dictout[self.ptr.hash]`).
     *              - Creates an empty sub-dictionary under the key `b"extra"` within this state dictionary: `dictout[self.ptr.hash][b"extra"] = {}`.
     *              - Iterates through the attribute names in `self.keys`. For each key `i`, if it corresponds to a non-callable attribute present in the Python instance's `__dict__`, it copies that attribute's value into the `b"extra"` dictionary: `dictout[self.ptr.hash][b"extra"][i] = getattr(self, i)`. This saves the Python-level state.
     *          5.  **Store Reconstruction Class:** Stores the actual class of the object being pickled (`self.__class__`) into the state dictionary under the key `b"__class__"`: `dictout[self.ptr.hash][b"__class__"] = self.__class__`. This tells the unpickler which class to use for reconstruction.
     *          6.  **Recursive Call & Return Tuple:** Makes a recursive call `self.__reduce__(dictout)`.
     *              - On this recursive call, the check in step 2 will now find the entry in `dictout`.
     *              - It retrieves the state dictionary `state = dictout[self.ptr.hash]`.
     *              - It checks if `b"__class__"` is present in `state`. Since it was added in step 5, this condition is now met.
     *              - It pops `b"__class__"` from the state dictionary to get the reconstruction class (`cls = state.pop(b"__class__")`).
     *              - It returns the standard tuple required by the pickle protocol: `(cls, (state,))`.
     *                  - `cls`: The class to call for reconstruction (`ParticleTemplate` or a subclass).
     *                  - `(state,)`: A tuple containing the arguments to pass to the class's `__init__` method during unpickling. Here, the argument is the `state` dictionary (now containing `b"data"` and `b"extra"` but without `b"__class__"`).
     *
     * @param dictout A dictionary passed recursively to accumulate state during serialization. Users should not provide this; it's managed internally. Initial call uses `{}`.
     * @return tuple A tuple `(callable, args)` conforming to the pickle protocol. `callable` is the class (`ParticleTemplate` or subclass) needed for reconstruction. `args` is a tuple containing the arguments for `__init__` (the state dictionary).
     * @note This implementation carefully combines C++ state retrieval (via C++ `__reduce__`) with Python-level state saving and uses a shared dictionary and the `_is_serial` flag to correctly handle complex object graphs and prevent redundant serialization or infinite loops.
     */
    def __reduce__(self, dict dictout = {}): pass

    /**
     * @brief Provides a hash value for the ParticleTemplate instance, enabling its use in sets and dictionary keys.
     * @details Calculates an integer hash value based on the unique hash string of the underlying C++ particle object.
     *          The implementation takes the first 8 characters of the C++ hash string (`self.ptr.hash`), treats this substring
     *          as a hexadecimal number, and converts it into a Python integer.
     *          Steps:
     *          1. Access the C++ hash string: `self.ptr.hash`.
     *          2. Convert the `std::string` to a C++ string object usable by Cython/Python: `string(...)`.
     *          3. Extract the first 8 characters: `.substr(0, 8)`.
     *          4. Convert this 8-character hexadecimal string to a Python integer using base 16: `int(..., 16)` (Note: the original code uses `int(..., 0)` which auto-detects base, including hex if prefixed with '0x', but directly using base 16 might be safer if the prefix isn't guaranteed).
     * @return int An integer hash value derived from the first 8 characters of the C++ particle's hash string.
     * @note The quality of this hash depends on the uniqueness and distribution of the first 8 characters of the C++ hash. While usually sufficient, collisions are theoretically possible if multiple particles share the same initial 8 hash characters. The C++ `hash` itself is assumed to be unique for distinct particle instances.
     */
    def __hash__(self): pass

    /**
     * @brief Overloads the addition operator (`+`) for combining two `ParticleTemplate` objects.
     * @details Implements particle addition primarily based on four-vector summation, returning a *new* `ParticleTemplate` instance representing the combination. It also attempts to merge the parent/child relationships of the operands into the resulting particle.
     *
     *          **Behavior:**
     *          1.  **Clone `self`:** Creates a new `ParticleTemplate` instance `p` by calling `self.clone()`.
     *              - **Important:** The effectiveness of this depends heavily on the implementation of `self.clone()`. The provided `clone` method is very basic, only copying the `Type`. A proper implementation should ideally create a new C++ object that is a kinematic copy of `self` (perhaps using the C++ copy constructor `particle_template(self.ptr, ...)`). The new object `p` owns its C++ pointer (`p.is_owner = True`).
     *          2.  **Add `other` Kinematics:** Calls the C++ in-place addition method `p.ptr.iadd(other.ptr)`. This adds the four-vector of the `other` particle to the new particle `p`.
     *          3.  **Add `self` Kinematics:** Calls `p.ptr.iadd(self.ptr)`. This adds the four-vector of the `self` particle to `p`.
     *              - **Note on Order:** If `clone` correctly copies `self`'s kinematics into `p`, then step 2 adds `other`, and step 3 adds `self` *again*. This would result in `p = self + other + self`. If `clone` creates a *default* (zeroed) particle and only copies the `Type`, then step 2 makes `p = other` kinematically, and step 3 makes `p = other + self`. The latter seems more likely intended for four-vector addition `self + other`. The current implementation might need review based on the `clone` behavior. Assuming `clone` creates a zeroed particle + type, the result is `p = other + self`.
     *          4.  **Merge Relationships:** It attempts to combine the parent and child relationships from both `self` and `other` onto the new particle `p`. It does this by accessing the `Children` and `Parents` properties (which trigger lazy loading if needed) and using the property setters (`p.Children = ...`, `p.Parents = ...`) or list extension (`+=`).
     *              - Appends `other.Children` to `p.Children`.
     *              - Appends `other.Parents` to `p.Parents`.
     *              - Appends `self.Children` to `p.Children`.
     *              - Appends `self.Parents` to `p.Parents`.
     *              - **Effect:** This makes the new particle `p` a child of *all* parents of `self` and `other`, and a parent of *all* children of `self` and `other`. This merging logic might be complex and its physical interpretation needs careful consideration. It uses the Python property setters, which in turn call the C++ `register_child`/`register_parent` methods, updating the C++ graph accordingly.
     *          5.  **Set `is_add` Flag (Implied):** Although not explicitly shown, a typical implementation of C++ `iadd` or the C++ `+` operator would likely set the `is_add` flag on the resulting particle `p` to `True`.
     *          6.  **Return New Particle:** Returns the newly created and modified `ParticleTemplate` instance `p`.
     *
     * @param other The `ParticleTemplate` instance to be added to `self`. Cython enforces this type hint.
     * @return ParticleTemplate A *new* `ParticleTemplate` instance representing the kinematic sum (potentially `other + self` based on `clone` behavior) and possessing merged parent/child relationships from both operands.
     * @throw TypeError If `other` is not a `ParticleTemplate` instance (enforced by Cython). May propagate exceptions from C++ `iadd` or property setters/getters if they occur.
     */
    def __add__(self, ParticleTemplate other): pass

    /**
     * @brief Implements reflected addition (handles `other + self`). Called when `self` is on the right side of `+`.
     * @details This method ensures that addition works correctly when a `ParticleTemplate` instance is the right-hand operand and the left-hand operand might be of a different type or also a `ParticleTemplate`.
     *          **Behavior:**
     *          1.  **Type Check:** Uses the helper method `self.is_self(other)` to check if the `other` object (the left-hand operand) is an instance of `ParticleTemplate` or one of its subclasses.
     *          2.  **Incompatible Type:** If `other` is not compatible (i.e., `is_self` returns `False`), the current implementation returns `self`. This behavior might be unexpected; typically, reflected operations should either raise a `TypeError` or return `NotImplemented` to allow Python to try other dispatch mechanisms. Returning `self` implies `incompatible_object + particle == particle`, which is likely incorrect.
     *          3.  **Compatible Type:** If `other` is a compatible `ParticleTemplate` instance, it delegates the operation to the standard `__add__` method: `self.__add__(other)`. This effectively calculates `self + other`. Since addition is usually commutative kinematically, this should produce the correct result for `other + self`.
     * @param other The object on the left-hand side of the `+` operator.
     * @return ParticleTemplate If `other` is compatible, returns the result of `self + other`. If `other` is incompatible, the current implementation returns `self` (consider changing to `NotImplemented` or raising `TypeError`).
     */
    def __radd__(self, other): pass

    /**
     * @brief Overloads the equality operator (`==`) for comparing `ParticleTemplate` objects.
     * @details Defines how two `ParticleTemplate` instances (or an instance and another object) are compared for equality in Python.
     *          **Behavior:**
     *          1.  **Type Check:** It first uses `self.is_self(other)` to check if the `other` object is an instance of `ParticleTemplate` or its subclasses. If `other` is not a compatible type, the comparison immediately returns `False`.
     *          2.  **Cast to `ParticleTemplate`:** If `other` is compatible, it's safely cast to a `ParticleTemplate` type within Cython (`cdef ParticleTemplate o = other`) to allow access to its `ptr`.
     *          3.  **Delegate to C++ `operator==`:** The core comparison logic is delegated to the C++ `operator==` implementation. It compares the C++ objects pointed to by the wrappers by dereferencing the pointers: `self.ptr[0] == o.ptr[0]`.
     *              - `self.ptr[0]` is Cython syntax for dereferencing the C++ pointer `self.ptr` (equivalent to `*self.ptr` in C++).
     *              - `o.ptr[0]` dereferences the pointer of the `other` compatible particle.
     *              - The result of the comparison depends entirely on how `operator==` is defined in the C++ `particle_template` class (e.g., based on hash, kinematics, or full state).
     * @param other The object to compare with `self`.
     * @return bool `True` if `other` is a `ParticleTemplate` (or subclass) instance and the C++ `operator==` between the underlying C++ objects returns `true`. Returns `False` otherwise (either due to type incompatibility or the C++ comparison yielding `false`).
     */
    def __eq__(self, other): pass

    /**
     * @brief Retrieves a dictionary of "leaf" attributes associated with the particle.
     * @details This method gathers string-based key-value metadata ("leaves") from two sources: the underlying C++ `leaves` map (`std::map<string, string>`) and any string attributes stored directly in the Python wrapper instance's `__dict__`. It also synchronizes the Python attributes back into the C++ map.
     *
     *          **Behavior:**
     *          1.  **Initialize Dictionary:** Creates an empty Python dictionary `leaves` to store the results.
     *          2.  **Fetch from C++ Map:** Iterates through the C++ `self.ptr.leaves` map. For each `pair[string, string] x` in the map:
     *              - Decodes the C++ key (`x.first`) and value (`x.second`) into Python strings using the `env()` helper function (assumed to handle potential encoding differences).
     *              - Adds the decoded key-value pair to the Python `leaves` dictionary.
     *          3.  **Fetch from Python `__dict__` and Synchronize to C++:** Iterates through the items `(i, v)` in the Python instance's dictionary (`self.__dict__`).
     *              - **String Check:** Checks if the value `v` is an instance of a Python string (`isinstance(v, str)`).
     *              - **If String:**
     *                  - Encodes the Python key `i` and the Python string value `v` into bytes/C++ strings using the `enc()` helper function.
     *                  - Calls the C++ method `self.ptr.add_leaf(enc(i), enc(v))` to add or update this key-value pair in the C++ `leaves` map. **Note:** This means Python string attributes can overwrite values in the C++ map if the keys match.
     *                  - Adds the Python string key `i` and value `v` to the Python `leaves` dictionary as well.
     *          4.  **Return Combined Leaves:** Returns the `leaves` dictionary, which now contains a merged view of string key-value pairs from both the C++ map and the Python instance's string attributes.
     *
     * @return dict A Python dictionary where both keys and values are strings, representing the combined metadata.
     * @note This method provides a unified view of string metadata but also actively synchronizes Python string attributes *into* the C++ `leaves` map during the retrieval process. This side effect should be considered when using this method.
     */
    def __getleaves__(self): pass

    /**
     * @brief Creates and returns a new `ParticleTemplate` instance that is a copy (clone) of the current one.
     * @details Provides a mechanism to duplicate a particle object.
     *          **Current Implementation Details:**
     *          1.  **Create New Instance:** Creates a new, default-initialized `ParticleTemplate` instance `v` using the standard constructor (`ParticleTemplate()`). This new instance `v` allocates its own default C++ object and sets `v.is_owner = True`.
     *          2.  **Copy Type:** Copies the `Type` property from the original object (`self`) to the new object (`v`) using the `Type` property setter: `v.Type = self.Type`. This sets the `type` string within the `data` member of `v`'s C++ object.
     *          3.  **Return New Instance:** Returns the newly created instance `v`.
     *
     * @return ParticleTemplate A new `ParticleTemplate` instance.
     * @note **Critique of Current Implementation:** This `clone` method is extremely shallow. It only copies the `Type` string. It does *not* copy any kinematic information (px, py, pz, e, pt, eta, phi, mass), other identifiers (pdgid, hash, symbol), flags (is_lep, is_nu, etc.), or relationships (parents, children, leaves). The returned object `v` will have default kinematics and flags, and its hash will be different from `self`.
     *       **Recommendation for Improvement:** A more useful `clone` method would typically perform a deeper copy. This could be achieved by leveraging the C++ copy constructor declared earlier (`particle_template(particle_template* p, bool dump)`):
     *       ```python
     *       # Potential improved implementation:
     *       cpdef ParticleTemplate clone(self, bool dump=False): # Optional dump flag
     *           # Create wrapper without triggering __cinit__'s allocation
     *           cdef ParticleTemplate v = ParticleTemplate.__new__(ParticleTemplate)
     *           # Use C++ copy constructor to create a copy of the C++ object
     *           v.ptr = new particle_template(self.ptr, dump)
     *           # The new wrapper owns the new C++ object
     *           v.is_owner = True
     *           # Initialize caches (optional, could be lazy loaded)
     *           v.children = []
     *           v.parents = []
     *           v.keys = list(self.keys) # Copy keys for potential Python state
     *           # Optionally copy Python-level attributes from self.__dict__ to v.__dict__
     *           # ... (copy relevant items from self.__dict__ to v.__dict__) ...
     *           return v
     *       ```
     *       This improved version would create a new C++ object that is a proper copy of `self.ptr` and ensure the new Python wrapper `v` correctly owns it. The current minimal implementation might be intentional if only a new particle of the same `Type` is needed, to be populated manually afterwards.
     */
    cpdef ParticleTemplate clone(self): pass

    /**
     * @brief Internal C-level helper method to replace the managed C++ pointer and set ownership to False.
     * @details This `cdef` method (callable only from Cython, not directly from Python) is a crucial utility for creating *non-owning* `ParticleTemplate` wrappers. It allows an existing Python wrapper instance to stop managing its current C++ object (if any) and instead point to a different, externally managed C++ object.
     *
     *          **Behavior:**
     *          1.  **Delete Owned Object (if any):** It first checks if the current wrapper instance owns its C++ object (`self.is_owner is True`) and if the pointer is valid (`self.ptr != NULL`). If both conditions are met, it deletes the C++ object currently pointed to by `self.ptr` using `del self.ptr`. This prevents a memory leak of the C++ object that might have been allocated by `__cinit__` when the wrapper was initially created.
     *          2.  **Assign New Pointer:** It assigns the provided C++ pointer `ox` to the wrapper's internal pointer: `self.ptr = ox`. The Python wrapper now references the C++ object pointed to by `ox`.
     *          3.  **Relinquish Ownership:** It explicitly sets the ownership flag to `False`: `self.is_owner = False`. This ensures that the wrapper's `__dealloc__` method will *not* attempt to delete the C++ object `*ox` when the Python wrapper is eventually garbage collected. The lifetime of `*ox` is assumed to be managed elsewhere.
     *
     * @param ox A raw C++ pointer (`particle_template*`) to an *existing* C++ `particle_template` object. The lifetime of the object pointed to by `ox` must be managed externally (e.g., by the C++ container it came from, or by another owning wrapper).
     * @note This method is essential for the implementation of `make_particle`, which creates the non-owning wrappers used in the `Parents` and `Children` property caches. It allows these cached wrappers to safely reference the C++ parent/child objects without causing double-deletion errors when the wrappers are garbage collected.
     */
    cdef void set_particle(self, particle_template* ox): pass

    /**
     * @brief Internal C-level factory utility to create a list of non-owning Python wrappers from a C++ map of particle pointers.
     * @details This `cdef` method takes a C++ map (`px`) where keys are strings (expected to be particle hashes) and values are pointers to existing C++ `particle_template` objects. It iterates through the map and creates a Python `ParticleTemplate` wrapper for each C++ object, ensuring that each wrapper is configured *not* to own the C++ object it points to.
     *
     *          **Behavior:**
     *          1.  **Initialize Output List:** Creates an empty Python list `out` to store the generated wrappers.
     *          2.  **Iterate C++ Map:** Loops through each entry (`pair[string, particle_template*] p`) in the input C++ map `px`. The `p.first` is the hash (key), and `p.second` is the pointer to the C++ particle object.
     *          3.  **Create Default Wrapper:** For each entry, it creates a new, standard `ParticleTemplate` instance: `pi = ParticleTemplate()`. As per `__cinit__`, this `pi` instance initially allocates its own default C++ object and sets `pi.is_owner = True`.
     *          4.  **Set Particle and Ownership:** It immediately calls `pi.set_particle(p.second)`. This crucial step does two things:
     *              - It deletes the default C++ object that `pi` just created (because `pi.is_owner` was `True`).
     *              - It makes `pi.ptr` point to the C++ particle from the map (`p.second`).
     *              - It sets `pi.is_owner = False`.
     *          5.  **Append Non-Owning Wrapper:** The configured wrapper `pi`, which now points to the correct C++ object and knows it doesn't own it, is appended to the `out` list.
     *          6.  **Return Wrapper List:** After iterating through the entire map, the method returns the `out` list containing all the newly created, non-owning `ParticleTemplate` wrappers.
     *
     * @param px A C++ `std::map<std::string, particle_template*>` containing pointers to existing C++ particle objects, keyed by their hashes. These C++ objects are assumed to have their lifetimes managed elsewhere.
     * @return list A Python list of `ParticleTemplate` instances. Each instance in the list wraps one of the C++ objects from the input map `px`, and crucially, each wrapper has `is_owner = False`.
     * @note This function is the core mechanism used by the `Children` and `Parents` property getters to lazily create the Python wrappers needed for the caches. It ensures that accessing parents or children provides Python objects that correctly reference the underlying C++ data without interfering with C++ memory management.
     */
    cdef list make_particle(self, map[string, particle_template*] px): pass

    /**
     * @brief Utility method to check if an input object is an instance of `ParticleTemplate` or its subclasses.
     * @details Provides a convenient way to verify if a given Python object `inpt` is type-compatible with `ParticleTemplate`, handling both direct instances and instances of derived classes.
     *          **Behavior:**
     *          1.  **`isinstance` Check:** It first performs a standard Python `isinstance(inpt, ParticleTemplate)` check. This returns `True` if `inpt` is an instance of `ParticleTemplate` or any class that inherits from it.
     *          2.  **`issubclass` Check (Potentially Redundant/Risky):** If the `isinstance` check fails, it proceeds to check `issubclass(inpt.__class__, ParticleTemplate)`.
     *              - The intention here might be to handle cases where `inpt` itself is a class object (e.g., `ParticleTemplate` itself or a subclass type) rather than an instance.
     *              - However, `isinstance` already covers instances of subclasses. Checking `issubclass` might be redundant for the common case of checking instances.
     *              - Furthermore, accessing `inpt.__class__` could raise an `AttributeError` if `inpt` doesn't have a `__class__` attribute (e.g., if it's a built-in type like `None` or an integer).
     *          3.  **Return Value:** Returns `True` if either the `isinstance` check or the `issubclass` check returns `True`. Otherwise, returns `False`.
     *
     * @param inpt The Python object whose type needs to be checked.
     * @return bool `True` if `inpt` is considered compatible with `ParticleTemplate` (either an instance of it or its subclass, or potentially a subclass type itself based on the second check), `False` otherwise.
     * @note A simpler and potentially safer implementation might be just `return isinstance(inpt, ParticleTemplate)`, as `isinstance` correctly handles subclass instances. The current implementation's `issubclass` check adds complexity and potential fragility. Used by `__radd__` and `__eq__` for type validation.
     */
    def is_self(self, inpt): pass

    /**
     * @brief Calculates the Delta R (ΔR = sqrt(Δη² + Δφ²)) distance between this particle and another `ParticleTemplate` instance.
     * @details This method provides efficient access to the Lorentz-invariant angular separation calculation, a fundamental quantity in particle physics analyses. It leverages the C++ implementation for performance.
     *          **Behavior:**
     *          1.  **Type Hinting:** The `ParticleTemplate other` argument uses Cython type hinting, ensuring that the input `other` is expected to be a `ParticleTemplate` instance. Cython will raise a `TypeError` at runtime if an incompatible type is passed.
     *          2.  **Delegate to C++:** It directly calls the C++ `DeltaR` method using the pointers to the underlying C++ objects: `self.ptr.DeltaR(other.ptr)`. It uses the refined C++ `DeltaR` signature that accepts a pointer.
     *          3.  **Return Value:** Returns the `double` value calculated by the C++ method.
     *          **`cpdef`:** The `cpdef` keyword makes this method highly optimized for calls from both Python code and other Cython code (C-level calls).
     *
     * @param other The other `ParticleTemplate` instance to which the ΔR distance should be calculated. Must be a `ParticleTemplate` or subclass instance.
     * @return double The calculated ΔR value.
     * @throw TypeError If `other` is not a `ParticleTemplate` instance (checked by Cython). May propagate C++ exceptions (e.g., if `other.ptr` is null and the C++ method doesn't handle it) if the C++ method is marked `except+`.
     */
    cpdef double DeltaR(self, ParticleTemplate other): pass

    // --- Properties (Getters) ---

    /**
     * @property hash
     * @brief Gets the unique hash identifier string of the underlying C++ particle object.
     * @details This read-only property provides access to the particle's unique identifier.
     *          **Behavior:**
     *          1. Accesses the `hash` member of the C++ object (`self.ptr.hash`), which is a `std::string`.
     *          2. Uses the `env()` helper function to decode the C++ `std::string` into a standard Python `str` object.
     *          3. Returns the resulting Python string.
     * @return str The unique hash string identifying this particle instance.
     */
    @property
    def hash(self) -> str: pass

    /**
     * @property index
     * @brief Gets the integer index associated with the particle, typically from the original data source.
     * @details This read-only property accesses an index value often used to link the particle back to its entry in an input file or event record.
     *          **Behavior:**
     *          1. Accesses the `index` member within the nested `data` struct of the C++ object (`self.ptr.data.index`).
     *          2. Returns the integer value.
     * @return int The particle index.
     */
    @property
    def index(self) -> int: pass

    /**
     * @property px
     * @brief Gets the x-component of the particle's momentum (Px), typically in GeV.
     * @details Provides read access to the Px kinematic variable.
     *          **Behavior:**
     *          1. Accesses the `px` member (a `double`) of the C++ object (`self.ptr.px`).
     *          2. Returns the `double` value, which Cython automatically converts to a Python `float`.
     * @return double The Px value (as a Python float).
     */
    @property
    def px(self) -> double: pass

    /**
     * @property py
     * @brief Gets the y-component of the particle's momentum (Py), typically in GeV.
     * @details Provides read access to the Py kinematic variable.
     *          **Behavior:**
     *          1. Accesses the `py` member (a `double`) of the C++ object (`self.ptr.py`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The Py value (as a Python float).
     */
    @property
    def py(self) -> double: pass

    /**
     * @property pz
     * @brief Gets the z-component (longitudinal) of the particle's momentum (Pz), typically in GeV.
     * @details Provides read access to the Pz kinematic variable.
     *          **Behavior:**
     *          1. Accesses the `pz` member (a `double`) of the C++ object (`self.ptr.pz`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The Pz value (as a Python float).
     */
    @property
    def pz(self) -> double: pass

    /**
     * @property pt
     * @brief Gets the transverse momentum (Pt = sqrt(Px² + Py²)) of the particle, typically in GeV.
     * @details Provides read access to the Pt kinematic variable. The C++ object is expected to maintain consistency between Pt, Px, and Py.
     *          **Behavior:**
     *          1. Accesses the `pt` member (a `double`) of the C++ object (`self.ptr.pt`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The Pt value (as a Python float).
     */
    @property
    def pt(self) -> double: pass

    /**
     * @property eta
     * @brief Gets the pseudorapidity (η) of the particle.
     * @details Provides read access to the eta kinematic variable. The C++ object is expected to maintain consistency between eta and the momentum components.
     *          **Behavior:**
     *          1. Accesses the `eta` member (a `double`) of the C++ object (`self.ptr.eta`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The eta value (as a Python float).
     */
    @property
    def eta(self) -> double: pass

    /**
     * @property phi
     * @brief Gets the azimuthal angle (φ) of the particle, typically in radians.
     * @details Provides read access to the phi kinematic variable (angle in the transverse plane). The C++ object is expected to maintain consistency between phi, Px, and Py.
     *          **Behavior:**
     *          1. Accesses the `phi` member (a `double`) of the C++ object (`self.ptr.phi`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The phi value (as a Python float), usually in the range [-π, π] or [0, 2π].
     */
    @property
    def phi(self) -> double: pass

    /**
     * @property e
     * @brief Gets the total energy (E) of the particle, typically in GeV.
     * @details Provides read access to the energy component of the four-momentum.
     *          **Behavior:**
     *          1. Accesses the `e` member (a `double`) of the C++ object (`self.ptr.e`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The energy value (as a Python float).
     */
    @property
    def e(self) -> double: pass

    /**
     * @property Mass
     * @brief Gets the invariant mass (M = sqrt(E² - P²)) of the particle, typically in GeV.
     * @details Provides read access to the invariant mass. The C++ object is expected to maintain consistency between mass, energy, and momentum. Note the capitalization 'Mass'.
     *          **Behavior:**
     *          1. Accesses the `mass` member (a `double`) of the C++ object (`self.ptr.mass`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The invariant mass value (as a Python float).
     */
    @property
    def Mass(self) -> double: pass

    /**
     * @property charge
     * @brief Gets the electric charge of the particle, typically in units of elementary charge |e|.
     * @details Provides read access to the particle's charge.
     *          **Behavior:**
     *          1. Accesses the `charge` member (a `double`) of the C++ object (`self.ptr.charge`).
     *          2. Returns the `double` value as a Python `float`.
     * @return double The charge value (as a Python float).
     */
    @property
    def charge(self) -> double: pass

    /**
     * @property pdgid
     * @brief Gets the Particle Data Group ID (PDG ID) identifying the particle type.
     * @details Provides read access to the integer PDG code.
     *          **Behavior:**
     *          1. Accesses the `pdgid` member (an `int`) of the C++ object (`self.ptr.pdgid`).
     *          2. Returns the `int` value.
     * @return int The PDG ID.
     */
    @property
    def pdgid(self) -> int: pass

    /**
     * @property symbol
     * @brief Gets the human-readable particle symbol string (e.g., "e-", "gamma", "jet").
     * @details Provides read access to the symbolic representation.
     *          **Behavior:**
     *          1. Accesses the `symbol` member of the C++ object (`self.ptr.symbol`), which is a `std::string`.
     *          2. Uses the `env()` helper function to decode the C++ `std::string` into a Python `str`.
     *          3. Returns the resulting Python string.
     * @return str The particle symbol string.
     */
    @property
    def symbol(self) -> str : pass

    /**
     * @property Type
     * @brief Gets the type identifier string for the particle (e.g., "Electron", "Jet", "MET"). Note the capitalization 'Type'.
     * @details Provides read access to a potentially analysis-specific type classification string. This accesses the `type` member within the *nested `data` struct*.
     *          **Behavior:**
     *          1. Accesses the `type` member within the `data` struct of the C++ object (`self.ptr.data.type`), which is a `std::string`.
     *          2. Uses the `env()` helper function to decode the C++ `std::string` into a Python `str`.
     *          3. Returns the resulting Python string.
     * @return str The particle type string stored in `data.type`.
     */
    @property
    def Type(self) -> str: pass

    /**
     * @property lepdef
     * @brief Gets the C++ `std::vector<int>` containing lepton definition information.
     * @details Provides direct access to the vector storing integer codes or flags related to how the particle (if it's a lepton) was defined or identified in the analysis. The specific meaning of the integers is context-dependent.
     *          **Behavior:**
     *          1. Accesses the `lepdef` member within the `data` struct of the C++ object (`self.ptr.data.lepdef`), which is a `vector[int]`.
     *          2. Returns the C++ `vector[int]` object itself. Cython allows this object to be returned to Python. It can often be implicitly converted to a Python list if needed (e.g., `list(particle.lepdef)`), but direct access returns the C++ vector proxy.
     * @return vector[int] The C++ vector containing lepton definition integers.
     */
    @property
    def lepdef(self) -> vector[int]: pass

    /**
     * @property nudef
     * @brief Gets the C++ `std::vector<int>` containing neutrino definition information.
     * @details Provides direct access to the vector storing integer codes or flags related to how the particle (if it's a neutrino or related to one) was defined, reconstructed, or identified. The meaning of the integers is context-dependent.
     *          **Behavior:**
     *          1. Accesses the `nudef` member within the `data` struct of the C++ object (`self.ptr.data.nudef`), which is a `vector[int]`.
     *          2. Returns the C++ `vector[int]` object itself, similar to `lepdef`.
     * @return vector[int] The C++ vector containing neutrino definition integers.
     */
    @property
    def nudef(self) -> vector[int]: pass

    /**
     * @property is_lep
     * @brief Gets the boolean flag indicating if the particle is classified as a lepton (e, mu, tau).
     * @details Provides read access to the `is_lep` flag.
     *          **Behavior:**
     *          1. Accesses the `is_lep` member (a `bool`) of the C++ object (`self.ptr.is_lep`).
     *          2. Returns the boolean value.
     * @return bool True if classified as a lepton, False otherwise.
     */
    @property
    def is_lep(self) -> bool: pass

    /**
     * @property is_nu
     * @brief Gets the boolean flag indicating if the particle is classified as a neutrino.
     * @details Provides read access to the `is_nu` flag.
     *          **Behavior:**
     *          1. Accesses the `is_nu` member (a `bool`) of the C++ object (`self.ptr.is_nu`).
     *          2. Returns the boolean value.
     * @return bool True if classified as a neutrino, False otherwise.
     */
    @property
    def is_nu(self) -> bool: pass

    /**
     * @property is_b
     * @brief Gets the boolean flag indicating if the particle is related to a b-quark (e.g., b-jet, B-hadron).
     * @details Provides read access to the `is_b` flag, often related to b-tagging information.
     *          **Behavior:**
     *          1. Accesses the `is_b` member (a `bool`) of the C++ object (`self.ptr.is_b`).
     *          2. Returns the boolean value.
     * @return bool True if identified as b-related, False otherwise.
     */
    @property
    def is_b(self) -> bool: pass

    /**
     * @property is_add
     * @brief Gets the boolean flag indicating if the particle was created by adding other particles (e.g., via `p1 + p2`).
     * @details Provides read access to the `is_add` flag, useful for identifying composite particles.
     *          **Behavior:**
     *          1. Accesses the `is_add` member (a `bool`) of the C++ object (`self.ptr.is_add`).
     *          2. Returns the boolean value.
     * @return bool True if the particle is the result of an addition operation, False otherwise.
     */
    @property
    def is_add(self) -> bool: pass

    /**
     * @property LeptonicDecay
     * @brief Gets the boolean flag indicating if the particle is associated with a leptonic decay process. Note the capitalization 'LeptonicDecay'.
     * @details Provides read access to the `lep_decay` flag.
     *          **Behavior:**
     *          1. Accesses the `lep_decay` member (a `bool`) of the C++ object (`self.ptr.lep_decay`).
     *          2. Returns the boolean value.
     * @return bool True if associated with a leptonic decay, False otherwise.
     */
    @property
    def LeptonicDecay(self) -> bool: pass

    // --- Properties (Setters) ---

    /**
     * @brief Sets the particle's integer index. Includes fallback mechanisms.
     * @details Attempts to set the `index` member within the C++ `particle_t` data structure. If the direct assignment fails (e.g., due to a type mismatch if `val` is not an integer), it tries to store the value as a string attribute in the C++ `leaves` map, and failing that, sets it as a Python attribute.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries to assign `val` directly to `self.ptr.data.index`. This works if `val` is an integer or implicitly convertible.
     *          2.  **Fallback 1: Store in C++ `leaves`:** If the direct assignment raises an exception (caught by `except *`), it attempts to store the value as a string in the C++ `leaves` map. It encodes the key "index" and the value `val` using `enc()` and calls `self.ptr.add_leaf(b'index', enc(val))`.
     *          3.  **Fallback 2: Store in Python `__dict__`:** If the call to `add_leaf` also fails (caught by `except *`), it performs a final fallback by assigning the value directly to the Python object's instance dictionary: `self.__dict__["index"] = val`. This stores the index only at the Python level.
     * @param val The value (preferably an integer) to set as the index. Non-integer types might be stored as string leaves or Python attributes.
     */
    @index.setter
    def index(self, val): pass

    /**
     * @brief Sets the x-component of the particle's momentum (Px). Includes fallback.
     * @details Attempts to set the `px` member (a `double`) of the C++ object. If the assignment fails (e.g., `val` is not a number), it falls back to storing the value as a string attribute in the C++ `leaves` map.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.px = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'px', enc(val))`.
     * @note Modifying a kinematic variable like Px might trigger internal recalculations within the C++ object (e.g., updating Pt, Eta, Phi, E, Mass via calls to `to_polar` or similar) to maintain four-vector consistency, depending on the C++ implementation.
     * @param val The value (preferably float/double) to set as Px. Other types might be stored as leaves.
     */
    @px.setter
    def px(self, val): pass

    /**
     * @brief Sets the y-component of the particle's momentum (Py). Includes fallback.
     * @details Attempts to set the `py` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.py = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'py', enc(val))`.
     * @note Setting Py might trigger internal recalculations of other kinematic variables in C++.
     * @param val The value (preferably float/double) to set as Py. Other types might be stored as leaves.
     */
    @py.setter
    def py(self, val): pass

    /**
     * @brief Sets the z-component of the particle's momentum (Pz). Includes fallback.
     * @details Attempts to set the `pz` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.pz = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'pz', enc(val))`.
     * @note Setting Pz might trigger internal recalculations of other kinematic variables (like Eta) in C++.
     * @param val The value (preferably float/double) to set as Pz. Other types might be stored as leaves.
     */
    @pz.setter
    def pz(self, val): pass

    /**
     * @brief Sets the transverse momentum (Pt) of the particle. Includes fallback.
     * @details Attempts to set the `pt` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.pt = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'pt', enc(val))`.
     * @note Setting Pt directly likely requires the C++ object to recalculate Px and Py (and potentially other variables) to maintain consistency, possibly by calling `to_cartesian` internally. The exact behavior depends on the C++ implementation.
     * @param val The value (preferably float/double) to set as Pt. Other types might be stored as leaves.
     */
    @pt.setter
    def pt(self, val): pass

    /**
     * @brief Sets the pseudorapidity (η) of the particle. Includes fallback.
     * @details Attempts to set the `eta` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.eta = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'eta', enc(val))`.
     * @note Setting eta directly likely requires the C++ object to recalculate Pz (and potentially other variables) to maintain consistency, possibly by calling `to_cartesian` internally.
     * @param val The value (preferably float/double) to set as eta. Other types might be stored as leaves.
     */
    @eta.setter
    def eta(self, val): pass

    /**
     * @brief Sets the azimuthal angle (φ) of the particle. Includes fallback.
     * @details Attempts to set the `phi` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.phi = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'phi', enc(val))`.
     * @note Setting phi directly likely requires the C++ object to recalculate Px and Py (and potentially other variables) to maintain consistency, possibly by calling `to_cartesian` internally. The value should typically be provided in radians.
     * @param val The value (preferably float/double, in radians) to set as phi. Other types might be stored as leaves.
     */
    @phi.setter
    def phi(self, val): pass

    /**
     * @brief Sets the total energy (E) of the particle. Includes fallback.
     * @details Attempts to set the `e` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.e = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'e', enc(val))`.
     * @note Setting energy directly might require the C++ object to recalculate momentum components or mass to maintain four-vector consistency, depending on its implementation.
     * @param val The value (preferably float/double) to set as energy. Other types might be stored as leaves.
     */
    @e.setter
    def e(self, val): pass

    /**
     * @brief Sets the invariant mass (M) of the particle. Includes fallback. Note the capitalization 'Mass'.
     * @details Attempts to set the `mass` member (a `double`) of the C++ object. Falls back to storing in `leaves` (using key 'Mass') on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.mass = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'Mass', enc(val))`.
     * @note Setting mass directly might require the C++ object to recalculate energy or momentum components to maintain four-vector consistency.
     * @param val The value (preferably float/double) to set as mass. Other types might be stored as leaves.
     */
    @Mass.setter
    def Mass(self, val): pass

    /**
     * @brief Sets the electric charge of the particle. Includes fallback.
     * @details Attempts to set the `charge` member (a `double`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.charge = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'charge', enc(val))`.
     * @param val The value (preferably float/double) to set as charge. Other types might be stored as leaves.
     */
    @charge.setter
    def charge(self, val): pass

    /**
     * @brief Sets the Particle Data Group ID (PDG ID) of the particle. Includes fallback.
     * @details Attempts to set the `pdgid` member (an `int`) of the C++ object. Falls back to storing in `leaves` on failure.
     *          **Behavior:**
     *          1.  **Attempt Direct C++ Assignment:** Tries `self.ptr.pdgid = val`.
     *          2.  **Fallback: Store in C++ `leaves`:** If an exception occurs, calls `self.ptr.add_leaf(b'pdgid', enc(val))`.
     * @param val The value (preferably int) to set as PDG ID. Other types might be stored as leaves.
     */
    @pdgid.setter
    def pdgid(self, val): pass

    /**
     * @brief Sets the particle symbol string.
     * @details Sets the `symbol` member (a `std::string`) of the C++ object.
     *          **Behavior:**
     *          1. Encodes the input Python string `val` into a format suitable for C++ `std::string` assignment using the `enc()` helper function.
     *          2. Assigns the encoded result directly to `self.ptr.symbol`.
     * @param val The particle symbol string (e.g., "e-", "gamma") to set. Cython type hint `str val` enforces string input.
     * @throw TypeError If `val` is not a string (enforced by Cython). May propagate exceptions from `enc()` if encoding fails.
     */
    @symbol.setter
    def symbol(self, str val): pass

    /**
     * @brief Sets the particle type identifier string stored in the `data` struct. Note the capitalization 'Type'.
     * @details Sets the `type` member (a `std::string`) within the nested `data` struct of the C++ object.
     *          **Behavior:**
     *          1. Encodes the input Python string `val` using the `enc()` helper function.
     *          2. Assigns the encoded result directly to `self.ptr.data.type`.
     * @param val The particle type string (e.g., "Electron", "Jet") to set. Cython type hint `str val` enforces string input.
     * @throw TypeError If `val` is not a string (enforced by Cython). May propagate exceptions from `enc()`.
     */
    @Type.setter
    def Type(self, str val): pass

    /**
     * @brief Sets the lepton definition vector stored in the `data` struct.
     * @details Replaces the content of the `lepdef` member (a `vector[int]`) within the nested `data` struct of the C++ object with the provided vector `val`.
     *          **Behavior:**
     *          1. Assigns the input C++ `vector[int]` object `val` directly to `self.ptr.data.lepdef`. If a Python list of integers is passed, Cython typically handles the conversion automatically.
     * @param val The C++ `vector[int]` (or compatible Python list of ints) containing the lepton definition integers to set. Cython type hint `vector[int] val` enforces compatibility.
     * @throw TypeError If `val` cannot be converted to a `vector[int]` (checked by Cython).
     */
    @lepdef.setter
    def lepdef(self, vector[int] val): pass

    /**
     * @brief Sets the neutrino definition vector stored in the `data` struct.
     * @details Replaces the content of the `nudef` member (a `vector[int]`) within the nested `data` struct of the C++ object with the provided vector `val`.
     *          **Behavior:**
     *          1. Assigns the input C++ `vector[int]` object `val` directly to `self.ptr.data.nudef`. Python lists of integers are typically converted automatically by Cython.
     * @param val The C++ `vector[int]` (or compatible Python list of ints) containing the neutrino definition integers to set. Cython type hint `vector[int] val` enforces compatibility.
     * @throw TypeError If `val` cannot be converted to a `vector[int]` (checked by Cython).
     */
    @nudef.setter
    def nudef(self, vector[int] val): pass

    # --- Parent/Child Properties ---

    /**
     * @property Children
     * @brief Gets a list of direct child particles as Python `ParticleTemplate` objects (read-only access via this getter). Uses lazy-loading cache.
     * @details Provides access to the direct descendants of this particle in the event graph. To optimize performance, it employs a lazy-loading strategy using the internal `self.children` list as a cache for Python wrapper objects.
     *
     *          **Getter Behavior:**
     *          1.  **Check Cache:** Checks if the Python list `self.children` has already been populated (i.e., `len(self.children) > 0`).
     *          2.  **Cache Hit:** If the cache is populated, it returns a unique list derived from the cache: `list(set(self.children))`. Using `set` ensures uniqueness even if the cache somehow contained duplicates (though ideally the setter prevents this) but means the order of children returned might not be deterministic or match the insertion order.
     *          3.  **Cache Miss:** If the cache is empty:
     *              - **Create Wrappers:** Calls the internal helper `self.make_particle(self.ptr.children)`. This function iterates through the C++ `children` map (`std::map<string, particle_template*>`), creates a *non-owning* (`is_owner=False`) `ParticleTemplate` Python wrapper for each C++ child pointer found, and returns these wrappers in a new list.
     *              - **Populate Cache:** Appends the newly created wrappers returned by `make_particle` to the `self.children` cache list using `self.children.extend(...)`.
     *              - **Return Unique List:** Returns a unique list derived from the now-populated cache: `list(set(self.children))`.
     *
     * @return list[ParticleTemplate] A list containing unique `ParticleTemplate` instances representing the direct children of this particle. The returned wrappers are non-owning (`is_owner=False`) references to the underlying C++ child objects.
     * @note The first access to this property triggers the creation of Python wrapper objects for all C++ children, which are then cached. Subsequent accesses are faster as they retrieve wrappers from the cache. The use of `set` for uniqueness might alter the original order of children.
     */
    @property
    def Children(self) -> list: pass

    /**
     * @brief Sets or modifies the children of this particle, updating relationships in both C++ and the Python cache.
     * @details This setter allows users to define the direct descendants of the particle. It handles clearing existing children, setting a new list of children, or adding individual children. It ensures that the changes are reflected in the underlying C++ relationship maps (`self.ptr.children` and the `parents` map of the child objects) and the Python cache (`self.children`).
     *
     *          **Setter Behavior:**
     *          - **Clearing Children (`inpt` is `None` or empty list `[]`):**
     *              - Clears the C++ children map: `self.ptr.children.clear()`. (Note: This breaks the C++ link but doesn't automatically update the former children's `parents` map. The C++ `particle_template` destructor or a dedicated `removeChild` method might be needed for full C++ graph consistency if children can be removed individually).
     *              - Resets the Python cache to an empty list: `self.children = []`.
     *          - **Setting/Adding Children (List Input `inpt = [p1, p2, ...]`):**
     *              - Iterates through each `ParticleTemplate` object `p` in the input list `inpt`.
     *              - Gets the C++ pointer of the potential child: `ptx = p.ptr`.
     *              - Calls the C++ method `self.ptr.register_child(ptx)`. This method attempts to:
     *                  - Add `ptx` to this particle's C++ `children` map (keyed by `ptx->hash`).
     *                  - Add `self.ptr` to the child's C++ `parents` map (by calling `ptx->register_parent(self.ptr)` internally).
     *                  - Returns `True` if registration was successful (e.g., not a duplicate), `False` otherwise.
     *              - **Update Python Cache:** If `register_child` returns `True`, the Python wrapper `p` is appended to the `self.children` cache list. (Note: The code uses `self.children += [p]`, which appends. If the intention was to *replace* the children with the input list, the cache should ideally be cleared first, similar to the `inpt is None` case, before appending).
     *          - **Setting/Adding Children (Single Instance Input `inpt = p`):**
     *              - If `inpt` is a single `ParticleTemplate` instance (detected by `else` block after checking for list/None), the code executes `self.Children += [inpt]`.
     *              - This recursively calls the setter, but the `+=` operation on a property might be interpreted by Python/Cython as appending to the existing list rather than replacing. It effectively delegates the addition of the single item `p` to the list-handling logic, resulting in the child `p` being appended to the current list of children (both in C++ via `register_child` and in the Python cache).
     *
     * @param inpt The particle(s) to be set as children. Accepts:
     *             - `list[ParticleTemplate]`: A list of particles to become children. The current implementation appends these to the existing children after C++ registration. Consider clearing first if replacement is desired.
     *             - `ParticleTemplate`: A single particle instance to add as a child (appends to existing children).
     *             - `None` or `[]`: Clears all existing children from the C++ map and Python cache.
     * @note This operation modifies the C++ object graph by calling `register_child` (which affects both parent and child objects in C++) and updates the Python `self.children` cache. The exact behavior when setting a list (append vs. replace) depends on the interpretation of the code; explicit clearing might be safer for replacement semantics. Assumes input particles are valid `ParticleTemplate` instances.
     */
    @Children.setter
    def Children(self, inpt): pass

    /**
     * @property Parents
     * @brief Gets a list of direct parent particles as Python `ParticleTemplate` objects (read-only access via this getter). Uses lazy-loading cache.
     * @details Provides access to the direct ancestors of this particle. Similar to `Children`, it uses the internal `self.parents` list as a lazy-loading cache.
     *
     *          **Getter Behavior:**
     *          1.  **Check Cache:** Checks if `self.parents` is populated (`len(self.parents) > 0`).
     *          2.  **Cache Hit:** If populated, returns `list(set(self.parents))` (unique list from cache, order might change).
     *          3.  **Cache Miss:** If empty:
     *              - **Create Wrappers:** Calls `self.make_particle(self.ptr.parents)` to create non-owning (`is_owner=False`) Python wrappers for each C++ parent pointer in the `self.ptr.parents` map.
     *              - **Populate Cache:** Appends the new wrappers to `self.parents` using `self.parents.extend(...)`.
     *              - **Return Unique List:** Returns `list(set(self.parents))`.
     *
     * @return list[ParticleTemplate] A list containing unique `ParticleTemplate` instances representing the direct parents of this particle. Wrappers are non-owning (`is_owner=False`).
     * @note First access triggers wrapper creation and caching. Subsequent accesses use the cache. Uniqueness via `set` may affect order.
     */
    @property
    def Parents(self) -> list: pass

    /**
     * @brief Sets or modifies the parents of this particle, updating relationships in C++ and the Python cache.
     * @details Allows defining the direct ancestors of the particle, mirroring the `Children` setter functionality. Ensures consistency between the C++ graph and the Python cache.
     *
     *          **Setter Behavior:**
     *          - **Clearing Parents (`inpt` is `None` or empty list `[]`):**
     *              - Clears the C++ parents map: `self.ptr.parents.clear()`. (Similar caveat as `Children.setter`: this breaks the link from this particle to its parents but doesn't automatically update the former parents' `children` map in C++).
     *              - Resets the Python cache: `self.parents = []`.
     *          - **Setting/Adding Parents (List Input `inpt = [p1, p2, ...]`):**
     *              - Iterates through each `ParticleTemplate` object `p` in `inpt`.
     *              - Gets the C++ pointer: `ptx = p.ptr`.
     *              - Calls `self.ptr.register_parent(ptx)`. This C++ method attempts to:
     *                  - Add `ptx` to this particle's C++ `parents` map.
     *                  - Add `self.ptr` to the parent's C++ `children` map (via `ptx->register_child(self.ptr)` internally).
     *                  - Returns `True` on success.
     *              - **Update Python Cache:** If `register_parent` returns `True`, appends the Python wrapper `p` to the `self.parents` cache list (`self.parents += [p]`). (Append vs. replace semantics apply as discussed for `Children.setter`).
     *          - **Setting/Adding Parents (Single Instance Input `inpt = p`):**
     *              - Executes `self.Parents += [inpt]`, recursively calling the setter to append the single parent `p` to the current list (in C++ via `register_parent` and in the Python cache).
     *
     * @param inpt The particle(s) to be set as parents. Accepts:
     *             - `list[ParticleTemplate]`: List of particles to become parents (appended by current implementation).
     *             - `ParticleTemplate`: Single particle instance to add as a parent (appended).
     *             - `None` or `[]`: Clears all existing parents.
     * @note Modifies the C++ object graph via `register_parent` and updates the Python `self.parents` cache. Assumes input particles are valid `ParticleTemplate` instances. Consider clearing the cache/C++ map explicitly before appending if replacement semantics are desired when setting a list.
     */
    @Parents.setter
    def Parents(self, inpt): pass

