/**
 * @file notification.pxd / notification.pyx
 * @brief Cython interface definition (.pxd) and implementation (.pyx) for the C++ notification system.
 * @details This documentation covers both the Cython interface declaration (`.pxd`) and the
 *          Python wrapper class implementation (`.pyx`) that bridge Python applications with
 *          the underlying C++ `notification` class. It facilitates the use of a high-performance
 *          C++ notification and progress tracking system directly from Python, minimizing overhead.
 *
 *          The `.pxd` part declares the C++ interface, making the C++ `notification` class and its
 *          members known to Cython. It specifies how C++ exceptions should be handled (`except+`)
 *          and when the Global Interpreter Lock (GIL) can be released (`nogil`).
 *
 *          The `.pyx` part defines the `Notification` `cdef class`, which acts as a Pythonic
 *          wrapper around a C++ `notification` object instance. This class manages the lifecycle
 *          (creation/destruction) of the C++ object and provides Python methods that call the
 *          corresponding C++ functions, handling type conversions and GIL management automatically.
 *
 *          The system exposes functions for displaying various status messages (success, warning,
 *          failure, info) and rendering different styles of progress bars, including sophisticated
 *          visualizations for multi-threaded operations.
 *
 * @section features Key Features
 * - **Typed Status Messages:** Provides distinct functions (`success`, `warning`, `failure`, `info`)
 *   for displaying messages categorized by severity or purpose. The C++ backend typically handles
 *   visual differentiation (e.g., colors, icons).
 * - **Versatile Progress Indication:** Offers multiple functions for rendering progress bars:
 *     - `progressbar`: A standard progress bar showing percentage completion (0.0 to 1.0).
 *     - `progressbar1`, `progressbar2`: Specialized progress bars for tracking multi-threaded
 *       progress based on aggregated counters against a single total.
 *     - `progressbar3`: An advanced multi-threaded progress bar supporting multiple counters,
 *       totals, and titles for complex scenarios.
 * - **Output Customization:** Allows configuration of the output appearance via properties:
 *     - `prefix`: A string prepended to all messages for context or identification.
 *     - `bold`: A boolean flag to render the primary message text in bold.
 *     - `shush`: A boolean flag to completely suppress all output (quiet mode).
 * - **Performance Optimization (nogil):** Utilizes the `nogil` directive on calls to C++ methods.
 *   This releases the Python Global Interpreter Lock (GIL) during the execution of potentially
 *   long-running C++ code (like I/O or computation). This allows other Python threads to execute
 *   concurrently, significantly improving performance in multi-threaded Python applications.
 * - **Robust Exception Handling (except+):** Employs the `except+` specifier when declaring C++
 *   methods in the `.pxd` file. This instructs Cython to automatically generate code that catches
 *   C++ exceptions thrown by the native code, translates them into appropriate Python exceptions
 *   (e.g., `RuntimeError`, `MemoryError`, `std::exception` subclasses mapped to Python equivalents),
 *   and raises them in the Python environment. This prevents application crashes and allows for
 *   standard Python `try...except` error handling.
 * - **Message Counting:** The underlying C++ class maintains internal counters (`_warning`, `_failure`,
 *   `_success`, `_info`) for each status message type. These counts are exposed to Python as
 *   read-only properties (`warning_count`, `failure_count`, etc.) on the `Notification` object,
 *   allowing applications to query the summary of notifications displayed.
 * - **RAII for C++ Object Lifetime:** The `Notification` Cython class manages the C++ `notification`
 *   object's lifetime using the Resource Acquisition Is Initialization (RAII) pattern adapted for
 *   Python's garbage collection. The C++ object is allocated in `__init__` and deallocated in
 *   `__dealloc__`, ensuring resources are cleaned up automatically when the Python wrapper object
 *   is no longer referenced.
 *
 * @section cpp_interface C++ Interface Declaration (Conceptual .pxd Content)
 * @brief This section describes the elements typically declared in the `.pxd` file to expose the C++
 *        `notification` class to Cython.
 *
 * @subsection cpp_extern_block C++ Header Inclusion (`cdef extern from`)
 * @details The `.pxd` file uses `cdef extern from "<notification/notification.h>" nogil:`
 *          to declare that the following definitions correspond to entities defined in the
 *          specified C++ header file. The `nogil` keyword here suggests that functions
 *          declared within this block might be suitable for calling without the GIL, although
 *          `nogil` is typically applied per-function call in the `.pyx` file or per-method
 *          declaration here.
 *
 * @subsection cpp_class_decl C++ Class Declaration (`cdef cppclass notification`)
 * @details Declares the existence of the C++ class `notification` to Cython. This allows Cython
 *          code to create pointers to, allocate, and call methods on objects of this C++ class.
 *
 * @subsection cpp_methods_decl C++ Method Declarations
 * @details These declarations mirror the C++ methods, specifying their signatures and adding
 *          Cython directives for exception handling and GIL management.
 * - `void success(string msg) except+ nogil`: Declares the C++ `success` method. `except+` enables
 *   automatic C++ to Python exception translation. `nogil` indicates the method is safe to call
 *   without the GIL.
 * - `void warning(string msg) except+ nogil`: Declares the C++ `warning` method with exception
 *   translation and GIL release. Increments the warning counter.
 * - `void failure(string msg) except+ nogil`: Declares the C++ `failure` method with exception
 *   translation and GIL release. Increments the failure counter.
 * - `void info(string msg) except+ nogil`: Declares the C++ `info` method with exception
 *   translation and GIL release. Increments the info counter.
 * - `void progressbar(float prg, string title) except+ nogil`: Declares the C++ `progressbar` method.
 * - `void progressbar1(vector[unsigned long long]* threads, unsigned long long* l, string* title) except+ nogil`:
 *   Declares the C++ `progressbar1` method for multi-threaded progress (variant 1). Note the use
 *   of pointers (`*`) for potentially large data structures or output parameters passed from C++.
 * - `void progressbar2(vector[unsigned long long]* threads, unsigned long long* l, string* title) except+ nogil`:
 *   Declares the C++ `progressbar2` method (variant 2).
 * - `void progressbar3(vector[unsigned long long]* threads, vector[unsigned long long]* l, vector[string*]* title) except+ nogil`:
 *   Declares the C++ `progressbar3` method (advanced variant 3).
 *
 * @subsection cpp_attributes_decl C++ Attribute Declarations
 * @details These declarations expose the C++ class member variables to Cython, allowing the
 *          wrapper class to access or modify them directly (though often access is managed
 *          via Python properties).
 * - `string prefix`: Exposes the C++ `std::string prefix` member.
 * - `int _warning`: Exposes the C++ `int _warning` counter.
 * - `int _failure`: Exposes the C++ `int _failure` counter.
 * - `int _success`: Exposes the C++ `int _success` counter.
 * - `int _info`: Exposes the C++ `int _info` counter.
 * - `bool bold`: Exposes the C++ `bool bold` flag (Cython maps C++ `bool` to `bint`).
 * - `bool shush`: Exposes the C++ `bool shush` flag.
 *
 * @example example_usage.py
 * @brief Demonstrates basic usage of the Notification class from Python.
 *
 * @code{.py}
 * from AnalysisG.core.notification import Notification
 * import time
 * import random
 *
 * # Create a Notification object. This allocates the C++ object.
 * notif = Notification()
 * print("Notification object created.")
 *
 * # Configure the notification appearance
 * notif.prefix = "[MyTask] "
 * notif.bold = True
 *
 * # Display status messages
 * notif.info("Starting the process...")
 * notif.success("Configuration loaded successfully.")
 * notif.warning("Optional component 'X' not found, proceeding without it.")
 *
 * # Simulate a simple progress bar
 * print("\n--- Simple Progress ---")
 * notif.progressbar(0.0, "Initializing...")
 * time.sleep(0.5)
 * for i in range(11):
 *     progress = i / 10.0
 *     notif.progressbar(progress, f"Processing item {i}/10")
 *     time.sleep(0.2)
 * notif.success("Simple processing complete.")
 *
 * # Simulate a multi-threaded progress bar (variant 1)
 * print("\n--- Multi-threaded Progress (Variant 1) ---")
 * num_threads = 4
 * total_items = 100
 * thread_progress = [0] * num_threads
 * notif.progressbar1(thread_progress, total_items, "Aggregated Task")
 * time.sleep(0.5)
 * completed_items = 0
 * while completed_items < total_items:
 *     # Simulate work in random threads
 *     thread_idx = random.randint(0, num_threads - 1)
 *     if thread_progress[thread_idx] < total_items / num_threads: # Simple distribution
 *         increment = random.randint(1, 3)
 *         thread_progress[thread_idx] += increment
 *         completed_items = sum(thread_progress)
 *         # Clamp progress if overshot (example logic)
 *         if completed_items > total_items:
 *             diff = completed_items - total_items
 *             thread_progress[thread_idx] -= diff # Adjust last increment
 *             completed_items = total_items
 *
 *         # Update progress bar - Pass the list and total
 *         notif.progressbar1(thread_progress, total_items, f"Aggregated Task ({completed_items}/{total_items})")
 *     time.sleep(0.05)
 * notif.success("Multi-threaded task complete.")
 *
 * # Display a failure message
 * notif.failure("Failed to process final report.")
 *
 * # Check the message counts
 * print("\n--- Final Counts ---")
 * print(f"Success messages: {notif.success_count}")
 * print(f"Warning messages: {notif.warning_count}")
 * print(f"Failure messages: {notif.failure_count}")
 * print(f"Info messages: {notif.info_count}")
 *
 * # The C++ object is automatically cleaned up when 'notif' goes out of scope
 * # or is explicitly deleted and garbage collected. When the reference count
 * # of the Python 'notif' object drops to zero,
 * # its __dealloc__ method will be called automatically by Python's
 * # garbage collector, which in turn deletes the C++ object.
 * print("Deleting Notification object reference...")
 * del notif
 * print("Notification object reference deleted; C++ object cleaned up.")
 * @endcode
 */

/**
 * @brief Cython directive specifying the source language as C++.
 * @details This pragma instructs Cython to generate C++ code instead of C, which is necessary
 *          for interfacing with C++ libraries and classes like `std::string` and `std::vector`.
 */
// # distutils: language=c++

/**
 * @brief Cython directive setting the Python language level compatibility.
 * @details `language_level=3` enables Python 3 semantics, such as Unicode strings by default
 *          and modern syntax features. This is standard practice for current Cython projects.
 */
// # cython: language_level=3

/**
 * @brief Import necessary C++ standard library types into the Cython namespace.
 * @details This block imports fundamental C++ types required for the interface definition:
 *          - `bool`: The C++ boolean type.
 *          - `long`: A C++ integer type (mapping depends on platform).
 *          - `string`: The C++ standard string class (`std::string`).
 *          - `vector`: The C++ standard dynamic array template (`std::vector`).
 *          These imports allow Cython to understand and correctly handle these types when
 *          interacting with the C++ code declared in the `cdef extern from` block.
 */
// from libcpp cimport bool, long
// from libcpp.string cimport string
// from libcpp.vector cimport vector

/**
 * @brief Declare C++ entities defined in an external header file.
 * @details This `cdef extern from` block tells Cython about the C++ code defined in
 *          `<notification/notification.h>`. It allows Cython to generate the necessary
 *          bindings to call functions and use classes/structs from this header.
 * @param "<notification/notification.h>" The path to the C++ header file containing the
 *        declarations for the `notification` class.
 * @param nogil Indicates that functions declared within this block are potentially safe
 *        to call without the Python Global Interpreter Lock (GIL). While specified here,
 *        `nogil` is typically applied per-method declaration for finer control.
 */
cdef extern from "<notification/notification.h>" nogil:

    /**
     * @brief Declare the C++ class `notification` to Cython.
     * @details This declaration makes the C++ class `notification` known to Cython, allowing
     *          the creation of pointers (`notification*`) and calls to its methods from
     *          Cython code. It does not define the class, only declares its existence and
     *          the signatures of the members that Cython needs to interact with.
     */
    cdef cppclass notification:

        /**
         * @brief Declare the C++ `success` method.
         * @details Exposes the C++ `notification::success(std::string)` method.
         * @param string The C++ `std::string` type for the message argument.
         * @param except+ Instructs Cython to automatically generate code to catch C++ exceptions
         *        thrown by this method and translate them into Python exceptions.
         * @param nogil Indicates this C++ method is safe to call without holding the Python GIL,
         *        allowing for potential concurrency in multi-threaded Python applications.
         */
        void success(string) except+ nogil

        /**
         * @brief Declare the C++ `warning` method.
         * @details Exposes the C++ `notification::warning(std::string)` method. Handles C++
         *          exception translation (`except+`) and allows GIL release (`nogil`).
         *          Calling this method typically increments the internal warning counter.
         */
        void warning(string) except+ nogil

        /**
         * @brief Declare the C++ `failure` method.
         * @details Exposes the C++ `notification::failure(std::string)` method. Handles C++
         *          exception translation (`except+`) and allows GIL release (`nogil`).
         *          Calling this method typically increments the internal failure counter.
         */
        void failure(string) except+ nogil

        /**
         * @brief Declare the C++ `info` method.
         * @details Exposes the C++ `notification::info(std::string)` method. Handles C++
         *          exception translation (`except+`) and allows GIL release (`nogil`).
         *          Calling this method typically increments the internal info counter.
         */
        void info(string)    except+ nogil

        /**
         * @brief Declare the C++ `progressbar` method.
         * @details Exposes the C++ `notification::progressbar(float, std::string)` method
         *          for displaying a simple progress bar. Handles C++ exception translation
         *          (`except+`) and allows GIL release (`nogil`).
         * @param prg The progress value (typically 0.0 to 1.0).
         * @param title The title for the progress bar.
         */
        void progressbar(float prg, string title) except+ nogil

        /**
         * @brief Declare the C++ `progressbar1` method (multi-threaded variant 1).
         * @details Exposes the C++ `notification::progressbar1` method, likely designed for
         *          displaying progress aggregated from multiple threads or sources. It takes
         *          pointers to data structures. Handles C++ exception translation (`except+`)
         *          and allows GIL release (`nogil`).
         * @param threads Pointer to a `std::vector<unsigned long long>` containing per-thread progress counts.
         * @param l Pointer to an `unsigned long long` representing the total progress value.
         * @param title Pointer to a `std::string` for the progress bar title.
         */
        void progressbar1(vector[unsigned long long]* threads, unsigned long long* l, string* title) except+ nogil

        /**
         * @brief Declare the C++ `progressbar2` method (multi-threaded variant 2).
         * @details Exposes the C++ `notification::progressbar2` method, another variant for
         *          multi-threaded progress display. Similar signature to `progressbar1`, likely
         *          differing in C++ implementation details (e.g., visualization). Handles C++
         *          exception translation (`except+`) and allows GIL release (`nogil`).
         * @param threads Pointer to a `std::vector<unsigned long long>` of thread progress.
         * @param l Pointer to the `unsigned long long` total.
         * @param title Pointer to the `std::string` title.
         */
        void progressbar2(vector[unsigned long long]* threads, unsigned long long* l, string* title) except+ nogil

        /**
         * @brief Declare the C++ `progressbar3` method (advanced multi-component variant).
         * @details Exposes the C++ `notification::progressbar3` method, designed for complex
         *          scenarios with multiple progress components, each potentially having its own
         *          counts, total, and title. Handles C++ exception translation (`except+`) and
         *          allows GIL release (`nogil`).
         * @param threads Pointer to a `std::vector<unsigned long long>` of progress counts.
         * @param l Pointer to a `std::vector<unsigned long long>` of corresponding totals.
         * @param title Pointer to a `std::vector<std::string*>` (vector of string pointers) for titles.
         */
        void progressbar3(vector[unsigned long long]* threads, vector[unsigned long long]* l, vector[string*]* title) except+ nogil

        /**
         * @brief Declare the C++ `prefix` member variable.
         * @details Exposes the `std::string prefix` member of the C++ `notification` class,
         *          allowing the Cython wrapper to get/set its value.
         */
        string prefix

        /**
         * @brief Declare the C++ `_warning` counter member variable.
         * @details Exposes the `int _warning` member, used internally by the C++ class to
         *          count warning messages. Accessible via a read-only property in the Python wrapper.
         */
        int _warning

        /**
         * @brief Declare the C++ `_failure` counter member variable.
         * @details Exposes the `int _failure` member, used internally to count failure messages.
         *          Accessible via a read-only property in the Python wrapper.
         */
        int _failure

        /**
         * @brief Declare the C++ `_success` counter member variable.
         * @details Exposes the `int _success` member, used internally to count success messages.
         *          Accessible via a read-only property in the Python wrapper.
         */
        int _success

        /**
         * @brief Declare the C++ `_info` counter member variable.
         * @details Exposes the `int _info` member, used internally to count informational messages.
         *          Accessible via a read-only property in the Python wrapper.
         */
        int _info

        /**
         * @brief Declare the C++ `bold` flag member variable.
         * @details Exposes the `bool bold` member, controlling whether output text should be bold.
         *          Cython maps C++ `bool` to its `bint` type, which interfaces with Python `bool`.
         */
        bool bold

        /**
         * @brief Declare the C++ `shush` flag member variable.
         * @details Exposes the `bool shush` member, controlling whether all output should be suppressed (quiet mode).
         */
        bool shush

/**
 * @class Notification
 * @brief A Python-accessible Cython wrapper managing the lifetime and interface of a C++ `notification` object.
 *
 * @details This Cython `cdef class` (defined in the `.pyx` file) provides the primary bridge
 *          between Python code and the C++ `notification` functionality. It encapsulates a
 *          pointer to a C++ `notification` instance, managing its allocation (`__init__`) and
 *          deallocation (`__dealloc__`) automatically based on the Python object's lifetime.
 *          This ensures that the C++ resources are properly managed without requiring manual
 *          memory handling in Python.
 *
 *          The class exposes the C++ functionality through Python methods (`cpdef` methods like
 *          `success`, `warning`, etc.) and properties (like `prefix`, `bold`, `warning_count`).
 *          These methods handle the necessary type conversions between Python objects (e.g., `str`,
 *          `list`) and C++ types (e.g., `std::string`, `std::vector`), release the GIL during
 *          C++ calls for performance, and propagate C++ exceptions back to Python.
 *
 *          Refer to the file-level documentation sections for details on features, C++ interface,
 *          lifecycle management, methods, properties, and an example usage.
 */
cdef class Notification:
    /**
     * @var ptr
     * @brief A C pointer (`notification*`) to the underlying C++ `notification` object instance.
     * @details This member variable holds the memory address of the dynamically allocated C++
     *          `notification` object managed by this Python wrapper instance. It is initialized
     *          in `__init__` (after `__cinit__`) and the C++ object it points to is deleted in
     *          `__dealloc__`. While technically accessible, direct manipulation from Python is
     *          discouraged; interaction should occur through the class's methods and properties.
     *          It is primarily used internally by the Cython methods to call the C++ object's members.
     *          This pointer becomes invalid after the `Notification` object is garbage collected.
     *          It is initialized to `NULL` in `__cinit__`.
     */
    cdef notification* ptr

    # --- Lifecycle Methods (Conceptual Implementation in .pyx) ---

    # cpdef __cinit__(self):
    ##! @brief Special Cython Initialization Method (Phase 1).
    ##! @details Automatically called by Cython *before* `__init__` when a `Notification` object is
    ##!          instantiated. Its main purpose is to initialize C-level members (like pointers) to a
    ##!          safe default state (e.g., `self.ptr = NULL`). This ensures the object is in a
    ##!          predictable state before Python-level initialization (`__init__`) runs and guarantees
    ##!          that `__dealloc__` can safely check the state of these members even if `__init__` fails.
    ##! @param self The `Notification` instance being created.
    ##! @note This method is crucial for robust initialization in `cdef` classes managing C/C++ resources.
    ##!       It should **not** be called directly from Python code. If `__cinit__` raises an exception,
    ##!       `__init__` and `__dealloc__` will not be called. Keep logic here simple and unlikely to fail.
    ##! @warning Avoid complex operations or resource allocation within `__cinit__` itself, as cleanup
    ##!          via `__dealloc__` is not guaranteed if `__cinit__` fails.

    # cpdef __init__(self):
    ##! @brief Standard Python Initializer (Phase 2) - Allocates the C++ Resource.
    ##! @details Called after `__cinit__` succeeds. This method is responsible for allocating the
    ##!          underlying C++ `notification` object using `new notification()`. The pointer to the
    ##!          newly created C++ object is stored in `self.ptr`. This method effectively acquires
    ##!          the C++ resource that the Python object will manage.
    ##! @param self The `Notification` instance being initialized.
    ##! @throws MemoryError If the C++ `new` operator fails to allocate memory (e.g., `std::bad_alloc`
    ##!         is thrown), Cython's `except+` mechanism (if used with the constructor declaration or
    ##!         if `new` itself throws) should translate this into a Python `MemoryError`. The
    ##!         implementation should handle potential allocation failures gracefully.
    ##! @note This method bridges the Python object's creation to the C++ object's creation.

    # cpdef __dealloc__(self):
    ##! @brief Special Cython Destructor - Releases the C++ Resource.
    ##! @details Automatically called by the Python garbage collector when the `Notification` object's
    ##!          reference count drops to zero. Its critical role is to release the C++ resource acquired
    ##!          in `__init__`. It does this by calling `delete self.ptr`, freeing the memory occupied
    ##!          by the C++ `notification` object.
    ##! @param self The `Notification` instance being destroyed.
    ##! @note This method is essential for preventing memory leaks of the C++ object. It should **never**
    ##!       be called directly from Python code. The implementation must check if `self.ptr` is not
    ##!       `NULL` before attempting deletion to handle cases where initialization might have failed
    ##!       after `__cinit__` but before `ptr` was successfully assigned, or simply as a safeguard.
    ##! @warning Omitting or incorrectly implementing `__dealloc__` will lead to memory leaks.

    # --- Python Interface Methods (Conceptual Implementation in .pyx) ---

    # cpdef void success(self, str msg):
    ##! @brief Displays a success message via the C++ backend.
    ##! @details This method calls the `success` method of the underlying C++ `notification` object.
    ##!          It handles the conversion of the Python `str` (`msg`) into a C++ `std::string`.
    ##!          The GIL is released (`nogil`) during the C++ call to allow Python thread concurrency,
    ##!          and any C++ exceptions are caught and translated to Python exceptions (`except+`).
    ##! @param self The `Notification` instance.
    ##! @param msg The success message string to display (Python `str`).

    # cpdef void warning(self, str msg):
    ##! @brief Displays a warning message and increments the warning counter via the C++ backend.
    ##! @details Calls the C++ `warning` method, converting the Python `str` `msg` to `std::string`.
    ##!          Releases the GIL (`nogil`) and propagates C++ exceptions (`except+`). It also
    ##!          increments the internal C++ warning counter, which can be accessed via the
    ##!          `warning_count` property.
    ##! @param self The `Notification` instance.
    ##! @param msg The warning message string to display (Python `str`).

    # cpdef void failure(self, str msg):
    ##! @brief Displays a failure message and increments the failure counter via the C++ backend.
    ##! @details Calls the C++ `failure` method, converting the Python `str` `msg` to `std::string`.
    ##!          Releases the GIL (`nogil`) and propagates C++ exceptions (`except+`). It also
    ##!          increments the internal C++ failure counter, accessible via the `failure_count` property.
    ##! @param self The `Notification` instance.
    ##! @param msg The failure message string to display (Python `str`).

    # cpdef void info(self, str msg):
    ##! @brief Displays an informational message and increments the info counter via the C++ backend.
    ##! @details Calls the C++ `info` method, converting the Python `str` `msg` to `std::string`.
    ##!          Releases the GIL (`nogil`) and propagates C++ exceptions (`except+`). It also
    ##!          increments the internal C++ info counter, accessible via the `info_count` property.
    ##! @param self The `Notification` instance.
    ##! @param msg The informational message string to display (Python `str`).

    # cpdef void progressbar(self, float prg, str title):
    ##! @brief Displays a simple percentage-based progress bar via the C++ backend.
    ##! @details Calls the C++ `progressbar` method. It converts the Python `str` `title` to
    ##!          `std::string` and passes the Python `float` `prg` directly. Releases the GIL (`nogil`)
    ##!          and propagates C++ exceptions (`except+`).
    ##! @param self The `Notification` instance.
    ##! @param prg The progress value, typically ranging from 0.0 (start) to 1.0 (complete) (Python `float`).
    ##! @param title A descriptive title string for the progress bar (Python `str`).

    # cpdef void progressbar1(self, list threads_progress, unsigned long long total, str title):
    ##! @brief Displays a progress bar optimized for multi-threaded tasks (variant 1) via the C++ backend.
    ##! @details Calls the C++ `progressbar1` method. It handles the conversion of the Python `list`
    ##!          `threads_progress` (containing unsigned long long integers) into a C++
    ##!          `std::vector<unsigned long long>`. It also converts the Python `str` `title` to
    ##!          `std::string`. The `unsigned long long total` is passed directly. Releases the GIL
    ##!          (`nogil`) and propagates C++ exceptions (`except+`).
    ##! @param self The `Notification` instance.
    ##! @param threads_progress A Python `list` where each element is an `unsigned long long`
    ##!        representing the progress count of an individual thread or task.
    ##! @param total An `unsigned long long` representing the total number of items to be processed
    ##!        across all threads/tasks.
    ##! @param title A descriptive title string for the progress bar (Python `str`).

    # cpdef void progressbar2(self, list threads_progress, unsigned long long total, str title):
    ##! @brief Displays a progress bar optimized for multi-threaded tasks (variant 2) via the C++ backend.
    ##! @details Similar to `progressbar1`, this method calls the C++ `progressbar2` method, performing
    ##!          the necessary type conversions (Python `list` to `std::vector<unsigned long long>`,
    ##!          Python `str` to `std::string`). Releases the GIL (`nogil`) and propagates C++
    ##!          exceptions (`except+`). The difference between `progressbar1` and `progressbar2`
    ##!          likely lies in the C++ implementation's visualization or calculation logic.
    ##! @param self The `Notification` instance.
    ##! @param threads_progress A Python `list` of `unsigned long long` progress counts per thread/task.
    ##! @param total An `unsigned long long` representing the overall total for progress calculation.
    ##! @param title A descriptive title string for the progress bar (Python `str`).

    # cpdef void progressbar3(self, list threads_progress, list totals, list titles):
    ##! @brief Displays an advanced multi-component progress bar for complex multi-threaded scenarios
    ##!        via the C++ backend.
    ##! @details Calls the C++ `progressbar3` method. This variant handles multiple progress indicators,
    ##!          each potentially with its own set of thread counts, total, and title. It converts:
    ##!          - Python `list` `threads_progress` to `std::vector<unsigned long long>`
    ##!          - Python `list` `totals` to `std::vector<unsigned long long>`
    ##!          - Python `list` of `str` `titles` to `std::vector<std::string>`
    ##!          Releases the GIL (`nogil`) and propagates C++ exceptions (`except+`).
    ##! @param self The `Notification` instance.
    ##! @param threads_progress A Python `list` of `unsigned long long` progress counts, potentially
    ##!        representing aggregated progress for different components or stages.
    ##! @param totals A Python `list` of `unsigned long long` values, where each corresponds to the
    ##!        total for a specific progress component.
    ##! @param titles A Python `list` of `str`, providing titles for each corresponding progress component.
    ##!        The lengths of `threads_progress`, `totals`, and `titles` should typically match.

    # --- Python Properties (Conceptual Implementation in .pyx using property()) ---

    # property prefix:
    ##! @property prefix
    ##! @brief Gets or sets the prefix string prepended to all output messages.
    ##! @details Accessing this property reads or writes the `prefix` member of the C++ `notification`
    ##!          object. Type conversion between Python `str` and C++ `std::string` is handled
    ##!          automatically by Cython.
    ##! @type str

    # property bold:
    ##! @property bold
    ##! @brief Gets or sets whether the primary message text should be rendered in bold.
    ##! @details Accessing this property reads or writes the `bold` member (a C++ `bool`) of the C++
    ##!          `notification` object. Cython handles the conversion between Python `bool` and C++ `bool`.
    ##!          The actual rendering effect depends on the C++ implementation (e.g., using terminal codes).
    ##! @type bool

    # property shush:
    ##! @property shush
    ##! @brief Gets or sets whether all output should be suppressed (quiet mode).
    ##! @details Accessing this property reads or writes the `shush` member (a C++ `bool`) of the C++
    ##!          `notification` object. If set to `True`, all message and progress bar display functions
    ##!          should ideally do nothing.
    ##! @type bool

    # property warning_count:
    ##! @property warning_count
    ##! @brief Gets the number of warning messages displayed since the object's creation.
    ##! @details This read-only property accesses the `_warning` integer member of the C++ `notification`
    ##!          object, which is incremented internally by the C++ `warning` method.
    ##! @type int

    # property failure_count:
    ##! @property failure_count
    ##! @brief Gets the number of failure messages displayed since the object's creation.
    ##! @details This read-only property accesses the `_failure` integer member of the C++ `notification`
    ##!          object, incremented internally by the C++ `failure` method.
    ##! @type int

    # property success_count:
    ##! @property success_count
    ##! @brief Gets the number of success messages displayed since the object's creation.
    ##! @details This read-only property accesses the `_success` integer member of the C++ `notification`
    ##!          object, incremented internally by the C++ `success` method.
    ##! @type int

    # property info_count:
    ##! @property info_count
    ##! @brief Gets the number of informational messages displayed since the object's creation.
    ##! @details This read-only property accesses the `_info` integer member of the C++ `notification`
    ##!          object, incremented internally by the C++ `info` method.
    ##! @type int

    pass # End of cdef class Notification definition placeholder
