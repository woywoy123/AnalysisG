/**
 * @file event_template.pxd
 * @brief Defines the Cython interface (`.pxd`) for the C++ `event_template` class and the `EventTemplate` wrapper.
 *
 * @details
 * This header file declares the C++ `event_template` class structure to Cython, enabling
 * the creation of the `EventTemplate` Python wrapper class. It specifies the C++ members
 * and methods that will be accessible from Cython. This allows Cython code (`.pyx`) to
 * interact directly with the C++ backend, managing memory and calling C++ functions
 * efficiently.
 *
 * The C++ `event_template` class serves as a blueprint for structuring and analyzing
 * event data, commonly found in high-energy physics analyses involving ROOT data formats
 * (trees, branches, leaves). It encapsulates the definition of an event's structure,
 * including associated data containers and metadata.
 *
 * The Cython wrapper `EventTemplate` (defined in the corresponding `.pyx` file) will
 * manage a pointer to a C++ `event_template` instance, providing a Pythonic interface
 * to its capabilities. This bridges the gap between high-performance C++ logic and
 * Python's flexibility for analysis workflows.
 *
 * The C++ `data_t` struct, referenced in the `build_event` method signature, is assumed
 * to be defined and accessible within the Cython environment, likely via
 * `AnalysisG.core.structs`.
 *
 * **C++ Class: `event_template`**
 *
 * @brief Represents a template defining the structure and metadata for event data processing.
 *
 * @details This C++ class encapsulates the structural definition of an event, including
 * references to data sources (like ROOT Trees and Branches) and associated metadata
 * (name, hash, weight, index). It provides functionalities for constructing event
 * representations based on this template (`build_event`) and for finalizing its
 * configuration (`CompileEvent`). It is designed to be integrated into data analysis
 * frameworks where standardized event structures are needed.
 *
 * **Members:**
 * @var std::vector<std::string> trees
 * @brief A collection of ROOT TTree names relevant to this event template.
 *        Represents all trees from which data might be drawn or associated.
 *
 * @var std::vector<std::string> branches
 * @brief A collection of ROOT TBranch names relevant to this event template.
 *        Specifies the data fields (branches) within the associated trees that are
 *        required or defined by this template.
 *
 * @var std::vector<std::string> leaves
 * @brief A collection of ROOT TLeaf names relevant to this event template.
 *        Represents the specific data points or variables (leaves) within the branches
 *        that are utilized by this template. Also used internally by setters for index/weight
 *        if a string is passed.
 *
 * @var std::string tree
 * @brief The name of the primary ROOT TTree associated with this template.
 *        Indicates the main data source tree for the event.
 *
 * @var std::string name
 * @brief A user-defined, human-readable name for this specific event template instance.
 *        Used for identification and logging purposes.
 *
 * @var std::string hash
 * @brief A hash string representing the configuration or state of the template.
 *        Likely used for uniquely identifying the template's definition, caching,
 *        or versioning. A truncated version is used for the Python `__hash__`.
 *
 * @var double weight
 * @brief A numerical weight associated with events conforming to this template.
 *        Often used in physics analysis for normalization, representing event probability,
 *        or cross-section.
 *
 * @var double index
 * @brief A numerical index associated with this event template, potentially representing
 *        an event ID or sequence number.
 *
 * **Methods:**
 * @fn event_template()
 * @brief Default constructor for the C++ `event_template` class.
 * @details Initializes a new instance of the `event_template`.
 * @throws May throw C++ exceptions during initialization (e.g., memory allocation issues).
 * @note This is called internally by the Cython wrapper's `__cinit__`.
 *
 * @fn build_event(std::map<std::string, data_t*>* evnt)
 * @brief Constructs a structured event representation from raw input data.
 * @details Takes a map of data pointers (`data_t*`) keyed by strings (likely variable names)
 *          and uses the template's structure (defined branches, leaves, etc.) to build
 *          a map representing the structured event. The output map likely contains
 *          pointers to other `event_template` instances or derived event objects.
 * @param evnt A pointer to a map containing the input data for building the event.
 *             Keys are variable names, and values are pointers to `data_t` objects.
 * @return A map (`std::map<std::string, event_template*>`) representing the structured event,
 *         where keys might be component names and values are pointers to corresponding
 *         event structures.
 * @throws May throw C++ exceptions during the event building process (e.g., missing data,
 *         type mismatches, configuration errors).
 *
 * @fn CompileEvent()
 * @brief Finalizes the configuration of the event template.
 * @details Performs necessary setup, validation, or optimization steps after the template
 *          has been configured (e.g., setting trees, branches). This might involve
 *          pre-calculating offsets, validating branch existence, or setting up internal
 *          data structures for efficient event processing by `build_event`.
 * @throws May throw C++ exceptions if the configuration is invalid or incomplete.
 *
 * @fn operator==(const event_template& p)
 * @brief Overloads the equality operator (`==`) for comparing two `event_template` objects.
 * @details Compares this `event_template` instance with another (`p`) based on their
 *          internal state and configuration (e.g., name, hash, associated trees/branches).
 * @param p The other `event_template` object to compare against.
 * @return `true` if the two templates are considered logically equivalent, `false` otherwise.
 * @throws May throw C++ exceptions during the comparison process.
 * @note This is used by the Cython wrapper's `__eq__` method.
 *
 * **Cython Class: `EventTemplate`**
 *
 * @brief A Cython wrapper providing a Python interface to the C++ `event_template`.
 *
 * @details This class acts as a bridge between Python and C++. It holds a pointer (`ptr`)
 * to an instance of the C++ `event_template` class, managing its lifecycle (creation
 * in `__cinit__`, deletion in `__dealloc__`). It exposes the C++ object's properties
 * (like `index`, `weight`, `Tree`, `Trees`, `Branches`, `Name`) and comparison logic
 * (`__eq__`, `__hash__`) to Python in a user-friendly way. This allows Python scripts
 * to configure and use the C++ event templating mechanism.
 *
 * **Members:**
 * @var event_template* ptr
 * @brief A raw C++ pointer to the underlying `event_template` object.
 * @details This pointer is managed internally by the `EventTemplate` wrapper. Direct access
 *          from user code is discouraged. Its lifecycle is tied to the Python `EventTemplate`
 *          object via `__cinit__` and `__dealloc__`.
 */

// --- Start of declarations typically found in .pxd ---

// from libcpp cimport bool
// from libcpp.map cimport map
// from libcpp.string cimport string
// from libcpp.vector cimport vector
// from libcpp.functional cimport function
// from cython.operator cimport dereference as deref
//
// from AnalysisG.core.structs cimport data_t

/**
 * @brief Declaration of the C++ `event_template` class for Cython.
 * @details This block informs Cython about the existence and structure of the C++
 *          `event_template` class located in the specified header file. It declares
 *          the members and methods that the Cython wrapper will interact with.
 *          The `nogil` keyword indicates methods that can be called without the
 *          Python Global Interpreter Lock, potentially improving performance in
 *          multi-threaded scenarios. The `except +` indicates C++ exceptions are
 *          translated into Python exceptions.
 */
// cdef extern from "<templates/event_template.h>" nogil:
//     cdef cppclass event_template:
//         event_template() except + nogil
//
//         vector[string] trees
//         vector[string] branches
//         vector[string] leaves
//
//         string tree
//         string name
//         string hash
//
//         double weight
//         double index
//
//         map[string, event_template*] build_event(map[string, data_t*]* evnt) except + nogil
//         void CompileEvent() except+ nogil
//
//         bool operator == (event_template& p) except+ nogil

/**
 * @brief Declaration of the Cython `EventTemplate` wrapper class.
 * @details This declares the Python-visible class `EventTemplate` and its core C++
 *          member, the pointer `ptr` to the `event_template` instance.
 */
// cdef class EventTemplate:
//     cdef event_template* ptr # Documented above

// --- End of declarations typically found in .pxd ---


/**
 * @file event_template.pyx
 * @brief Implements the `EventTemplate` Cython wrapper class for the C++ `event_template`.
 * @details This file provides the Python implementation details for the `EventTemplate`
 *          class declared in the corresponding `.pxd` file. It defines how Python methods
 *          and properties interact with the underlying C++ `event_template` object,
 *          including memory management (`__cinit__`, `__dealloc__`), attribute access
 *          (properties like `index`, `weight`, `Tree`, etc.), and special Python methods
 *          (`__hash__`, `__eq__`, `__name__`). It uses helper functions like `env` and `enc`
 *          (presumably for string encoding/decoding between Python `str` and C++ `std::string`)
 *          from `AnalysisG.core.tools`.
 */

// --- Start of implementation typically found in .pyx ---

// # distutils: language=c++
// # cython: language_level = 3
//
// from libcpp cimport bool, int
// from libcpp.map cimport map
// from libcpp.string cimport string
// from libcpp.vector cimport vector
// from libcpp.functional cimport function
// from cython.operator cimport dereference as deref
//
// from AnalysisG.core.structs cimport data_t # Assumed needed for context or future use
// from AnalysisG.core.event_template cimport event_template # Import C++ class definition
// from AnalysisG.core.tools cimport env, enc # Import helper functions for string conversion
// from typing import Union # For type hinting

/**
 * @class EventTemplate
 * @brief Cython implementation of the wrapper for the C++ `event_template` class.
 * @details This class provides the concrete implementation for the `EventTemplate` interface
 *          declared in the `.pxd` file. It manages the lifecycle of a C++ `event_template`
 *          object and exposes its functionality through Python methods and properties.
 *          It handles the translation between Python types (like `str`, `list`, `int`, `float`)
 *          and C++ types (`std::string`, `std::vector<std::string>`, `double`).
 *          Includes special methods for hashing, equality comparison, and string representation.
 *          Inheritance is checked in memory management methods to prevent issues in derived classes.
 */
cdef class EventTemplate:
    # cdef event_template* ptr # Defined in pxd, documented above

    /**
     * @fn __cinit__(self)
     * @brief Cython constructor: Allocates the C++ `event_template` object.
     * @details This special Cython method is called *before* `__init__` when an `EventTemplate`
     *          object is created in Python (`EventTemplate()`). It is responsible for
     *          allocating the underlying C++ `event_template` object using `new` and
     *          storing the pointer in `self.ptr`. It includes a check (`type(self) is not EventTemplate`)
     *          to ensure this allocation logic only runs for the base class and not potentially
     *          derived Python classes, preventing double allocation or incorrect initialization
     *          in inheritance scenarios.
     * @param self The instance of the EventTemplate class being constructed.
     * @throws Propagates C++ exceptions from the `event_template` constructor as Python exceptions.
     */
    // def __cinit__(self):
        // Implementation removed, signature kept for documentation.

    /**
     * @fn __init__(self)
     * @brief Standard Python initializer (called after `__cinit__`).
     * @details This method is called after the C++ object has been allocated by `__cinit__`.
     *          In this implementation, it currently does nothing (`pass`), but it could be
     *          used for further Python-level initialization if needed, such as setting
     *          default property values based on arguments passed to the Python constructor.
     * @param self The instance of the EventTemplate class being initialized.
     */
    // def __init__(self):
        // Implementation removed, signature kept for documentation.

    /**
     * @fn __dealloc__(self)
     * @brief Cython destructor: Deallocates the C++ `event_template` object.
     * @details This special Cython method is called when the Python `EventTemplate` object's
     *          reference count drops to zero and it's about to be garbage collected. Its crucial
     *          role is to release the memory occupied by the C++ object pointed to by `self.ptr`
     *          using `del self.ptr` (which translates to `delete ptr;`). This prevents memory leaks.
     *          Similar to `__cinit__`, it checks the type to ensure deallocation only happens
     *          for the base class instance, coordinating correctly with potential inheritance.
     * @param self The instance of the EventTemplate class being destroyed.
     */
    // def __dealloc__(self):
        // Implementation removed, signature kept for documentation.

    /**
     * @fn __name__(self) -> str
     * @brief Returns the name of the event template.
     * @details Provides a string representation of the event template's name, primarily
     *          intended for display or identification. It retrieves the `name` attribute
     *          from the C++ object and converts it to a Python string using the `env` helper.
     *          This often corresponds to the `Name` property.
     * @param self The instance of the EventTemplate class.
     * @return str The name of the event template, converted from `std::string`.
     */
    // def __name__(self) -> str:
        // Implementation removed, signature kept for documentation.

    /**
     * @fn __hash__(self) -> int
     * @brief Computes a hash value for the event template based on its C++ hash string.
     * @details Calculates an integer hash value suitable for using `EventTemplate` objects
     *          as keys in Python dictionaries or elements in sets. It retrieves the `hash`
     *          attribute (a `std::string`) from the C++ object, takes the first 8 characters,
     *          interprets them as a hexadecimal number (base 0 detects `0x` prefix, falls back
     *          to base 10 otherwise, but likely intended for hex), and returns the resulting integer.
     *          Templates with the same C++ hash string (up to 8 chars) will have the same Python hash.
     * @param self The instance of the EventTemplate class.
     * @return int The computed hash value.
     */
    // def __hash__(self) -> int:
        // Implementation removed, signature kept for documentation.

    /**
     * @fn __eq__(self, other) -> bool
     * @brief Compares this event template to another object for equality using the C++ `operator==`.
     * @details Implements the equality comparison (`==`) for `EventTemplate` objects.
     *          First, it checks if the `other` object is an instance or subclass of `EventTemplate`
     *          using the `is_self` helper method. If the type check passes, it casts `other`
     *          to `EventTemplate` (`cdef EventTemplate ev = other`) and then delegates the
     *          comparison to the overloaded `operator==` of the underlying C++ `event_template`
     *          objects (`self.ptr[0] == ev.ptr[0]`).
     * @param self The instance of the EventTemplate class.
     * @param other The object to compare against this event template.
     * @return bool `True` if `other` is a compatible `EventTemplate` and the underlying
     *         C++ objects are equal according to their `operator==`, `False` otherwise.
     * @throws Propagates C++ exceptions from `operator==` as Python exceptions.
     */
    // def __eq__(self, other) -> bool:
        // Implementation removed, signature kept for documentation.

    /**
     * @fn is_self(self, inpt) -> bool
     * @brief Checks if the input object is an instance or subclass of EventTemplate.
     * @details A utility method for robust type checking. It verifies if the provided `inpt`
     *          object is either a direct instance of `EventTemplate` (`isinstance`) or
     *          an instance of a class that inherits from `EventTemplate` (`issubclass`).
     *          This is used in `__eq__` to ensure comparisons are only made between
     *          compatible objects.
     * @param self The instance of the EventTemplate class (unused in the check itself).
     * @param inpt The object whose type needs to be checked.
     * @return bool `True` if `inpt` is an instance or subclass of `EventTemplate`, `False` otherwise.
     */
    // def is_self(self, inpt) -> bool:
        // Implementation removed, signature kept for documentation.

    /**
     * @property index
     * @brief Gets or sets the numerical index associated with the event template.
     * @details
     *   - **Getter:** Retrieves the `index` member (a `double`) from the C++ `event_template`
     *     object and returns it as a Python `int`. Note the potential type conversion from double to int.
     *   - **Setter:** Attempts to assign the provided `val` (which can be a string or number)
     *     to the C++ `index` member (`double`). If this assignment fails due to a `TypeError`
     *     (e.g., `val` is a string that cannot be directly converted to `double`), it falls back
     *     to storing the encoded string representation of `val` in the C++ `leaves` vector.
     *     This fallback behavior suggests `leaves` might be used for storing symbolic representations
     *     when direct numerical assignment isn't possible.
     * @return int The current index value (getter).
     * @param val Union[str, double] The value to set the index to (setter).
     */
    // @property
    // def index(self) -> int:
        // Getter implementation removed.
    // @index.setter
    // def index(self, val: Union[str, double]):
        // Setter implementation removed.

    /**
     * @property weight
     * @brief Gets or sets the numerical weight associated with the event template.
     * @details
     *   - **Getter:** Retrieves the `weight` member (a `double`) from the C++ `event_template`
     *     object and returns it as a Python `float` (Cython `double`).
     *   - **Setter:** Attempts to assign the provided `val` (which can be a string or number)
     *     to the C++ `weight` member (`double`). Similar to the `index` setter, if a `TypeError`
     *     occurs during the direct assignment, it encodes `val` as a string using `enc` and
     *     stores it in the C++ `leaves` vector as a fallback.
     * @return double The current weight value (getter).
     * @param val Union[str, double] The value to set the weight to (setter).
     */
    // @property
    // def weight(self) -> double:
        // Getter implementation removed.
    // @weight.setter
    // def weight(self, val: Union[str, double]):
        // Setter implementation removed.

    /**
     * @property Tree
     * @brief Gets or sets the name of the primary ROOT TTree associated with the template.
     * @details
     *   - **Getter:** Retrieves the `tree` member (a `std::string`) from the C++ object,
     *     converts it to a Python string using the `env` helper, and returns it.
     *   - **Setter:** Takes a Python string `val`, converts it to a `std::string` using the
     *     `enc` helper, and assigns it to the `tree` member of the C++ object.
     * @return str The name of the primary associated tree (getter).
     * @param val str The tree name to set (setter).
     */
    // @property
    // def Tree(self) -> str:
        // Getter implementation removed.
    // @Tree.setter
    // def Tree(self, val: str):
        // Setter implementation removed.

    /**
     * @property Trees
     * @brief Gets or sets the list of associated ROOT TTree names.
     * @details
     *   - **Getter:** Retrieves the `trees` member (a `std::vector<std::string>`) from the
     *     C++ object. It iterates through the vector, converts each `std::string` to a
     *     Python string using `env`, and returns them as a Python `list`.
     *   - **Setter:** Accepts either a single Python string or a list of Python strings.
     *     - If `val` is a string, it creates a C++ `std::vector` containing just that
     *       string (encoded using `enc`) and assigns it to the C++ `trees` member,
     *       overwriting any previous content.
     *     - If `val` is a list, it iterates through the list and recursively calls the
     *       `Trees` setter with each individual string element. This effectively appends
     *       each string in the list to the C++ `trees` vector one by one, potentially
     *       leading to unexpected behavior if the intention was to replace the list.
     *       *Note: The recursive list handling seems incorrect; it should likely clear
     *       the vector and then add all elements from the input list.*
     * @return list A list of strings representing the associated tree names (getter).
     * @param val Union[str, list] A single tree name string or a list of tree name strings (setter).
     */
    // @property
    // def Trees(self) -> list:
        // Getter implementation removed.
    // @Trees.setter
    // def Trees(self, val: Union[str, list]):
        // Setter implementation removed.

    /**
     * @property Branches
     * @brief Gets or sets the list of associated ROOT TBranch names.
     * @details
     *   - **Getter:** Retrieves the `branches` member (a `std::vector<std::string>`) from the
     *     C++ object. It iterates through the vector, converts each `std::string` to a
     *     Python string using `env`, and returns them as a Python `list`.
     *   - **Setter:** Accepts either a single Python string or a list of Python strings.
     *     - If `val` is a string, it creates a C++ `std::vector` containing just that
     *       string (encoded using `enc`) and assigns it to the C++ `branches` member,
     *       overwriting any previous content.
     *     - If `val` is a list, it iterates through the list and recursively calls the
     *       `Branches` setter with each individual string element. Similar to `Trees`,
     *       this effectively appends each string one by one. *Note: This recursive list
     *       handling seems incorrect and likely needs revision for expected list assignment.*
     * @return list A list of strings representing the associated branch names (getter).
     * @param val Union[str, list] A single branch name string or a list of branch name strings (setter).
     */
    // @property
    // def Branches(self) -> list:
        // Getter implementation removed.
    // @Branches.setter
    // def Branches(self, val: Union[str, list]):
        // Setter implementation removed.

    /**
     * @property Name
     * @brief Gets or sets the descriptive name of the event template.
     * @details
     *   - **Getter:** Retrieves the `name` member (a `std::string`) from the C++ object,
     *     converts it to a Python string using the `env` helper, and returns it. This
     *     provides the same value as the `__name__` method.
     *   - **Setter:** (Not Implemented) The provided code only shows a getter for `Name`.
     *     If a setter were implemented, it would likely take a Python string, encode it
     *     using `enc`, and assign it to the C++ `name` member.
     * @return str The descriptive name of the event template (getter).
     */
    // @property
    // def Name(self) -> str:
        // Getter implementation removed.

// --- End of implementation ---
