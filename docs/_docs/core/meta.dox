/**
 * @file meta.pxd
 * @brief Cython declarations for C++ metadata handling classes and related utilities.
 *
 * @details This file defines the Cython interface (`.pxd`) for C++ classes and Cython
 * extension types involved in managing physics analysis metadata, particularly focusing
 * on interaction with the ATLAS Metadata Interface (AMI) and local caching. It declares
 * C++ classes (like `meta`) exposed from header files and defines Cython `cdef class`
 * wrappers (`Meta`, `MetaLookup`, `Data`, `ami_client`) that provide a Pythonic interface
 * to the underlying C++ and Cython logic. These declarations enable efficient, type-aware
 * interaction between Python analysis code and the performance-critical C++/Cython backend,
 * facilitating metadata retrieval, storage, lookup, and association with analysis data.
 * The `nogil` keyword is used where appropriate to allow C++ functions to release the
 * Python Global Interpreter Lock (GIL) for potential parallelism.
 *
 * @note This is a declaration file (`.pxd`) and contains no implementation code.
 *       Implementations are found in the corresponding `.pyx` file and C++ source files.
 */

// distutils: language = c++
// cython: language_level=3

/**
 * @brief Declares C++ classes and functions from the `<meta/meta.h>` header for Cython access.
 * @details This `cdef extern from` block exposes the C++ `meta` class defined in the
 *          `<meta/meta.h>` header file to the Cython environment. It specifies that the
 *          methods within this block can be called without holding the Python GIL (`nogil`),
 *          which is crucial for performance in potentially multi-threaded scenarios involving
 *          C++ operations.
 */
cdef extern from "<meta/meta.h>" nogil:
    /**
     * @brief C++ class for managing core analysis metadata.
     * @details This C++ class encapsulates the logic for handling metadata associated with
     *          physics analysis datasets. Its responsibilities likely include storing metadata
     *          attributes (like dataset identifiers, cross-sections, file lists), computing
     *          hashes for identification or caching, and potentially interacting with a
     *          persistent cache file (`metacache_path`) to speed up metadata lookups.
     *          The `nogil` declaration on its methods indicates they are thread-safe with
     *          respect to the Python GIL.
     */
    cdef cppclass meta:
        /**
         * @brief Default constructor for the C++ `meta` class.
         * @details Initializes a new instance of the C++ `meta` class. This constructor
         *          might set up internal data structures, initialize default values, or
         *          prepare the object for metadata storage and operations.
         * @throws std::exception Propagates C++ exceptions (indicated by `except+`) that
         *         might occur during construction (e.g., memory allocation issues).
         * @note Declared `nogil`, allowing construction without the GIL.
         */
        meta() except+ nogil

        /**
         * @brief Computes a hash value for a given input string.
         * @details This method takes a standard C++ string as input and returns a hash
         *          representation, also as a standard C++ string. The hashing algorithm
         *          is implemented in C++ for efficiency and might be used for generating
         *          unique keys for caching, indexing, or comparing metadata entries based
         *          on identifiers like filenames or dataset names.
         * @param inpt The `std::string` input value to be hashed.
         * @return A `std::string` containing the computed hash.
         * @throws std::exception Propagates C++ exceptions (indicated by `except+`) that
         *         might occur during the hashing process.
         * @note Declared `nogil`, allowing hashing without the GIL.
         */
        string hash(string inpt) except+ nogil

        /**
         * @brief Core storage structure for metadata attributes.
         * @details This member variable holds the actual metadata. `meta_t` is expected
         *          to be a C++ struct or class defined in `<meta/meta.h>` (or an included
         *          header like `<structs.h>`), containing fields for various metadata
         *          properties (e.g., DSID, cross-section, file lists, event counts, AMI tags).
         *          The Cython `Meta` class will wrap access to this C++ data.
         */
        meta_t meta_data

        /**
         * @brief Filesystem path to the metadata cache file.
         * @details This `std::string` stores the path to a file used for caching metadata
         *          information. This allows the C++ layer (and potentially the Cython layer
         *          via `ami_client`) to persist and retrieve metadata, avoiding redundant
         *          computations or expensive lookups (e.g., AMI queries).
         */
        string metacache_path

/**
 * @brief Cython extension type providing a Python interface to the C++ `meta` class.
 * @details This `cdef class` serves as a bridge between Python code and the underlying
 *          C++ `meta` object. It holds a pointer (`ptr`) to a C++ `meta` instance and
 *          exposes its functionality through Python methods and properties defined in the
 *          corresponding `.pyx` file. It manages the lifetime of the C++ object and provides
 *          a convenient, Pythonic way to interact with the metadata system.
 */
cdef class Meta:
    /**
     * @brief Raw pointer to the underlying C++ `meta` object.
     * @details This C-level pointer (`meta*`) directly references the C++ `meta` instance
     *          that contains the actual metadata (`meta_data`) and implements core logic
     *          (like `hash`). All interactions with the C++ layer from this Cython class
     *          occur through this pointer. Its memory management (allocation/deallocation)
     *          is handled within the `Meta` class lifecycle (`__cinit__`, `__dealloc__`).
     */
    cdef meta* ptr

    /**
     * @brief Internal Cython method for linking the wrapper to a C++ `meta` instance.
     * @details This C-level method (`cdef`) is used internally, likely during initialization
     *          or data population (e.g., called by `ami_client.dressmeta`), to associate this
     *          Cython `Meta` wrapper object with a specific C++ `meta` object by setting the
     *          `ptr` attribute. It allows transferring ownership or linking to an existing
     *          C++ object managed elsewhere.
     * @param met A pointer (`meta*`) to the C++ `meta` object to be associated with this wrapper.
     * @note This method is not intended for direct use from Python. Its name (`__meta__`)
     *       suggests an internal protocol.
     */
    cdef __meta__(self, meta* met)

    /**
     * @brief Internal flag or attribute indicating metadata loading status.
     * @details This `cdef` attribute likely tracks whether the metadata for this `Meta`
     *          instance has been successfully loaded (e.g., from cache or AMI). Its exact
     *          type (e.g., `bint`, `object`) and usage are defined in the `.pyx` file.
     *          It might control behavior like preventing redundant fetch operations.
     */
    cdef loaded

/**
 * @brief Cython extension type for performing metadata lookups.
 * @details This class provides functionality to find and retrieve `Meta` objects based on
 *          some input criteria, often a dataset identifier or filename. It likely maintains
 *          a collection of known `Meta` objects and uses the `Meta.hash` or other matching
 *          logic to perform efficient lookups. It holds references to the matched metadata
 *          and associated information.
 */
cdef class MetaLookup:
    /**
     * @brief Reference to the currently matched `Meta` object.
     * @details This attribute holds the `Meta` instance that was successfully found during
     *          the last lookup operation (`__find__`). It provides access to the detailed
     *          metadata of the matched dataset. Declared `public` for direct access from Python.
     */
    cdef public Meta meta

    /**
     * @brief Cache of successful lookup results.
     * @details This Python dictionary stores the results of previous lookups, mapping the
     *          input string used for the lookup (e.g., filename) to the corresponding `Meta`
     *          object that was found. This serves as a fast cache to avoid redundant searches
     *          within the main `metadata` collection for frequently accessed identifiers.
     *          Declared `public` for potential inspection or manipulation from Python.
     */
    cdef public dict matched

    /**
     * @brief Collection of all known `Meta` objects available for lookup.
     * @details This Python dictionary holds the pool of `Meta` instances that the `MetaLookup`
     *          can search through. The keys could be DSIDs, dataset names, or other identifiers,
     *          and the values are the corresponding `Meta` objects. This collection is typically
     *          populated externally before lookups are performed. Declared `public`.
     */
    cdef public dict metadata

    /**
     * @brief Integrated luminosity value used for calculations.
     * @details This floating-point value stores the integrated luminosity (e.g., in pb⁻¹ or fb⁻¹)
     *          relevant to the analysis context. It's used by this class (e.g., in properties like
     *          `ExpectedEvents` in the `.pyx` file) to calculate expected event yields based on
     *          the cross-section stored in the matched `Meta` object. Declared `public`.
     */
    cdef public float luminosity

    /**
     * @brief Internal Cython method to find a `Meta` object based on an input string.
     * @details This C-level method implements the core lookup logic. It takes an input string
     *          (e.g., a filename or dataset pattern), checks the `matched` cache first, and if
     *          not found, searches through the `Meta` objects in the `metadata` dictionary.
     *          The search likely involves comparing the input string against information stored
     *          within each `Meta` object (e.g., list of files, dataset name, using `Meta.hash`).
     *          If a match is found, it updates the `meta` attribute and potentially the `matched` cache.
     * @param inpt The input string (`str`) used as the key or pattern for the search.
     * @return The `Meta` object that matches the input string, or potentially `None` or raises
     *         an error if no match is found (the exact return behavior depends on the `.pyx`
     *         implementation). The declaration here suggests it returns a `Meta` object, which
     *         would typically be the matched object assigned to `self.meta`.
     * @note This method is not intended for direct use from Python. It's likely called by a
     *       Python-level method like `__call__` or `lookup` in the `.pyx` file.
     */
    cdef Meta __find__(self, str inpt)

/**
 * @brief Cython extension type for managing analysis data associated with metadata.
 * @details This class is designed to hold and manage numerical data (e.g., event variables,
 *          weights) related to physics analysis datasets. It maintains a link (`_meta`) to the
 *          metadata context via a `MetaLookup` object. Data is stored efficiently using C++
 *          standard library containers (`std::map`, `std::vector`) accessed via Cython. It provides
 *          methods for populating these containers and potentially rescaling or manipulating the
 *          data based on the associated metadata (e.g., normalizing weights).
 */
cdef class Data:
    /**
     * @brief Reference to the `MetaLookup` instance providing metadata context.
     * @details This attribute links the `Data` object to the `MetaLookup` instance that likely
     *          created it or is associated with it. This link allows the `Data` object to access
     *          the relevant `Meta` object (via `_meta.meta`) and its metadata (e.g., cross-section,
     *          sum of weights, expected events) needed for operations like data rescaling.
     *          Declared `public` for direct access from Python.
     */
    cdef public MetaLookup _meta

    /**
     * @brief C++ map storing primary numerical data vectors.
     * @details This `std::map` uses `std::string` keys (likely representing variable names or
     *          other identifiers) and maps them to `std::vector<float>` values, which hold the
     *          actual numerical data arrays (e.g., values of a specific variable for many events).
     *          Using C++ containers provides memory efficiency and potentially faster access
     *          compared to Python lists, especially when manipulated from Cython or C++. The
     *          leading underscore suggests it might be intended for internal use, accessed via
     *          properties or methods in the `.pyx` file.
     */
    cdef map[string, vector[float]] _data

    /**
     * @brief C++ map storing numerical weight vectors.
     * @details Similar to `_data`, this `std::map` stores vectors of floating-point weights.
     *          The `std::string` keys likely identify the type of weight (e.g., 'eventWeight',
     *          'pileupWeight', systematic variations) or the associated file/dataset. The
     *          `std::vector<float>` holds the weight values for corresponding events or entries.
     *          The leading underscore suggests internal use.
     */
    cdef map[string, vector[float]] _weights

    /**
     * @brief C++ map storing aggregated sums of weights.
     * @details This nested map structure is likely used to store pre-calculated sums of weights,
     *          often required for normalization purposes. The outer `std::map` might be keyed by
     *          a dataset identifier (`std::string`). The inner `std::map` could then be keyed by
     *          a weight type or component name (`std::string`), storing the corresponding total
     *          sum (`float`) for that component within that dataset. This structure facilitates
     *          efficient access to normalization factors.
     */
    cdef map[string, map[string, float]] sumofweights

    /**
     * @brief C++ map storing the number of expected events for different samples.
     * @details This `std::map` holds the calculated expected number of events for various datasets
     *          or analysis samples, keyed by a string identifier (e.g., dataset name or sample name).
     *          The values are floating-point numbers, typically derived from `crossSection * luminosity`.
     *          This information is crucial for scaling Monte Carlo simulations to the target luminosity.
     */
    cdef map[string, float] expected_events

    /**
     * @brief Internal Cython method to populate a C++ data map from a Python dictionary.
     * @details This C-level method efficiently transfers data from a Python dictionary (`inpt`)
     *          into a C++ `std::map<std::string, std::vector<float>>` referenced by the pointer `ptx`.
     *          The keys in the Python dictionary are expected to be strings, and the values should
     *          be sequences (like lists or NumPy arrays) containing floats. This is likely used
     *          in the `.pyx` file to load data read from files (e.g., using Python libraries)
     *          into the internal C++ containers (`_data`, `_weights`).
     * @param inpt A Python dictionary containing the data to be loaded. Keys are strings, values
     *             are sequences of floats.
     * @param ptx A C++ pointer to the `std::map<std::string, std::vector<float>>` that will be
     *            populated with the data from `inpt`.
     * @note This method is not intended for direct use from Python.
     */
    cdef void __populate__(self, dict inpt, map[string, vector[float]]* ptx)

    /**
     * @brief Internal Cython method to rescale data stored in a C++ vector.
     * @details This C-level method applies a scaling factor or normalization to the elements
     *          of a C++ `std::vector<float>` referenced by the pointer `ptx`. The specific
     *          scaling logic is implemented in the `.pyx` file and likely uses metadata accessed
     *          via the `_meta` attribute (e.g., using `expected_events` and `sumofweights`)
     *          to normalize event weights according to luminosity, cross-section, and initial
     *          sum of weights.
     * @param ptx A C++ pointer to the `std::vector<float>` whose elements will be rescaled in place
     *            or used as input for a rescaling calculation. The exact behavior depends on the
     *            `.pyx` implementation (e.g., whether it modifies the input vector or returns a
     *            new scaled vector).
     * @note This method is not intended for direct use from Python.
     */
    cdef void __rescale__(self, vector[float]* ptx)

/**
 * @brief Cython extension type for interacting with an ATLAS Metadata Interface (AMI) client.
 * @details This class encapsulates the logic for communicating with the AMI service to retrieve
 *          metadata about ATLAS datasets. It likely manages an underlying AMI client object
 *          (e.g., from `pyAMI`), handles authentication, performs queries, and potentially
 *          interacts with a local cache (`file_cache`) to store and retrieve AMI query results,
 *          thereby reducing network traffic and speeding up repeated requests. It plays a key
 *          role in populating `Meta` objects with authoritative metadata.
 */
cdef class ami_client:
    /**
     * @brief The underlying client object used for AMI communication.
     * @details This attribute holds the actual client instance responsible for making requests
     *          to the AMI service. The specific type is not fully declared here (`cdef client`),
     *          but the `.pyx` implementation will define it. It's likely an instance of a class
     *          from the `pyAMI` library (e.g., `pyAMI.client.Client` or a custom subclass like
     *          `atlas` defined in the `.pyx` file) configured for ATLAS grid access.
     */
    cdef client

    /**
     * @brief Object managing the local cache for AMI query results.
     * @details This attribute holds an object responsible for handling the persistence of AMI
     *          metadata. The type is specified as `cdef file_cache`, suggesting it might be
     *          a custom class or potentially an object from a library like `h5py` (as used in
     *          the `.pyx` file) for reading from and writing to a cache file (e.g., HDF5 format).
     *          Methods like `loadcache` and `savecache` will interact with this object.
     */
    cdef file_cache

    /**
     * @brief Pointer to a C++ notification object for logging.
     * @details This C-level pointer (`notification*`) references a C++ object used for emitting
     *          log messages, warnings, or errors during the operation of the `ami_client`. The
     *          `notification` class is likely defined in a custom C++ header (`notification.h`)
     *          and provides a structured way to report status from performance-sensitive Cython/C++ code.
     */
    cdef notification* nf

    /**
     * @brief String identifier for the type of dataset being processed.
     * @details This attribute stores a string that likely specifies the data format or processing
     *          tier of the datasets being queried (e.g., 'DAOD_TOPQ1', 'mc', 'data'). This information
     *          can be used to construct appropriate AMI queries or to filter results based on the
     *          analysis requirements.
     */
    cdef str type_

    /**
     * @brief List of dataset identifiers (DSIDs) relevant to the current operation.
     * @details This Python list stores the Dataset IDs (unique numerical identifiers used in ATLAS)
     *          that are being processed or have been retrieved from an AMI query (e.g., via
     *          `list_datasets`).
     */
    cdef list dsids

    /**
     * @brief Dictionary storing primary data retrieved from AMI queries.
     * @details This Python dictionary holds the core results fetched from AMI, typically metadata
     *          about datasets or files. The structure likely maps dataset names or DSIDs to lists
     *          or dictionaries containing attributes like file lists (LFNs), event counts, file sizes, etc.
     *          It's populated by methods like `list_datasets` and potentially loaded from cache.
     */
    cdef dict datas

    /**
     * @brief Dictionary storing supplementary information retrieved from AMI.
     * @details This Python dictionary holds additional metadata or informational details about the
     *          datasets, separate from the primary file/event data in `datas`. It might contain
     *          dataset-level properties like cross-section, generator name, processing tags, AMI status, etc.
     *          It's populated by methods like `list_datasets` and potentially loaded from cache.
     */
    cdef dict infos

    /**
     * @brief Internal Cython method to load dataset information from the local cache.
     * @details This C-level method attempts to retrieve previously cached AMI query results
     *          associated with the context provided by the `Meta` object `obj` (e.g., using `obj.dsid`
     *          as a key and `obj.MetaCachePath` to find the cache file). It interacts with the
     *          `file_cache` object to read data. If successful, it populates internal attributes
     *          like `dsids`, `datas`, and `infos` with the cached information.
     * @param obj The `Meta` object providing context for the cache lookup (e.g., DSID, cache path).
     * @return A boolean value (`bint` in Cython, `bool` in C++): `True` if data was successfully
     *         loaded from the cache, `False` otherwise (e.g., cache miss, file not found, corrupted data).
     * @note This method is not intended for direct use from Python.
     */
    cdef bool loadcache(self, Meta obj)

    /**
     * @brief Internal Cython method to save current dataset information to the local cache.
     * @details This C-level method writes the current contents of the internal attributes `dsids`,
     *          `datas`, and `infos` to the local cache file managed by `file_cache`. The data is
     *          associated with the context provided by the `Meta` object `obj` (e.g., using `obj.dsid`
     *          as a key within the cache file specified by `obj.MetaCachePath`). This persists the
     *          results of AMI queries for future use.
     * @param obj The `Meta` object providing context for saving to the cache (e.g., DSID, cache path).
     * @note This method is not intended for direct use from Python.
     */
    cdef void savecache(self, Meta obj)

    /**
     * @brief Internal Cython method to populate a `Meta` object with AMI information.
     * @details This C-level method takes the metadata retrieved from AMI (and stored internally,
     *          likely in `datas` and `infos` under the key `dset_name`) and transfers it into the
     *          provided `Meta` object (`obj`). This typically involves calling the `Meta.__meta__`
     *          method or directly setting attributes on the `Meta` object or its underlying C++
     *          `meta_t` struct. It effectively "dresses" the `Meta` object with the detailed
     *          information obtained from AMI.
     * @param obj The `Meta` object instance to be populated with metadata.
     * @param dset_name The name (`str`) of the dataset whose information (stored internally
     *                  in `self.datas` and `self.infos`) should be used to populate `obj`.
     * @note This method is not intended for direct use from Python.
     */
    cdef void dressmeta(self, Meta obj, str dset_name)

    /**
     * @brief Internal Cython method to query AMI and retrieve dataset information.
     * @details This C-level method orchestrates the main interaction with the AMI service. It
     *          first attempts to load data from the cache using `loadcache`. If the cache miss occurs
     *          or is bypassed, it uses the `client` attribute to perform queries against AMI. These
     *          queries are constructed based on the context from the `Meta` object (`obj`) (e.g.,
     *          `obj.dsid`, `obj.amitag`) and the `type_` attribute. The results from AMI are used
     *          to populate the internal attributes `dsids`, `datas`, and `infos`. Finally, it may
     *          call `savecache` to store the newly fetched results and `dressmeta` to populate the
     *          input `Meta` object. It likely handles authentication checks and error reporting via `nf`.
     * @param obj The `Meta` object providing the context (e.g., DSID, AMI tag, file list) needed
     *            to perform the relevant AMI queries and cache operations.
     * @note This method is not intended for direct use from Python. It encapsulates the core
     *       fetch-or-cache logic.
     */
    cdef void list_datasets(self, Meta obj)
