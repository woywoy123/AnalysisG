/**
 * @file meta.dox
 * @brief Doxygen documentation for the `meta` class and its implementation.
 *
 * This file provides detailed documentation for the `meta` class, which is responsible
 * for managing and accessing metadata associated with high-energy physics analysis datasets.
 * It covers the class structure, member variables, methods, and the underlying mechanisms
 * for metadata parsing and retrieval.
 */

/**
 * @class meta
 * @brief Manages metadata for high-energy physics analysis datasets.
 *
 * @details The `meta` class serves as a central hub for handling various metadata attributes
 * related to datasets used in high-energy physics analysis. It is designed to parse
 * metadata from diverse sources, including:
 *   - JSON strings (often embedded within ROOT files).
 *   - ROOT TObjects, specifically focusing on:
 *     - `MetaData` TTrees containing structured metadata.
 *     - `AnalysisTracking` TTrees, which often store JSON metadata or summary information.
 *     - Histograms (like TH1F) used to store sum-of-weights information and basic dataset parameters.
 *
 * A key feature of the `meta` class is its use of the `cproperty` template class. This provides
 * a unified and convenient interface for accessing metadata fields. Each metadata attribute
 * (like DSID, cross-section, luminosity, etc.) is exposed as a `cproperty` member. Accessing
 * these properties triggers a getter function, which retrieves the value either directly from
 * the internal `meta_t` data structure (`meta_data`) or calculates it on-the-fly (lazy evaluation).
 * This approach decouples the user interface from the underlying data storage and parsing logic.
 *
 * The class inherits from:
 *   - `tools`: To leverage common utility functions (e.g., string manipulation, hashing).
 *   - `notification`: To provide a standardized way of issuing messages (errors, warnings, info)
 *     using a consistent prefix ("meta").
 *
 * **Core Responsibilities:**
 *   - Parsing metadata from JSON strings via the `rapidjson` library.
 *   - Scanning ROOT TTrees (`MetaData`, `AnalysisTracking`, `EventLoop_FileExecuted`) to extract metadata.
 *   - Scanning ROOT TH1 histograms to extract sum-of-weights and other embedded information.
 *   - Storing the extracted metadata in the `meta_t meta_data` struct.
 *   - Providing access to metadata fields through `cproperty` members.
 *   - Calculating derived metadata values (e.g., cross-sections in different units).
 *   - Managing dataset identifiers (DSID), Monte Carlo status, cross-sections, luminosity,
 *     event counts, generator details, file information, configuration settings, and more.
 *   - Associating metadata with specific files using hashing via the `get_tags` method (requires external `folds` data).
 *
 * @note The `meta` class often works in conjunction with an `analysis` class, which might manage the overall
 *       workflow, provide the `folds` data structure, and orchestrate the metadata scanning process.
 * @see meta_t
 * @see cproperty
 * @see tools
 * @see notification
 * @see analysis
 */
class meta:
    public tools,
    public notification
{
    public:
        /**
         * @brief Constructs a `meta` object and initializes its properties.
         *
         * @details This constructor initializes the `meta` object. Its primary role is to
         * set up the `cproperty` members. For each `cproperty` representing a metadata field,
         * it assigns:
         *   1. The corresponding static getter function (e.g., `get_dsid` for the `dsid` property).
         *      These getter functions define how the property's value is retrieved from the
         *      internal `meta_data` struct when the property is accessed.
         *   2. A pointer to the current `meta` object instance (`this`). This allows the static
         *      getter functions to access the `meta_data` member of the specific `meta` instance.
         *
         * It also sets the default prefix for messages generated via the `notification`
         * base class to "meta", ensuring consistent logging output.
         *
         * @post All `cproperty` members are configured with their respective getter functions
         *       and a pointer to `this` object.
         * @post The notification prefix is set to "meta".
         * @post The internal `meta_data` struct is default-initialized.
         * @post The `rpd` (rapidjson::Document) pointer is initialized to `nullptr`.
         * @post The `folds` pointer is initialized to `nullptr`.
         */
        meta();

        /**
         * @brief Destroys the `meta` object and cleans up resources.
         *
         * @details This destructor is responsible for releasing any resources allocated by the
         * `meta` object during its lifetime. Specifically, it checks if the `rapidjson::Document`
         * pointer (`rpd`) is non-null. If it is, indicating that a JSON document was parsed
         * but potentially not cleaned up immediately (though typically it's deleted after
         * `compiler()` finishes), this destructor deletes the `rapidjson::Document` object
         * to prevent memory leaks.
         *
         * @post If `rpd` was non-null, the associated `rapidjson::Document` object is deleted.
         */
        ~meta();

        /**
         * @brief Retrieves folding information (`folds_t`) based on a file hash.
         *
         * @details This method searches for metadata tags or folding information associated
         * with a specific input file, identified by its hash. It iterates through an
         * externally provided vector of `folds_t` structures (pointed to by the private `folds` member).
         * If a `folds_t` entry has a `hash` member matching the input `hash_`, a constant pointer
         * to that `folds_t` structure is returned.
         *
         * @param hash_ The hash string identifying the input file for which to retrieve tags.
         *              This hash is typically generated using the `meta::hash` method.
         *
         * @return A constant pointer to the matching `folds_t` struct if found within the `folds` vector.
         * @return `nullptr` if the `folds` vector is not set (i.e., `folds == nullptr`) or if no entry
         *         with a matching hash is found.
         *
         * @note The `folds` member variable (a pointer to `std::vector<folds_t>`) must be
         *       initialized externally before calling this function. This is typically done
         *       by a managing class like `analysis`, which populates the folding information.
         * @see folds_t
         * @see meta::hash
         * @see analysis
         */
        const folds_t* get_tags(std::string hash_);

        /**
         * @brief Scans a generic ROOT TObject to extract metadata.
         *
         * @details This method acts as a dispatcher for metadata extraction based on the type
         * and name of the input ROOT `TObject`. It determines the appropriate parsing strategy:
         *   - If the object is a `TTree` named "AnalysisTracking": It assumes the tree contains
         *     JSON metadata stored in a branch named "jsonData" and calls `parse_json()`
         *     after extracting the string content using `parse_string()`.
         *   - If the object is a `TTree` named "MetaData": It assumes this tree directly maps
         *     to the structure of `meta_t` and sets the branch address for the `meta_data` member,
         *     allowing ROOT to fill the structure directly when `GetEntry()` is called on the tree.
         *   - For any other object type or name: It calls `scan_sow()` to attempt extracting
         *     sum-of-weights information or other metadata potentially stored in histograms or
         *     other tree structures.
         *
         * It temporarily sets `gErrorIgnoreLevel` to suppress potential ROOT messages during object inspection.
         *
         * @param obj A pointer to the `TObject` (e.g., `TTree`, `TH1F`) to be scanned for metadata.
         *            The object is not modified by this function.
         *
         * @post Metadata might be extracted and stored in `meta_data` or the `misc` map depending
         *       on the object type and content.
         * @see parse_json
         * @see parse_string
         * @see scan_sow
         * @see meta_t
         */
        void scan_data(TObject* obj);

        /**
         * @brief Scans a TObject specifically for sum-of-weights (SoW) and related information.
         *
         * @details This method focuses on extracting metadata commonly found in sum-of-weights
         * histograms (like those produced by `AnalysisBase` or similar frameworks) or specific TTrees.
         * It handles two main cases:
         *
         *   1.  **TTrees:**
         *       - If the TTree is named "AnalysisTracking": It extracts fields like `dsid`, `isAFII`,
         *         `totalEventsWeighted`, `totalEvents`, `processedEvents`, `processedEventsWeighted`,
         *         `processedEventsWeightedSquared`, `generators`, and `AMITag` using the private
         *         `parse_float` and `parse_string` helper methods. The extracted values are stored
         *         in a `weights_t` struct within the `meta_data.misc` map, keyed by the tree name ("AnalysisTracking").
         *       - If the TTree is named "EventLoop_FileExecuted": It reads the list of executed input
         *         filenames (stored in the "file" branch) using a `TTreeReader` and populates the
         *         `meta_data.inputfiles` map (mapping an index to the filename).
         *
         *   2.  **TH1 Histograms (inheriting from TH1):**
         *       - It assumes the histogram (specifically tested with `TH1F`) stores metadata in its
         *         X-axis bin labels and contents.
         *       - It iterates through the bins, extracting label-content pairs.
         *       - Specific labels like "Initial events", "Initial sum of weights", and
         *         "Initial sum of weights squared" are used to populate the corresponding fields
         *         in a `weights_t` struct within `meta_data.misc`, keyed by the histogram name.
         *       - All label-content pairs are also stored in the `hist_data` map within the `weights_t` struct.
         *       - If a bin label contains "mc" (indicating a campaign name), it's stored in `meta_data.campaign`.
         *       - It attempts to extract the DSID and AMI tag from specific bin labels (assuming a convention, e.g., bin 3 for DSID, bin 4 for AMI tag) if the campaign was found.
         *
         * @param obj A pointer to the `TObject` to be scanned. Expected to be a `TTree` or inherit from `TH1`.
         *            The object is not modified by this function.
         *
         * @post If `obj` is a recognized TTree or TH1, relevant metadata (SoW, event counts, filenames, etc.)
         *       is extracted and stored in `meta_data.misc`, `meta_data.inputfiles`, `meta_data.campaign`,
         *       `meta_data.dsid`, or `meta_data.AMITag`.
         * @see weights_t
         * @see parse_float
         * @see parse_string
         * @see meta_t::misc
         * @see meta_t::inputfiles
         */
        void scan_sow(TObject* obj);

        /**
         * @brief Parses a JSON string to extract metadata.
         *
         * @details This method takes a JSON formatted string as input, parses it using the
         * `rapidjson` library, and populates the internal `meta_data` structure.
         *
         * Steps:
         *   1. Checks if a `rapidjson::Document` (`rpd`) already exists. If so, it returns early
         *      to prevent re-parsing.
         *   2. Creates a new `rapidjson::Document` object (`rpd`).
         *   3. Attempts to parse the input JSON string (`inpt`).
         *   4. **Error Handling:** If parsing fails (`rpd->HasParseError()` is true):
         *      - It identifies the approximate location of the error.
         *      - It attempts a simple heuristic fix: If the characters around the error
         *        location look like a newline (`\n`) that might be missing a preceding comma,
         *        it tries replacing the `\n` with `,\n` in the input string.
         *      - It deletes the failed `rpd` object, creates a new one, and re-parses the
         *        potentially corrected input string.
         *   5. If parsing succeeds (either initially or after the fix), it calls the private
         *      `compiler()` method. The `compiler()` method traverses the parsed JSON
         *      document (`rpd`) and extracts the relevant values into the `meta_data` struct.
         *   6. After `compiler()` finishes, it deletes the `rapidjson::Document` object (`rpd`)
         *      and sets the `rpd` pointer back to `nullptr` to free memory and indicate that
         *      parsing is complete.
         *
         * @param inpt A `std::string` containing the metadata in JSON format.
         *
         * @post If parsing is successful, the `meta_data` struct is populated with values
         *       extracted from the JSON string.
         * @post The internal `rpd` pointer is set to `nullptr` after successful parsing and compilation.
         * @see compiler
         * @see meta_t
         * @see rapidjson::Document
         */
        void parse_json(std::string inpt);

        /**
         * @brief Generates a hash string for a given filename.
         *
         * @details This method computes a hash string intended to uniquely identify a file based
         * on its name. It first extracts the base filename (the part after the last '/' character)
         * from the input path `fname`. If the input string doesn't contain '/', the entire string
         * is considered the filename. Then, it calls the `tools::hash` method (inherited from the
         * `tools` base class) to compute the actual hash of the base filename.
         *
         * @param fname The full path or filename string for which to generate a hash.
         *
         * @return A `std::string` representing the computed hash of the base filename.
         * @see tools::hash
         */
        std::string hash(std::string fname);

        // --- Public Members ---

        /**
         * @var rapidjson::Document* rpd
         * @brief Pointer to the `rapidjson::Document` used for JSON parsing.
         * @details This pointer holds the `rapidjson::Document` object while JSON metadata is being
         * parsed by `parse_json` and processed by `compiler`. It is created within `parse_json`,
         * used by `compiler`, and typically deleted at the end of `parse_json`. It is initialized
         * to `nullptr` and should be `nullptr` when no JSON parsing is actively in progress.
         * The destructor also provides a safety check to delete it if it wasn't cleaned up properly.
         * @see parse_json
         * @see compiler
         */
        rapidjson::Document* rpd = nullptr;

        /**
         * @var std::string metacache_path
         * @brief Path for a potential metadata cache file.
         * @details This string is intended to store the path to a file that could be used for
         * caching metadata. The `meta` class itself does not directly implement caching logic
         * using this path; its usage is determined by external context, such as a managing
         * `analysis` class, which might use this path to read/write cached metadata to speed up
         * subsequent runs.
         */
        std::string metacache_path;

        /**
         * @var meta_t meta_data
         * @brief The core data structure holding the extracted metadata values.
         * @details This is an instance of the `meta_t` struct, which defines the fields for all
         * the metadata attributes managed by the `meta` class (e.g., `dsid`, `isMC`, `crossSection_mean`,
         * `inputfiles`, `misc`, etc.). The parsing methods (`parse_json`, `scan_data`, `scan_sow`)
         * populate this structure, and the `cproperty` getter functions retrieve values from it.
         * @see meta_t
         * @see cproperty
         */
        meta_t meta_data;

        // --- Properties (Accessors for meta_data fields via cproperty) ---
        // These members provide a convenient, uniform interface to access the underlying
        // metadata stored in the `meta_data` struct. Accessing a property (e.g., `mymeta.dsid()`)
        // invokes the corresponding static getter function assigned in the constructor.

        /** @brief Property: Indicates if the dataset is Monte Carlo (MC). Accesses `meta_data.isMC`. */
        cproperty<bool, meta> isMC;
        /** @brief Property: Indicates if metadata was successfully found/loaded. Accesses `meta_data.found`. */
        cproperty<bool, meta> found;

        /** @brief Property: Event number (context-dependent). Accesses `meta_data.eventNumber`. */
        cproperty<double, meta> eventNumber;
        /** @brief Property: Index of the event within its file/dataset. Accesses `meta_data.event_index`. */
        cproperty<double, meta> event_index;
        /** @brief Property: Total size (context-dependent, e.g., file size). Accesses `meta_data.totalSize`. */
        cproperty<double, meta> totalSize;
        /** @brief Property: k-factor applied to the process. Accesses `meta_data.kfactor`. */
        cproperty<double, meta> kfactor;
        /** @brief Property: Center-of-mass energy (ECM) in GeV. Accesses `meta_data.ecmEnergy`. */
        cproperty<double, meta> ecmEnergy;
        /** @brief Property: Generator filter efficiency. Accesses `meta_data.genFiltEff`. */
        cproperty<double, meta> genFiltEff;
        /** @brief Property: Completion status/fraction. Accesses `meta_data.completion`. */
        cproperty<double, meta> completion;
        /** @brief Property: Beam energy in GeV. Accesses `meta_data.beam_energy`. */
        cproperty<double, meta> beam_energy;

        /** @brief Property: Cross-section in nanobarns (nb). Accesses `meta_data.crossSection_mean`. */
        cproperty<double, meta> cross_section_nb;
        /** @brief Property: Cross-section in femtobarns (fb). Derived from `cross_section_nb`. */
        cproperty<double, meta> cross_section_fb;
        /** @brief Property: Cross-section in picobarns (pb). Derived from `cross_section_nb`. */
        cproperty<double, meta> cross_section_pb;

        /** @brief Property: Integrated luminosity of the campaign (e.g., pb^-1). Accesses `meta_data.campaign_luminosity`. */
        cproperty<double, meta> campaign_luminosity;
        /** @brief Property: Sum of weights (often for MC normalization). Derived from `meta_data.misc`. */
        cproperty<double, meta> sum_of_weights;

        /** @brief Property: Dataset Identifier (DSID). Accesses `meta_data.dsid`. */
        cproperty<unsigned int, meta> dsid;
        /** @brief Property: Number of files in the dataset. Accesses `meta_data.nFiles`. */
        cproperty<unsigned int, meta> nFiles;
        /** @brief Property: Total number of events in the dataset. Accesses `meta_data.totalEvents`. */
        cproperty<unsigned int, meta> totalEvents;
        /** @brief Property: Dataset number (often same as DSID). Accesses `meta_data.datasetNumber`. */
        cproperty<unsigned int, meta> datasetNumber;

        /** @brief Property: Derivation format (e.g., "PHYS", "PHYSLITE"). Accesses `meta_data.derivationFormat`. */
        cproperty<std::string, meta> derivationFormat;
        /** @brief Property: AMI (ATLAS Metadata Interface) tag. Accesses `meta_data.AMITag`. */
        cproperty<std::string, meta> AMITag;
        /** @brief Property: List of generators used. Accesses `meta_data.generators`. */
        cproperty<std::string, meta> generators;
        /** @brief Property: Unique identifier string. Accesses `meta_data.identifier`. */
        cproperty<std::string, meta> identifier;
        /** @brief Property: Full dataset name. Accesses `meta_data.DatasetName`. */
        cproperty<std::string, meta> DatasetName;
        /** @brief Property: Production system status. Accesses `meta_data.prodsysStatus`. */
        cproperty<std::string, meta> prodsysStatus;
        /** @brief Property: Data type (e.g., "data", "mc"). Accesses `meta_data.dataType`. */
        cproperty<std::string, meta> dataType;
        /** @brief Property: Version string (e.g., dataset version). Accesses `meta_data.version`. */
        cproperty<std::string, meta> version;
        /** @brief Property: Parton Distribution Function (PDF) set used. Accesses `meta_data.PDF`. */
        cproperty<std::string, meta> PDF;
        /** @brief Property: ATLAS software release version. Accesses `meta_data.AtlasRelease`. */
        cproperty<std::string, meta> AtlasRelease;
        /** @brief Property: Principal physics group. Accesses `meta_data.principalPhysicsGroup`. */
        cproperty<std::string, meta> principalPhysicsGroup;
        /** @brief Property: Short physics name/category. Accesses `meta_data.physicsShort`. */
        cproperty<std::string, meta> physicsShort;
        /** @brief Property: Primary generator name. Accesses `meta_data.generatorName`. */
        cproperty<std::string, meta> generatorName;
        /** @brief Property: Detector geometry version. Accesses `meta_data.geometryVersion`. */
        cproperty<std::string, meta> geometryVersion;
        /** @brief Property: Conditions tag used. Accesses `meta_data.conditionsTag`. */
        cproperty<std::string, meta> conditionsTag;
        /** @brief Property: Generator tune used. Accesses `meta_data.generatorTune`. */
        cproperty<std::string, meta> generatorTune;
        /** @brief Property: AMI status (e.g., "VALID"). Accesses `meta_data.amiStatus`. */
        cproperty<std::string, meta> amiStatus;
        /** @brief Property: Type of beams collided (e.g., "pp"). Accesses `meta_data.beamType`. */
        cproperty<std::string, meta> beamType;
        /** @brief Property: Production step (e.g., "recon", "simul"). Accesses `meta_data.productionStep`. */
        cproperty<std::string, meta> productionStep;
        /** @brief Property: Project name (e.g., "mc16_13TeV"). Accesses `meta_data.projectName`. */
        cproperty<std::string, meta> projectName;
        /** @brief Property: Algorithm used for statistics calculation. Accesses `meta_data.statsAlgorithm`. */
        cproperty<std::string, meta> statsAlgorithm;
        /** @brief Property: Names of generator filters applied. Accesses `meta_data.genFilterNames`. */
        cproperty<std::string, meta> genFilterNames;
        /** @brief Property: File type (e.g., "DAOD", "AOD"). Accesses `meta_data.file_type`. */
        cproperty<std::string, meta> file_type;
        /** @brief Property: Sample name (often derived/user-defined). Accesses `meta_data.sample_name`. */
        cproperty<std::string, meta> sample_name;
        /** @brief Property: Logical dataset name (LFN). Accesses `meta_data.logicalDatasetName`. */
        cproperty<std::string, meta> logicalDatasetName;
        /** @brief Property: Campaign identifier (e.g., "mc16a"). Accesses `meta_data.campaign`. */
        cproperty<std::string, meta> campaign;

        /** @brief Property: List of keywords associated with the dataset. Accesses `meta_data.keywords`. */
        cproperty<std::vector<std::string>, meta> keywords;
        /** @brief Property: List of weight names available. Accesses `meta_data.weights`. */
        cproperty<std::vector<std::string>, meta> weights;
        /** @brief Property: List of keywords (duplicate of `keywords`?). Accesses `meta_data.keyword`. */
        cproperty<std::vector<std::string>, meta> keyword;
        /** @brief Property: List of file GUIDs (Globally Unique Identifiers). Accesses `meta_data.fileGUID`. */
        cproperty<std::vector<std::string>, meta> fileGUID;

        /** @brief Property: List of event counts (e.g., per file). Accesses `meta_data.events`. */
        cproperty<std::vector<int>, meta> events;
        /** @brief Property: List of run numbers associated with the data. Accesses `meta_data.run_number`. */
        cproperty<std::vector<int>, meta> run_number;
        /** @brief Property: List of file sizes. Accesses `meta_data.fileSize`. */
        cproperty<std::vector<double>, meta> fileSize;

        /** @brief Property: Map of index to range/count (e.g., file index to event count). Accesses `meta_data.inputrange`. */
        cproperty<std::map<int, int>, meta> inputrange;
        /** @brief Property: Map of cumulative event count index to input filename. Accesses `meta_data.inputfiles`. */
        cproperty<std::map<int, std::string>, meta> inputfiles;

        /** @brief Property: Map of Logical File Name (LFN) to an integer (e.g., event count). Accesses `meta_data.LFN`. */
        cproperty<std::map<std::string, int>, meta> LFN;
        /** @brief Property: Map storing miscellaneous metadata, often SoW info, keyed by source name. Accesses `meta_data.misc`. */
        cproperty<std::map<std::string, weights_t>, meta> misc;

        /** @brief Property: Map storing configuration settings as key-value string pairs. Accesses `meta_data.config`. */
        cproperty<std::map<std::string, std::string>, meta> config;

    private:
        /**
         * @friend analysis
         * @brief Grants the `analysis` class access to private members of `meta`.
         * @details This friendship allows the `analysis` class (or a similar orchestrating class)
         * to directly access and manipulate private members of `meta`, such as setting the `folds`
         * pointer or potentially calling private methods like `compiler` if needed, facilitating
         * closer integration between analysis workflow management and metadata handling.
         */
        friend class analysis;

        /**
         * @brief Populates the `meta_data` struct from a parsed JSON document.
         *
         * @details This private helper method is called by `parse_json` after a JSON string
         * has been successfully parsed into the `rapidjson::Document` pointed to by `rpd`.
         * It navigates the JSON structure within `rpd` and extracts values for various
         * metadata fields, assigning them to the corresponding members of the `meta_data` struct.
         *
         * Specifically, it looks for:
         *   - The "inputConfig" object for fields like "dsid", "isMC", "derivationFormat", and "amiTag".
         *   - The "configSettings" array to populate the `meta_data.config` map.
         *   - The "inputFiles" array to extract filenames and event counts, populating the
         *     `meta_data.inputfiles` map (using the base filename).
         *
         * It includes logic to infer the "amiTag" from the input file paths if it's not
         * directly present in "inputConfig". It also attempts to infer it from `meta_data.sample_name`
         * as a fallback.
         *
         * @pre `rpd` must point to a valid, parsed `rapidjson::Document`.
         * @post The `meta_data` struct is populated with values found in the JSON document.
         * @see parse_json
         * @see meta_t
         * @see rapidjson::Document
         */
        void compiler();

        /**
         * @var std::vector<folds_t>* folds
         * @brief Pointer to an external vector containing folding information.
         * @details This pointer holds the address of a `std::vector<folds_t>` managed externally
         * (typically by the `analysis` class). This vector contains `folds_t` structures,
         * each associating a file hash with specific metadata tags or processing instructions.
         * The `get_tags` method uses this vector to look up information based on a file hash.
         * It is initialized to `nullptr` and must be set externally for `get_tags` to function.
         * @see folds_t
         * @see get_tags
         * @see analysis
         */
        std::vector<folds_t>* folds = nullptr;

        /**
         * @brief Parses a float value from a specific leaf in a TTree.
         *
         * @details This private helper method reads a floating-point value from a specified
         * leaf within a ROOT TTree. It assumes the TTree (`tr`) has at least one entry and
         * retrieves the value from the first entry (entry index 0). It uses `TTree::GetLeaf`
         * to find the leaf by name (`key`) and `TLeaf::GetValue` to retrieve its value.
         *
         * @param key The name of the TLeaf containing the float value.
         * @param tr Pointer to the TTree from which to read the value.
         *
         * @return The float value read from the specified leaf in the first entry.
         * @return Returns `0.0f` if the leaf is not found or cannot be read (e.g., wrong type).
         *
         * @note This method only reads from the first entry (index 0) of the TTree.
         * @pre `tr` must be a valid pointer to a TTree with at least one entry and the specified leaf.
         */
        float parse_float(std::string key, TTree* tr);

        /**
         * @brief Parses a string value from a specified branch/leaf in a TTree.
         *
         * @details This private helper method reads a string value from a specified branch
         * within a ROOT TTree. It is designed to handle cases where a C-style string might
         * be stored across multiple leaves within the same branch (a ROOT feature for long strings).
         * It retrieves the `TBranch` by name (`key`), gets the list of `TLeaf` objects associated
         * with that branch, and iterates through them. For each leaf, it gets a pointer to the
         * data (`char**`) and appends the C-string content to the result string.
         *
         * Like `parse_float`, it assumes the TTree (`tr`) has at least one entry and reads
         * the data corresponding to the first entry (entry index 0).
         *
         * @param key The name of the TBranch containing the string value.
         * @param tr Pointer to the TTree from which to read the value.
         *
         * @return The `std::string` value read by concatenating the content of all leaves
         *         within the specified branch for the first entry.
         * @return Returns an empty string if the branch is not found or cannot be read.
         *
         * @note This method only reads from the first entry (index 0) of the TTree.
         * @pre `tr` must be a valid pointer to a TTree with at least one entry and the specified branch.
         */
        std::string parse_string(std::string key, TTree* tr);

        // --- Static Getter Functions for cproperty ---
        // These static methods serve as the callbacks for the cproperty members.
        // When a cproperty is accessed (e.g., `mymeta.dsid()`), the corresponding
        // static getter function is invoked. It receives a pointer to the location
        // where the result should be stored (`val`) and a pointer to the `meta`
        // object instance (`m`) whose data should be accessed. The function then
        // retrieves the appropriate value from `m->meta_data` (or computes it)
        // and stores it in `*val`.

        /** @brief Static getter for the `isMC` property. Retrieves `m->meta_data.isMC`. */
        void static get_isMC(bool* val, meta* m);
        /** @brief Static getter for the `found` property. Retrieves `m->meta_data.found`. */
        void static get_found(bool* val, meta* m);
        /** @brief Static getter for the `eventNumber` property. Retrieves `m->meta_data.eventNumber`. */
        void static get_eventNumber(double* val, meta* m);
        /** @brief Static getter for the `event_index` property. Retrieves `m->meta_data.event_index`. */
        void static get_event_index(double* val, meta* m);
        /** @brief Static getter for the `totalSize` property. Retrieves `m->meta_data.totalSize`. */
        void static get_totalSize(double* val, meta* m);
        /** @brief Static getter for the `kfactor` property. Retrieves `m->meta_data.kfactor`. */
        void static get_kfactor(double* val, meta* m);
        /** @brief Static getter for the `ecmEnergy` property. Retrieves `m->meta_data.ecmEnergy`. */
        void static get_ecmEnergy(double* val, meta* m);
        /** @brief Static getter for the `genFiltEff` property. Retrieves `m->meta_data.genFiltEff`. */
        void static get_genFiltEff(double* val, meta* m);
        /** @brief Static getter for the `completion` property. Retrieves `m->meta_data.completion`. */
        void static get_completion(double* val, meta* m);
        /** @brief Static getter for the `beam_energy` property. Retrieves `m->meta_data.beam_energy`. */
        void static get_beam_energy(double* val, meta* m);

        /** @brief Static getter for `cross_section_pb`. Calculates `m->cross_section_nb() * 1000`. */
        void static get_cross_section_pb(double* val, meta* m);
        /** @brief Static getter for `cross_section_nb`. Retrieves `m->meta_data.crossSection_mean`. */
        void static get_cross_section_nb(double* val, meta* m);
        /** @brief Static getter for `cross_section_fb`. Calculates `m->cross_section_nb() * 1000000`. */
        void static get_cross_section_fb(double* val, meta* m);

        /** @brief Static getter for `campaign_luminosity`. Retrieves `m->meta_data.campaign_luminosity`. */
        void static get_campaign_luminosity(double* val, meta* m);
        /** @brief Static getter for the `dsid` property. Retrieves `m->meta_data.dsid`. */
        void static get_dsid(unsigned int* val, meta* m);
        /** @brief Static getter for the `nFiles` property. Retrieves `m->meta_data.nFiles`. */
        void static get_nFiles(unsigned int* val, meta* m);
        /** @brief Static getter for the `totalEvents` property. Retrieves `m->meta_data.totalEvents`. */
        void static get_totalEvents(unsigned int* val, meta* m);
        /** @brief Static getter for the `datasetNumber` property. Retrieves `m->meta_data.datasetNumber`. */
        void static get_datasetNumber(unsigned int* val, meta* m);
        /** @brief Static getter for `derivationFormat`. Retrieves `m->meta_data.derivationFormat`. */
        void static get_derivationFormat(std::string* val, meta* m);
        /** @brief Static getter for the `AMITag` property. Retrieves `m->meta_data.AMITag`. */
        void static get_AMITag(std::string* val, meta* m);
        /** @brief Static getter for the `generators` property. Retrieves `m->meta_data.generators`. */
        void static get_generators(std::string* val, meta* m);
        /** @brief Static getter for the `identifier` property. Retrieves `m->meta_data.identifier`. */
        void static get_identifier(std::string* val, meta* m);
        /** @brief Static getter for the `DatasetName` property. Retrieves `m->meta_data.DatasetName`. */
        void static get_DatasetName(std::string* val, meta* m);
        /** @brief Static getter for the `prodsysStatus` property. Retrieves `m->meta_data.prodsysStatus`. */
        void static get_prodsysStatus(std::string* val, meta* m);
        /** @brief Static getter for the `dataType` property. Retrieves `m->meta_data.dataType`. */
        void static get_dataType(std::string* val, meta* m);
        /** @brief Static getter for the `version` property. Retrieves `m->meta_data.version`. */
        void static get_version(std::string* val, meta* m);
        /** @brief Static getter for the `PDF` property. Retrieves `m->meta_data.PDF`. */
        void static get_PDF(std::string* val, meta* m);
        /** @brief Static getter for the `AtlasRelease` property. Retrieves `m->meta_data.AtlasRelease`. */
        void static get_AtlasRelease(std::string* val, meta* m);
        /** @brief Static getter for `principalPhysicsGroup`. Retrieves `m->meta_data.principalPhysicsGroup`. */
        void static get_principalPhysicsGroup(std::string* val, meta* m);
        /** @brief Static getter for the `physicsShort` property. Retrieves `m->meta_data.physicsShort`. */
        void static get_physicsShort(std::string* val, meta* m);
        /** @brief Static getter for the `generatorName` property. Retrieves `m->meta_data.generatorName`. */
        void static get_generatorName(std::string* val, meta* m);
        /** @brief Static getter for the `geometryVersion` property. Retrieves `m->meta_data.geometryVersion`. */
        void static get_geometryVersion(std::string* val, meta* m);
        /** @brief Static getter for the `conditionsTag` property. Retrieves `m->meta_data.conditionsTag`. */
        void static get_conditionsTag(std::string* val, meta* m);
        /** @brief Static getter for the `generatorTune` property. Retrieves `m->meta_data.generatorTune`. */
        void static get_generatorTune(std::string* val, meta* m);
        /** @brief Static getter for the `amiStatus` property. Retrieves `m->meta_data.amiStatus`. */
        void static get_amiStatus(std::string* val, meta* m);
        /** @brief Static getter for the `beamType` property. Retrieves `m->meta_data.beamType`. */
        void static get_beamType(std::string* val, meta* m);
        /** @brief Static getter for the `productionStep` property. Retrieves `m->meta_data.productionStep`. */
        void static get_productionStep(std::string* val, meta* m);
        /** @brief Static getter for the `projectName` property. Retrieves `m->meta_data.projectName`. */
        void static get_projectName(std::string* val, meta* m);
        /** @brief Static getter for the `statsAlgorithm` property. Retrieves `m->meta_data.statsAlgorithm`. */
        void static get_statsAlgorithm(std::string* val, meta* m);
        /** @brief Static getter for the `genFilterNames` property. Retrieves `m->meta_data.genFilterNames`. */
        void static get_genFilterNames(std::string* val, meta* m);
        /** @brief Static getter for the `file_type` property. Retrieves `m->meta_data.file_type`. */
        void static get_file_type(std::string* val, meta* m);
        /** @brief Static getter for the `sample_name` property. Retrieves `m->meta_data.sample_name`. */
        void static get_sample_name(std::string* val, meta* m);
        /** @brief Static getter for `logicalDatasetName`. Retrieves `m->meta_data.logicalDatasetName`. */
        void static get_logicalDatasetName(std::string* val, meta* m);
        /** @brief Static getter for the `campaign` property. Retrieves `m->meta_data.campaign` after removing spaces. */
        void static get_campaign(std::string* val, meta* m);
        /** @brief Static getter for the `keywords` property. Retrieves `m->meta_data.keywords`. */
        void static get_keywords(std::vector<std::string>* val, meta* m);
        /** @brief Static getter for the `weights` property. Retrieves `m->meta_data.weights`. */
        void static get_weights(std::vector<std::string>* val, meta* m);
        /** @brief Static getter for the `keyword` property. Retrieves `m->meta_data.keyword`. */
        void static get_keyword(std::vector<std::string>* val, meta* m);
        /** @brief Static getter for the `fileGUID` property. Retrieves `m->meta_data.fileGUID`. */
        void static get_fileGUID(std::vector<std::string>* val, meta* m);
        /** @brief Static getter for the `events` property. Retrieves `m->meta_data.events`. */
        void static get_events(std::vector<int>* val, meta* m);
        /** @brief Static getter for the `run_number` property. Retrieves `m->meta_data.run_number`. */
        void static get_run_number(std::vector<int>* val, meta* m);
        /** @brief Static getter for the `fileSize` property. Retrieves `m->meta_data.fileSize`. */
        void static get_fileSize(std::vector<double>* val, meta* m);
        /** @brief Static getter for the `inputrange` property. Retrieves `m->meta_data.inputrange`. */
        void static get_inputrange(std::map<int, int>* val, meta* m);
        /** @brief Static getter for the `inputfiles` property. Retrieves `m->meta_data.inputfiles`. */
        void static get_inputfiles(std::map<int, std::string>* val, meta* m);
        /** @brief Static getter for the `LFN` property. Retrieves `m->meta_data.LFN`. */
        void static get_LFN(std::map<std::string, int>* val, meta* m);
        /** @brief Static getter for the `misc` property. Retrieves `m->meta_data.misc`. */
        void static get_misc(std::map<std::string, weights_t>* val, meta* m);
        /** @brief Static getter for the `config` property. Retrieves `m->meta_data.config`. */
        void static get_config(std::map<std::string, std::string>* val, meta* m);
        /** @brief Static getter for `sum_of_weights`. Finds first valid `processed_events_weighted` in `m->misc`. */
        void static get_sum_of_weights(double* val, meta* m);
};

// --- Implementation Details (Conceptual Doxygen Comments) ---

// The following sections would typically contain the C++ implementation code.
// Here, they are replaced with Doxygen comments describing the implementation logic
// as derived from the original code provided.

/**
 * @fn meta::meta()
 * @brief Implementation of the `meta` constructor.
 * @details Initializes all `cproperty` members by calling `set_getter` with the corresponding
 *          static getter function (e.g., `this->dsid.set_getter(this->get_dsid)`) and
 *          `set_object` with the `this` pointer (e.g., `this->dsid.set_object(this)`).
 *          Sets the notification prefix using `this->prefix = "meta";`.
 */

/**
 * @fn meta::~meta()
 * @brief Implementation of the `meta` destructor.
 * @details Checks if `this->rpd` is not `nullptr`. If it holds a pointer, it deletes
 *          the `rapidjson::Document` object using `delete this->rpd;` to prevent memory leaks.
 */

/**
 * @fn meta::parse_json(std::string inpt)
 * @brief Implementation of the JSON parsing logic.
 * @details
 * - Returns immediately if `this->rpd` is already allocated.
 * - Allocates a new `rapidjson::Document` and assigns it to `this->rpd`.
 * - Calls `this->rpd->Parse(inpt.c_str())`.
 * - If `this->rpd->HasParseError()` is true:
 *   - Extracts a substring around the error offset.
 *   - Attempts a simple fix by replacing potential trailing newlines (`\n`) with comma-newlines (`,\n`)
 *     within the extracted substring and updates the original `inpt` string.
 *   - Deletes the failed `rpd`, allocates a new one, and re-parses the modified `inpt`.
 * - Calls `this->compiler()` to populate `meta_data` from the parsed `rpd`.
 * - Deletes `this->rpd` and sets it back to `nullptr`.
 */

/**
 * @fn meta::compiler()
 * @brief Implementation of the JSON compilation logic.
 * @details
 * - Accesses the root `rapidjson::Value` using `(*this->rpd)`.
 * - Checks for and extracts values from the "inputConfig" object:
 *   - `dsid` (as double, assigned to `this->meta_data.dsid`).
 *   - `isMC` (as bool, assigned to `this->meta_data.isMC`).
 *   - `derivationFormat` (as string, assigned to `this->meta_data.derivationFormat`).
 *   - `amiTag` (as string, assigned to `this->meta_data.AMITag`).
 * - Checks for and iterates through the "configSettings" array, populating `this->meta_data.config` map.
 * - Checks for and iterates through the "inputFiles" array:
 *   - Extracts the filename string and event count integer for each entry.
 *   - Splits the filename by '/' to get the base filename.
 *   - Stores the base filename in `this->meta_data.inputfiles` map, keyed by the cumulative event count.
 * - Implements fallback logic for `amiTag` if not found in "inputConfig":
 *   - Tries to extract it from the second-to-last component of the first input file path.
 *   - Further fallback using `this->meta_data.sample_name`.
 */

/**
 * @fn meta::scan_data(TObject* obj)
 * @brief Implementation of the generic TObject scanning dispatcher.
 * @details
 * - Sets `gErrorIgnoreLevel` high to suppress ROOT info/warnings.
 * - Gets the object name using `obj->GetName()`.
 * - If name is "AnalysisTracking": Calls `this->parse_string("jsonData", (TTree*)obj)` and passes the result to `this->parse_json()`.
 * - If name is "MetaData": Casts `obj` to `TTree*` and calls `SetBranchAddress("MetaData", &this->meta_data)`.
 * - Otherwise: Calls `this->scan_sow(obj)`.
 */

/**
 * @fn meta::parse_float(std::string key, TTree* tr)
 * @brief Implementation for parsing a float from a TTree leaf.
 * @details
 * - Calls `tr->GetEntry(0)` to load the first entry.
 * - Calls `tr->GetLeaf(key.c_str())` to get the TLeaf pointer.
 * - Returns the value using `->GetValue()`. Includes basic null checks implicitly via ROOT behavior (returns 0 if leaf not found).
 */

/**
 * @fn meta::parse_string(std::string key, TTree* tr)
 * @brief Implementation for parsing a string from a TTree branch (potentially multi-leaf).
 * @details
 * - Gets the TBranch using `tr->GetBranch(key.c_str())`.
 * - Calls `tr->GetEntry(0)` to load the first entry.
 * - Initializes an empty `std::string data`.
 * - Iterates through the `TListOfLeaves` obtained from the branch (`branch->GetListOfLeaves()`).
 * - For each `TLeaf* lx` in the list:
 *   - Gets the value pointer using `lx->GetValuePointer()`.
 *   - Reinterprets the pointer as `char** datar`.
 *   - Appends the C-string `*datar` to the `data` string.
 * - Returns the concatenated `data` string.
 */

/**
 * @fn meta::scan_sow(TObject* obj)
 * @brief Implementation for scanning sum-of-weights information.
 * @details
 * - Gets the object name.
 * - Checks if `obj->InheritsFrom("TTree")`:
 *   - Casts `obj` to `TTree* r`.
 *   - Gets a reference `weights_t* wg` to `this->meta_data.misc[obname]`.
 *   - If name is "AnalysisTracking":
 *     - Calls `parse_float` for relevant fields (`dsid`, `isAFII`, `totalEventsWeighted`, etc.) and assigns to `wg` members.
 *     - Calls `parse_string` for `generators` and `AMITag` and assigns to `wg` members.
 *   - If name is "EventLoop_FileExecuted":
 *     - Creates a `TTreeReader`.
 *     - Creates a `TTreeReaderValue<TString> dr` for the "file" branch.
 *     - Loops using `r.Next()`, reading `*dr` into a temporary `std::vector<std::string>`.
 *     - Populates `this->meta_data.inputfiles` from the temporary vector.
 * - Checks if `obj->InheritsFrom("TH1")`:
 *   - Casts `obj` to `TH1F* hs`.
 *   - Gets the X-axis `TAxis* xs`.
 *   - Gets a reference `weights_t* wg` to `this->meta_data.misc[obname]`.
 *   - Initializes `bool capture = false`.
 *   - Loops from `x = 0` to `xs->GetNbins()`:
 *     - Gets bin label `lbl = xs->GetBinLabel(x+1)`.
 *     - Gets bin content `val = hs->GetBinContent(x+1)`.
 *     - Checks `lbl` for specific strings ("Initial events", "Initial sum of weights", etc.) and assigns `val` to corresponding `wg` members.
 *     - If `lbl` contains "mc", sets `this->meta_data.campaign = lbl` and `capture = true`.
 *     - Stores the label-value pair in `wg->hist_data`.
 *   - If `capture` is true:
 *     - Attempts to read DSID from bin label 3 (`std::atoi`) into `this->meta_data.dsid`.
 *     - Attempts to read AMI tag from bin label 4 into `this->meta_data.AMITag`.
 */

/**
 * @fn meta::hash(std::string fname)
 * @brief Implementation for generating a filename hash.
 * @details
 * - Splits the input `fname` string by '/'.
 * - If the resulting vector is empty (no '/'), calls `this->tools::hash(fname)`.
 * - Otherwise, calls `this->tools::hash()` on the last element of the split vector (the base filename).
 * - Returns the result of the `tools::hash` call.
 */

/**
 * @fn meta::get_sum_of_weights(double* val, meta* m)
 * @brief Implementation of the static getter for the `sum_of_weights` property.
 * @details
 * - Accesses the `misc` map: `std::map<std::string, weights_t> data = m->misc;`.
 * - Iterates through the `data` map.
 * - For each entry, checks if `itr->second.processed_events_weighted` is not -1 (or some invalid marker).
 * - If a valid value is found, assigns it to `*val` and returns immediately.
 * - If the loop finishes without finding a valid value, `*val` remains unchanged (likely default initialized or holding a previous value).
 */

/**
 * @fn meta::get_tags(std::string hash_)
 * @brief Implementation for retrieving folding tags by hash.
 * @details
 * - Checks if `this->folds` is `nullptr`. If so, returns `nullptr`.
 * - Iterates through the vector `*(this->folds)` using an index `x`.
 * - Compares the input `hash_` with `(*this->folds)[x].hash`.
 * - If they match, returns the address `&(*this->folds)[x]`.
 * - If the loop finishes without a match, returns `nullptr`.
 */

/**
 * @fn meta::get_cross_section_fb(double* val, meta* m)
 * @brief Implementation of the static getter for the `cross_section_fb` property.
 * @details Calculates the value by accessing the `cross_section_nb` property (`m->cross_section_nb()`)
 *          and multiplying by 1,000,000. Assigns the result to `*val`.
 */

/**
 * @fn meta::get_cross_section_pb(double* val, meta* m)
 * @brief Implementation of the static getter for the `cross_section_pb` property.
 * @details Calculates the value by accessing the `cross_section_nb` property (`m->cross_section_nb()`)
 *          and multiplying by 1,000. Assigns the result to `*val`.
 */

/**
 * @fn meta::get_cross_section_nb(double* val, meta* m)
 * @brief Implementation of the static getter for the `cross_section_nb` property.
 * @details Retrieves the value directly from `m->meta_data.crossSection_mean`.
 *          Includes a check: if `tml` (temporary value) is 0, it reads it again (likely a typo, should just assign).
 *          Assigns the retrieved value to `*val`.
 */

/**
 * @fn meta::get_campaign(std::string* val, meta* m)
 * @brief Implementation of the static getter for the `campaign` property.
 * @details Calls `m->replace(&m->meta_data.campaign, " ", "")` to remove spaces from the stored campaign string in-place.
 *          Assigns the modified `m->meta_data.campaign` string to `*val`.
 */

// --- Implementations for simple static getters ---
/**
 * @fn meta::get_isMC(bool* val, meta* m)
 * @brief Assigns `m->meta_data.isMC` to `*val`.
 * @fn meta::get_found(bool* val, meta* m)
 * @brief Assigns `m->meta_data.found` to `*val`.
 * @fn meta::get_eventNumber(double* val, meta* m)
 * @brief Assigns `m->meta_data.eventNumber` to `*val`.
 * @fn meta::get_event_index(double* val, meta* m)
 * @brief Assigns `m->meta_data.event_index` to `*val`.
 * @fn meta::get_totalSize(double* val, meta* m)
 * @brief Assigns `m->meta_data.totalSize` to `*val`.
 * @fn meta::get_kfactor(double* val, meta* m)
 * @brief Assigns `m->meta_data.kfactor` to `*val`.
 * @fn meta::get_ecmEnergy(double* val, meta* m)
 * @brief Assigns `m->meta_data.ecmEnergy` to `*val`.
 * @fn meta::get_genFiltEff(double* val, meta* m)
 * @brief Assigns `m->meta_data.genFiltEff` to `*val`.
 * @fn meta::get_completion(double* val, meta* m)
 * @brief Assigns `m->meta_data.completion` to `*val`.
 * @fn meta::get_beam_energy(double* val, meta* m)
 * @brief Assigns `m->meta_data.beam_energy` to `*val`.
 * @fn meta::get_campaign_luminosity(double* val, meta* m)
 * @brief Assigns `m->meta_data.campaign_luminosity` to `*val`.
 * @fn meta::get_dsid(unsigned int* val, meta* m)
 * @brief Assigns `m->meta_data.dsid` to `*val`.
 * @fn meta::get_nFiles(unsigned int* val, meta* m)
 * @brief Assigns `m->meta_data.nFiles` to `*val`.
 * @fn meta::get_totalEvents(unsigned int* val, meta* m)
 * @brief Assigns `m->meta_data.totalEvents` to `*val`.
 * @fn meta::get_datasetNumber(unsigned int* val, meta* m)
 * @brief Assigns `m->meta_data.datasetNumber` to `*val`.
 * @fn meta::get_derivationFormat(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.derivationFormat` to `*val`.
 * @fn meta::get_AMITag(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.AMITag` to `*val`.
 * @fn meta::get_generators(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.generators` to `*val`.
 * @fn meta::get_identifier(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.identifier` to `*val`.
 * @fn meta::get_DatasetName(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.DatasetName` to `*val`.
 * @fn meta::get_prodsysStatus(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.prodsysStatus` to `*val`.
 * @fn meta::get_dataType(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.dataType` to `*val`.
 * @fn meta::get_version(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.version` to `*val`.
 * @fn meta::get_PDF(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.PDF` to `*val`.
 * @fn meta::get_AtlasRelease(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.AtlasRelease` to `*val`.
 * @fn meta::get_principalPhysicsGroup(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.principalPhysicsGroup` to `*val`.
 * @fn meta::get_physicsShort(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.physicsShort` to `*val`.
 * @fn meta::get_generatorName(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.generatorName` to `*val`.
 * @fn meta::get_geometryVersion(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.geometryVersion` to `*val`.
 * @fn meta::get_conditionsTag(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.conditionsTag` to `*val`.
 * @fn meta::get_generatorTune(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.generatorTune` to `*val`.
 * @fn meta::get_amiStatus(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.amiStatus` to `*val`.
 * @fn meta::get_beamType(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.beamType` to `*val`.
 * @fn meta::get_productionStep(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.productionStep` to `*val`.
 * @fn meta::get_projectName(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.projectName` to `*val`.
 * @fn meta::get_statsAlgorithm(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.statsAlgorithm` to `*val`.
 * @fn meta::get_genFilterNames(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.genFilterNames` to `*val`.
 * @fn meta::get_file_type(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.file_type` to `*val`.
 * @fn meta::get_sample_name(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.sample_name` to `*val`.
 * @fn meta::get_logicalDatasetName(std::string* val, meta* m)
 * @brief Assigns `m->meta_data.logicalDatasetName` to `*val`.
 * @fn meta::get_keywords(std::vector<std::string>* val, meta* m)
 * @brief Assigns `m->meta_data.keywords` to `*val`.
 * @fn meta::get_weights(std::vector<std::string>* val, meta* m)
 * @brief Assigns `m->meta_data.weights` to `*val`.
 * @fn meta::get_keyword(std::vector<std::string>* val, meta* m)
 * @brief Assigns `m->meta_data.keyword` to `*val`.
 * @fn meta::get_fileGUID(std::vector<std::string>* val, meta* m)
 * @brief Assigns `m->meta_data.fileGUID` to `*val`.
 * @fn meta::get_events(std::vector<int>* val, meta* m)
 * @brief Assigns `m->meta_data.events` to `*val`.
 * @fn meta::get_run_number(std::vector<int>* val, meta* m)
 * @brief Assigns `m->meta_data.run_number` to `*val`.
 * @fn meta::get_fileSize(std::vector<double>* val, meta* m)
 * @brief Assigns `m->meta_data.fileSize` to `*val`.
 * @fn meta::get_inputrange(std::map<int, int>* val, meta* m)
 * @brief Assigns `m->meta_data.inputrange` to `*val`.
 * @fn meta::get_inputfiles(std::map<int, std::string>* val, meta* m)
 * @brief Assigns `m->meta_data.inputfiles` to `*val`.
 * @fn meta::get_LFN(std::map<std::string, int>* val, meta* m)
 * @brief Assigns `m->meta_data.LFN` to `*val`.
 * @fn meta::get_misc(std::map<std::string, weights_t>* val, meta* m)
 * @brief Assigns `m->meta_data.misc` to `*val`.
 * @fn meta::get_config(std::map<std::string, std::string>* val, meta* m)
 * @brief Assigns `m->meta_data.config` to `*val`.
 */

// --- Corresponding Header File Content (Conceptual Doxygen Comments) ---

/**
 * @file meta.h
 * @brief Header file defining the `meta` class for metadata management.
 *
 * @details This header file declares the `meta` class, its member variables (including
 * `cproperty` accessors), public methods for interacting with metadata, and private
 * helper methods and static getter functions. It includes necessary headers for
 * dependencies like ROOT objects (`TObject`, `TTree`, `TH1F`), `rapidjson`,
 * custom structures (`meta_t`, `folds_t`, `property`), base classes (`tools`, `notification`),
 * and standard library components. It also includes a forward declaration for the `analysis` class,
 * which is declared as a friend.
 */

// #ifndef META_META_H
// #define META_META_H
//
// // Includes for dependencies (structs, ROOT, rapidjson, base classes, etc.)
// #include <structs/meta.h>
// #include <structs/folds.h>
// #include <structs/property.h>
// #include <rapidjson/document.h>
// #include <notification/notification.h>
// #include <tools/tools.h>
// #include <TFile.h> // Example ROOT includes
// #include <TTree.h>
// #include <TBranch.h>
// #include <TLeaf.h>
// #include <TH1F.h>
// #include <vector>
// #include <string>
// #include <map>
//
// // Forward declaration
// class analysis;
//
// // Class definition (as documented above)
// class meta:
//     public tools,
//     public notification
// {
//     public:
//         // Constructor, Destructor, Public Methods (declarations)
//         meta();
//         ~meta();
//         const folds_t* get_tags(std::string hash);
//         void scan_data(TObject* obj);
//         void scan_sow(TObject* obj);
//         void parse_json(std::string inpt);
//         std::string hash(std::string fname);
//
//         // Public Members (declarations)
//         rapidjson::Document* rpd;
//         std::string metacache_path;
//         meta_t meta_data;
//
//         // Public cproperty Members (declarations)
//         cproperty<bool, meta> isMC;
//         // ... (all other cproperty declarations)
//         cproperty<std::map<std::string, std::string>, meta> config;
//
//     private:
//         // Friend declaration
//         friend analysis;
//
//         // Private Methods (declarations)
//         void compiler();
//         float parse_float(std::string key, TTree* tr);
//         std::string parse_string(std::string key, TTree* tr);
//
//         // Private Members (declarations)
//         std::vector<folds_t>* folds;
//
//         // Private Static Getter Functions (declarations)
//         void static get_isMC(bool*, meta*);
//         // ... (all other static getter declarations)
//         void static get_sum_of_weights(double*, meta*);
// };
//
// #endif // META_META_H

