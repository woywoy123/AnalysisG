/**
 * @file ssml_mc20.dox
 * @brief Implementation file for the ssml_mc20 event and associated particle classes.
 *
 * This file contains the implementation details for the constructors, destructors,
 * build methods, and other specific functionalities of the ssml_mc20 event class
 * and the particle classes (jet, truthjet, muon, electron, lepton, zboson, top, parton)
 * used within this analysis context. It relies on the base templates defined in
 * `event_template` and `particle_template`.
 */

#include "event.h" // Includes the header for ssml_mc20 and potentially base classes
#include "particles.h" // Includes the header for particle definitions

// --- ssml_mc20 Event Class Implementation ---

/**
 * @brief Constructor for the ssml_mc20 event class.
 * @details Initializes the event object by setting its name, specifying the relevant
 *          ROOT tree ("reco"), and defining the leaves (branches) to be read from the
 *          input file. It maps these leaves to internal variable names, often appending
 *          a systematic variation suffix (`_NOSYS`). It also registers the particle types
 *          (Zprime, tops, truthjets, partons, leptons, electrons, muons, jets) that
 *          will be built and managed by this event object.
 */
ssml_mc20::ssml_mc20(){
    // Implementation details...
    // Sets name, trees, adds leaves for event variables, weights, kinematics,
    // particle counts, and registers particle handlers.
}

/**
 * @brief Destructor for the ssml_mc20 event class.
 * @details Handles the cleanup of resources allocated by the ssml_mc20 object.
 *          Since particle objects are managed via maps and potentially vectors of
 *          pointers, this ensures proper memory management when an event object
 *          goes out of scope or is deleted. The base class destructor likely handles
 *          the core cleanup of registered particles.
 */
ssml_mc20::~ssml_mc20(){
    // Implementation details... (likely empty, relying on base class destructor)
}

/**
 * @brief Creates a clone (deep copy) of the current ssml_mc20 event object.
 * @details Implements the virtual `clone` method inherited from `event_template`.
 *          This is crucial for polymorphism, allowing copies to be made through
 *          base class pointers. It allocates a new `ssml_mc20` object on the heap
 *          and returns a pointer to it, cast as an `event_template*`.
 * @return event_template* Pointer to the newly created ssml_mc20 object (caller owns memory).
 */
event_template* ssml_mc20::clone(){
    // Implementation details...
    // Creates a new ssml_mc20 instance and returns a base class pointer.
}

/**
 * @brief Populates the event's member variables from the raw data container.
 * @details Implements the virtual `build` method. It extracts data for each leaf
 *          defined in the constructor from the provided `element_t` object (which
 *          represents the data source for a single event, e.g., a TTree entry).
 *          It assigns the retrieved values to the corresponding member variables
 *          of the `ssml_mc20` object (e.g., eventNumber, weights, MET, particle counts).
 *          Special handling is done for boolean flags stored as chars in the input.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void ssml_mc20::build(element_t* el){
    // Implementation details...
    // Uses el->get() to retrieve values for all registered event leaves
    // and assign them to the corresponding member variables.
    // Handles type conversions (e.g., char to int for boolean flags).
}

/**
 * @brief Processes the built event data to establish relationships and create final particle collections.
 * @details Implements the virtual `CompileEvent` method. This method is called after `build`.
 *          It performs crucial post-processing steps:
 *          1. Sorts the particles retrieved during `build` (stored in internal maps like `m_jets`, `m_muons`) by their index.
 *          2. Creates final, sorted vectors of particle pointers (e.g., `Tops`, `Zprime`, `Detector`, `Leptons`).
 *          3. Establishes parent-child relationships between particles (e.g., Z' -> top, top -> partons, parton -> reco/truth objects).
 *          4. Performs matching between different particle types (e.g., truth partons to reconstructed jets/leptons) using indices stored during `build`.
 *          5. Sets flags like `broken_event` if inconsistencies are found during matching.
 */
void ssml_mc20::CompileEvent(){
    // Implementation details...
    // Sorts particle maps (m_tops, m_jets, etc.) using sort_by_index.
    // Vectorizes maps into public vectors (Tops, Zprime, Detector, etc.).
    // Iterates through partons to link them to jets, truthjets, muons, electrons based on indices.
    // Calls match_object to link tops to their decay products (partons, electrons, muons, jets, truthjets).
    // Populates final particle vectors (Detector, Leptons, Leptsn, Electrons).
}


// --- jet Particle Class Implementation ---

/**
 * @brief Constructor for the jet particle class.
 * @details Initializes a jet object. Sets the particle type identifier to "jet".
 *          Defines the leaves (branches) specific to jets (eta, phi, pt, energy, flavor,
 *          b-tagging info, truth matching index) and applies the type prefix ("jet")
 *          to them. Initializes the `from_res` computed property, linking it to the
 *          `get_from_res` static method.
 */
jet::jet(){
    // Implementation details...
    // Sets type, adds leaves for jet properties, applies prefix, sets up cproperty.
}

/**
 * @brief Destructor for the jet particle class.
 * @details Handles cleanup for a jet object. (Likely empty, relying on base class).
 */
jet::~jet(){}

/**
 * @brief Creates a clone (deep copy) of the current jet object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created jet object (caller owns memory).
 */
particle_template* jet::clone(){
    // Implementation details...
    // Creates a new jet instance and returns a base class pointer.
}

/**
 * @brief Builds jet particle objects from the raw event data.
 * @details Implements the static `build` method. It's called by the event's `build` process.
 *          1. Uses the `pmu` helper template to create basic jet objects with kinematic properties (pt, eta, phi, e) from the `element_t`.
 *          2. Retrieves vectors of b-tagging decisions and truth information (flavor, top index) from the `element_t`.
 *          3. Iterates through the created jet objects, assigning the corresponding b-tagging flags, pdgid (flavor), and truth top index.
 *          4. Stores the fully constructed jet objects in the provided map (`prt`), keyed by their unique hash.
 * @param prt Pointer to the map (string -> particle_template*) where created jet objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void jet::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Calls pmu to create jet objects with kinematics.
    // Gets vectors for b-tagging flags, selection flags, top index, flavor.
    // Loops through created jets, assigns properties, adds to the prt map.
}

/**
 * @brief Static getter method for the `from_res` computed property of a jet.
 * @details Determines if the jet originates from the decay of a resonant particle (e.g., a top quark marked as `from_res`).
 *          It iterates through the jet's registered parent particles. If any parent is a `top` quark and that top's `from_res` flag is true,
 *          this jet is considered to be from the resonance.
 * @param[out] val Pointer to a boolean that will be set to true if the jet is from resonance, false otherwise.
 * @param el Pointer to the jet object whose `from_res` status is being queried.
 */
void jet::get_from_res(bool* val, jet* el){
    // Implementation details...
    // Iterates through el->parents, casts to top*, checks top->from_res.
    // Sets *val to true if a resonant parent top is found, otherwise false.
}


// --- truthjet Particle Class Implementation ---

/**
 * @brief Constructor for the truthjet particle class.
 * @details Initializes a truthjet object. Sets the particle type identifier to "truth_jet".
 *          Defines the leaves specific to truth jets (energy, eta, phi, pt, parton ID)
 *          and applies the type prefix ("truth_jet").
 */
truthjet::truthjet(){
    // Implementation details...
    // Sets type, adds leaves for truth jet properties, applies prefix.
}

/**
 * @brief Destructor for the truthjet particle class.
 * @details Handles cleanup for a truthjet object. (Likely empty).
 */
truthjet::~truthjet(){}

/**
 * @brief Creates a clone (deep copy) of the current truthjet object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created truthjet object (caller owns memory).
 */
particle_template* truthjet::clone(){
    // Implementation details...
    // Creates a new truthjet instance and returns a base class pointer.
}

/**
 * @brief Builds truthjet particle objects from the raw event data.
 * @details Implements the static `build` method.
 *          1. Uses the `pmu` helper template to create basic truthjet objects with kinematic properties.
 *          2. Retrieves the vector of parton IDs (`_partonid`) from the `element_t`.
 *          3. Iterates through the created truthjet objects, assigning the corresponding `pdgid`.
 *          4. Stores the fully constructed truthjet objects in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where created truthjet objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void truthjet::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Calls pmu to create truthjet objects with kinematics.
    // Gets vector for parton IDs.
    // Loops through created truthjets, assigns pdgid, adds to the prt map.
}


// --- muon Particle Class Implementation ---

/**
 * @brief Constructor for the muon particle class.
 * @details Initializes a muon object. Sets the type to "mu". Defines leaves for
 *          muon properties (eta, phi, charge, pt, energy, truth top index) and
 *          applies the prefix. Initializes the `from_res` computed property.
 */
muon::muon(){
    // Implementation details...
    // Sets type, adds leaves, applies prefix, sets up cproperty.
}

/**
 * @brief Destructor for the muon particle class.
 * @details Handles cleanup for a muon object. (Likely empty).
 */
muon::~muon(){}

/**
 * @brief Creates a clone (deep copy) of the current muon object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created muon object (caller owns memory).
 */
particle_template* muon::clone(){
    // Implementation details...
    // Creates a new muon instance and returns a base class pointer.
}

/**
 * @brief Builds muon particle objects from the raw event data.
 * @details Implements the static `build` method.
 *          1. Uses `pmu` to create basic muon objects with kinematics.
 *          2. Retrieves vectors for charge and truth top index.
 *          3. Iterates through created muons, assigning index, charge, pdgid (derived from charge), and truth top index.
 *          4. Stores the fully constructed muon objects in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where created muon objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void muon::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Calls pmu to create muon objects with kinematics.
    // Gets vectors for charge, top index.
    // Loops through created muons, assigns properties (charge, pdgid, top_index), adds to prt map.
}

/**
 * @brief Static getter method for the `from_res` computed property of a muon.
 * @details Determines if the muon originates from the decay of a resonant particle (e.g., a top quark marked as `from_res`).
 *          Functions identically to `jet::get_from_res` but operates on muon parents.
 * @param[out] val Pointer to a boolean that will be set to true if the muon is from resonance, false otherwise.
 * @param el Pointer to the muon object whose `from_res` status is being queried.
 */
void muon::get_from_res(bool* val, muon* el){
    // Implementation details...
    // Iterates through el->parents, casts to top*, checks top->from_res.
    // Sets *val to true if a resonant parent top is found, otherwise false.
}


// --- electron Particle Class Implementation ---

/**
 * @brief Constructor for the electron particle class.
 * @details Initializes an electron object. Sets the type to "el". Defines leaves for
 *          electron properties (eta, phi, pt, energy, charge, truth top index, ECIDS flag)
 *          and applies the prefix. Initializes the `from_res` computed property.
 */
electron::electron(){
    // Implementation details...
    // Sets type, adds leaves, applies prefix, sets up cproperty.
}

/**
 * @brief Destructor for the electron particle class.
 * @details Handles cleanup for an electron object. (Likely empty).
 */
electron::~electron(){}

/**
 * @brief Creates a clone (deep copy) of the current electron object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created electron object (caller owns memory).
 */
particle_template* electron::clone(){
    // Implementation details...
    // Creates a new electron instance and returns a base class pointer.
}

/**
 * @brief Builds electron particle objects from the raw event data.
 * @details Implements the static `build` method.
 *          1. Uses `pmu` to create basic electron objects with kinematics.
 *          2. Retrieves vectors for charge, truth top index, and ECIDS flag.
 *          3. Iterates through created electrons, assigning index, charge, pdgid (derived from charge), ECIDS status, and truth top index.
 *          4. Stores the fully constructed electron objects in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where created electron objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void electron::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Calls pmu to create electron objects with kinematics.
    // Gets vectors for charge, top index, ECIDS flag.
    // Loops through created electrons, assigns properties (charge, pdgid, pass_ecids, top_index), adds to prt map.
}

/**
 * @brief Static getter method for the `from_res` computed property of an electron.
 * @details Determines if the electron originates from the decay of a resonant particle (e.g., a top quark marked as `from_res`).
 *          Functions identically to `jet::get_from_res` but operates on electron parents.
 * @param[out] val Pointer to a boolean that will be set to true if the electron is from resonance, false otherwise.
 * @param el Pointer to the electron object whose `from_res` status is being queried.
 */
void electron::get_from_res(bool* val, electron* el){
    // Implementation details...
    // Iterates through el->parents, casts to top*, checks top->from_res.
    // Sets *val to true if a resonant parent top is found, otherwise false.
}


// --- lepton Particle Class Implementation ---

/**
 * @brief Constructor for the lepton particle class.
 * @details Initializes a generic lepton object (likely representing a combined collection or truth leptons
 *          not directly matched to reco). Sets the type to "lepton". Defines leaves for basic properties
 *          (eta, phi, pt, e, charge) and an ambiguity flag, then applies the prefix.
 */
lepton::lepton(){
    // Implementation details...
    // Sets type, adds leaves (eta, phi, pt, e, charge, ambiguity), applies prefix.
}

/**
 * @brief Destructor for the lepton particle class.
 * @details Handles cleanup for a lepton object. (Likely empty).
 */
lepton::~lepton(){}

/**
 * @brief Creates a clone (deep copy) of the current lepton object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created lepton object (caller owns memory).
 */
particle_template* lepton::clone(){
    // Implementation details...
    // Creates a new lepton instance and returns a base class pointer.
}

/**
 * @brief Builds generic lepton particle objects from the raw event data.
 * @details Implements the static `build` method.
 *          1. Retrieves vectors for kinematic properties (pt, eta, phi, e), charge, and the ambiguity flag.
 *          2. Iterates, creating a new `lepton` object for each entry.
 *          3. Assigns the retrieved properties (pt, eta, phi, e, charge, ambiguity) and index to each new lepton.
 *          4. Stores the fully constructed lepton objects in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where created lepton objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void lepton::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Gets vectors for kinematics, charge, ambiguity flag.
    // Loops through size of pt vector, creates new lepton objects, assigns properties, adds to prt map.
}


// --- zboson Particle Class Implementation ---

/**
 * @brief Constructor for the zboson particle class (representing a truth Z' boson).
 * @details Initializes a Z' boson object. Sets the type to "parton_Zprime". Defines leaves
 *          for its properties (mass, eta, phi, pt) and applies the prefix.
 */
zboson::zboson(){
    // Implementation details...
    // Sets type, adds leaves (mass, eta, phi, pt), applies prefix.
}

/**
 * @brief Destructor for the zboson particle class.
 * @details Handles cleanup for a Z' boson object. (Likely empty).
 */
zboson::~zboson(){}

/**
 * @brief Creates a clone (deep copy) of the current zboson object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created zboson object (caller owns memory).
 */
particle_template* zboson::clone(){
    // Implementation details...
    // Creates a new zboson instance and returns a base class pointer.
}

/**
 * @brief Builds a Z' boson particle object from the raw event data.
 * @details Implements the static `build` method. Assumes only one Z' per event.
 *          1. Retrieves vectors for kinematic properties (pt, eta, phi, mass).
 *          2. If data exists (pt vector is not empty), creates a single `zboson` object.
 *          3. Assigns the properties from the first element of the retrieved vectors.
 *          4. Stores the Z' boson object in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where the created Z' object should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void zboson::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Gets vectors for kinematics (pt, eta, phi, mass).
    // If pt.size() > 0, creates one new zboson, assigns properties from index 0, adds to prt map.
}


// --- top Particle Class Implementation ---

/**
 * @brief Constructor for the top particle class (representing a truth top quark).
 * @details Initializes a top quark object. Sets the type to "parton_top". Defines leaves
 *          for its properties (eta, phi, pt, mass) and a flag indicating if it's from
 *          a Z' decay (`_isFromZprime`), then applies the prefix.
 */
top::top(){
    // Implementation details...
    // Sets type, adds leaves (eta, phi, pt, mass, from_res flag), applies prefix.
}

/**
 * @brief Destructor for the top particle class.
 * @details Handles cleanup for a top object. (Likely empty).
 */
top::~top(){}

/**
 * @brief Creates a clone (deep copy) of the current top object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created top object (caller owns memory).
 */
particle_template* top::clone(){
    // Implementation details...
    // Creates a new top instance and returns a base class pointer.
}

/**
 * @brief Builds top quark particle objects from the raw event data.
 * @details Implements the static `build` method.
 *          1. Uses the `pmu_mass` helper template to create basic top objects with kinematic properties (pt, eta, phi, mass).
 *          2. Retrieves the vector indicating if each top is from a Z' decay (`_isFromZprime`).
 *          3. Iterates through the created top objects, assigning the index and the `from_res` flag.
 *          4. Stores the fully constructed top objects in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where created top objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void top::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Calls pmu_mass to create top objects with kinematics.
    // Gets vector for from_res flag.
    // Loops through created tops, assigns index and from_res flag, adds to prt map.
}


// --- parton Particle Class Implementation ---

/**
 * @brief Constructor for the parton particle class (representing truth partons from top/W decays).
 * @details Initializes a parton object. Sets the type to "parton". Defines leaves for the
 *          properties of the two W decay products (Wdecay1, Wdecay2: mass, eta, phi, pt, pdgId)
 *          and the b quark (mass, eta, phi, pt). Also defines leaves for the indices linking
 *          these partons to their corresponding reconstructed objects (electrons, muons, reco jets)
 *          and truth jets. Note: This structure implies each 'parton' object created might represent
 *          one specific decay product (W-decay-1, W-decay-2, or b), identified later by its properties.
 */
parton::parton(){
    // Implementation details...
    // Sets type, adds leaves for Wdecay1, Wdecay2, b properties and their matching indices.
    // Does *not* apply prefix here, as leaf names are explicit.
}

/**
 * @brief Destructor for the parton particle class.
 * @details Handles cleanup for a parton object. (Likely empty).
 */
parton::~parton(){}

/**
 * @brief Creates a clone (deep copy) of the current parton object.
 * @details Implements the virtual `clone` method for polymorphism.
 * @return particle_template* Pointer to the newly created parton object (caller owns memory).
 */
particle_template* parton::clone(){
    // Implementation details...
    // Creates a new parton instance and returns a base class pointer.
}

/**
 * @brief Builds parton particle objects from the raw event data.
 * @details Implements the static `build` method. This method creates multiple `parton` objects per event,
 *          one for each W decay product and b quark associated with each top quark.
 *          1. Retrieves vectors for Wdecay1 properties (kinematics, pdgid) and matching indices (el, mu, reco j, truth j).
 *          2. Iterates, creating a `parton` object for each Wdecay1 entry, assigning properties and indices. The `top_index` is set to the loop index `x`.
 *          3. Stores these Wdecay1 partons in the provided map (`prt`).
 *          4. Repeats steps 1-3 for Wdecay2 properties and indices.
 *          5. Retrieves vectors for b quark properties (kinematics) and matching indices (reco j, truth j).
 *          6. Iterates, creating a `parton` object for each b quark entry, assigning properties (pdgid is hardcoded to 5) and indices. `top_index` is set to `x`.
 *          7. Stores these b partons in the provided map (`prt`).
 * @param prt Pointer to the map (string -> particle_template*) where created parton objects should be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
void parton::build(std::map<std::string, particle_template*>* prt, element_t* el){
    // Implementation details...
    // Gets vectors for Wdecay1 properties and indices.
    // Loops, creates new parton objects for Wdecay1, assigns properties/indices, adds to prt map.
    // Gets vectors for Wdecay2 properties and indices.
    // Loops, creates new parton objects for Wdecay2, assigns properties/indices, adds to prt map.
    // Gets vectors for b properties and indices.
    // Loops, creates new parton objects for b, assigns properties/indices (pdgid=5), adds to prt map.
}


// --- Header File: event.h ---

#ifndef EVENTS_SSML_MC20_H
#define EVENTS_SSML_MC20_H

#include <ssml_mc20/particles.h> // Include particle definitions used by this event
#include <templates/event_template.h> // Include the base event template

#include <vector> // For std::vector
#include <map>    // For std::map
#include <string> // For std::string

// Forward declarations for particle types used in internal maps
class jet;
class muon;
class electron;
class lepton;
class zboson;
class top;
class parton;
class truthjet;
class element_t; // Forward declaration for the data element type

/**
 * @brief Represents an event structure specifically tailored for the ssml_mc20 analysis.
 *
 * @details This class inherits from `event_template` and encapsulates all the relevant information
 *          for a single event in the ssml_mc20 Monte Carlo simulation dataset. It includes
 *          event-level variables (like event number, category, MET), weights (MC, pileup, SFs),
 *          kinematic properties (HT), particle counts, selection flags, and collections
 *          of reconstructed and truth particles (stored as pointers in vectors).
 *          It defines methods for building the event data from an underlying data source (`element_t`)
 *          via `build()` and for post-processing and linking particles via `CompileEvent()`.
 */
class ssml_mc20: public event_template
{
    public:
        /**
         * @brief Default constructor for the ssml_mc20 class.
         * @details Initializes a new instance of the ssml_mc20 event, setting up
         *          internal structures and default values. See implementation for details
         *          on leaf registration and particle handler setup.
         */
        ssml_mc20();

        /**
         * @brief Virtual destructor for the ssml_mc20 class.
         * @details Ensures proper cleanup of resources, especially for derived classes and
         *          dynamically allocated particle objects managed by the event. Relies on
         *          the base class destructor for handling registered particles.
         */
        virtual ~ssml_mc20();

        // --- Event Variables ---
        /** @brief Unique identifier for the event. */
        unsigned long long eventNumber;
        /** @brief Categorization of the event (e.g., background category). Meaning defined by analysis. */
        float event_category;

        // --- Weights ---
        /** @brief Monte Carlo generator weight (cross-section, generator specifics). */
        float weight_mc;
        /** @brief Pileup reweighting factor. */
        float weight_pileup;
        /** @brief Beamspot condition reweighting factor. */
        float weight_beamspot;
        /** @brief Jet Vertex Tagger (JVT) efficiency scale factor weight. */
        float weight_jvt_effSF;
        /** @brief Lepton (tight selection) scale factor weight (ID, isolation, etc.). */
        float weight_lep_tightSF;
        /** @brief Flavor tagging (b-tagging) efficiency scale factor weight (e.g., GN2v01 Continuous). */
        float weight_ftag_effSF;
        /** @brief Global trigger efficiency scale factor. */
        float global_trigger_SF;

        // --- Kinematics ---
        /** @brief Azimuthal angle (phi) of the missing transverse momentum vector. */
        float phi;
        /** @brief Magnitude of the missing transverse momentum (MET). */
        float met;
        /** @brief Scalar sum of transverse energy used in MET calculation (SumET). */
        float met_sum;
        /** @brief Scalar sum of transverse momenta (pT) of all selected jets and leptons. */
        float HT_all;

        // --- Selection Flags ---
        /** @brief Pass flag for same-sign di-electron selection (1=pass, 0=fail). */
        int pass_ssee;
        /** @brief Pass flag for same-sign electron-muon selection (1=pass, 0=fail). */
        int pass_ssem;
        /** @brief Pass flag for same-sign di-muon selection (1=pass, 0=fail). */
        int pass_ssmm;
        /** @brief Pass flag for electron-electron-muon + Z veto selection (1=pass, 0=fail). */
        int pass_eem_zveto;
        /** @brief Pass flag for tri-electron + Z veto selection (1=pass, 0=fail). */
        int pass_eee_zveto;
        /** @brief Pass flag for electron-muon-muon + Z veto selection (1=pass, 0=fail). */
        int pass_emm_zveto;
        /** @brief Pass flag for tri-muon + Z veto selection (1=pass, 0=fail). */
        int pass_mmm_zveto;
        /** @brief Pass flag for four-lepton + Z veto selection (1=pass, 0=fail). */
        int pass_llll_zveto;
        /** @brief Pass flag for electron-electron-muon selection (no Z veto) (1=pass, 0=fail). */
        int pass_eem;
        /** @brief Pass flag for tri-electron selection (no Z veto) (1=pass, 0=fail). */
        int pass_eee;
        /** @brief Pass flag for electron-muon-muon selection (no Z veto) (1=pass, 0=fail). */
        int pass_emm;
        /** @brief Pass flag for tri-muon selection (no Z veto) (1=pass, 0=fail). */
        int pass_mmm;

        // --- Status Flag ---
        /** @brief Flag indicating if an issue occurred during event processing (e.g., matching failure). Defaults to false. */
        bool broken_event = false;

        // --- Particle Counts ---
        /** @brief Number of selected electrons. */
        int n_electrons;
        /** @brief Number of selected forward jets (f-jets). */
        int n_fjets;
        /** @brief Number of selected central jets. */
        int n_jets;
        /** @brief Total number of selected leptons (electrons + muons). */
        int n_leptons;
        /** @brief Number of selected muons. */
        int n_muons;

        // --- Particle Collections (Populated by CompileEvent) ---
        /** @brief Vector of pointers to truth top quark objects. */
        std::vector<particle_template*> Tops;
        /** @brief Vector of pointers to truth partons (from top/W decays). */
        std::vector<particle_template*> TruthChildren;
        /** @brief Vector of pointers to truth Z' boson objects (typically size 0 or 1). */
        std::vector<particle_template*> Zprime;
        /** @brief Vector of pointers to generic truth lepton objects. */
        std::vector<particle_template*> Leptsn; // Note: Name might be typo for TruthLeptons
        /** @brief Vector of pointers to reconstructed electron objects. */
        std::vector<particle_template*> Electrons;
        /** @brief Vector of pointers to reconstructed jet objects. */
        std::vector<particle_template*> Jets;
        /** @brief Vector of pointers to reconstructed lepton (electron or muon) objects. */
        std::vector<particle_template*> Leptons;
        /** @brief Vector of pointers to detector-level objects (jets, electrons, muons combined). */
        std::vector<particle_template*> Detector;
        /** @brief Vector of pointers to truth jet objects. */
        std::vector<particle_template*> TruthJets;

        // --- Core Methods ---
        /**
         * @brief Creates a deep copy (clone) of the current ssml_mc20 event object.
         * @details Overrides the virtual `clone` method from `event_template`.
         * @return A pointer to the newly created `event_template` (dynamically castable to ssml_mc20*).
         *         The caller is responsible for managing the memory of the returned object.
         */
        event_template* clone() override;

        /**
         * @brief Builds the event structure by populating members from a generic data element.
         * @details Overrides the virtual `build` method. Extracts event variables, weights,
         *          kinematics, and particle data from the input `element_t` and stores them
         *          internally (member variables and private maps like `m_jets`, `m_muons`).
         * @param el Pointer to the `element_t` object containing the raw event data.
         */
        void build(element_t* el) override;

        /**
         * @brief Compiles the event data after it has been built.
         * @details Overrides the virtual `CompileEvent` method. Processes the internally stored
         *          particle data (e.g., sorting, matching truth to reco, establishing parent-child links),
         *          populates the public particle vectors (`Jets`, `Leptons`, `Tops`, etc.), and sets
         *          flags like `broken_event`.
         */
        void CompileEvent() override;

    private:
        // --- Internal Particle Storage (Populated by build, Processed by CompileEvent) ---
        /** @brief Internal map storing reconstructed jets, keyed by hash, used during `build`. */
        std::map<std::string, jet*>      m_jets;
        /** @brief Internal map storing reconstructed muons, keyed by hash, used during `build`. */
        std::map<std::string, muon*>     m_muons;
        /** @brief Internal map storing reconstructed electrons, keyed by hash, used during `build`. */
        std::map<std::string, electron*> m_electrons;
        /** @brief Internal map storing generic leptons, keyed by hash, used during `build`. */
        std::map<std::string, lepton*>   m_leptons;
        /** @brief Internal map storing truth Z' bosons, keyed by hash, used during `build`. */
        std::map<std::string, zboson*>   m_zprime;
        /** @brief Internal map storing truth top quarks, keyed by hash, used during `build`. */
        std::map<std::string, top*>      m_tops;
        /** @brief Internal map storing truth partons, keyed by hash, used during `build`. */
        std::map<std::string, parton*>    m_partons;
        /** @brief Internal map storing truth jets, keyed by hash, used during `build`. */
        std::map<std::string, truthjet*>  m_truthjets;

        // --- Helper Templates (Implementation likely in base class or .cxx file) ---
        /**
         * @brief Template helper function to sort particles stored in a map by their integer index.
         * @details Takes a map keyed by string and containing pointers to particle objects (which must have an `index` member)
         *          and returns a new map keyed by the integer index, facilitating ordered access.
         * @tparam G The type of the particle object pointer stored in the map values (e.g., `jet*`, `muon*`).
         * @param ipt Pointer to the input map (string -> G*).
         * @return A map sorted by the particle index (int -> G*).
         */
        template <typename G>
        std::map<int, G*> sort_by_index(std::map<std::string, G*>* ipt);

        /**
         * @brief Template helper function to copy pointers from a map's values into a vector.
         * @details Iterates through the input map and appends each value (which is a pointer, potentially
         *          to a derived type) into the provided vector (which stores base class pointers).
         * @tparam m The key type of the input map (e.g., `std::string`, `int`).
         * @tparam G The value type (derived particle pointer type) stored in the input map (e.g., `jet*`, `top*`).
         * @tparam g The pointer type stored in the output vector (usually a base class pointer like `particle_template*`).
         * @param ipt Pointer to the input map.
         * @param vec Pointer to the output vector to be populated.
         */
        template <typename m, typename G, typename g>
        void vectorize(std::map<m, G*>* ipt, std::vector<g*>* vec);

        /**
         * @brief Template helper function to match reconstructed or truth objects to their parent truth tops.
         * @details Iterates through a map of objects (`objects`) and attempts to associate them with truth tops
         *          stored in the `topx` map based on the `top_index` member of the objects. It populates
         *          the particle vectors within the corresponding `top` objects (e.g., `top->leptons`, `top->jets`)
         *          and also registers parent-child relationships. It contributes to populating event-level
         *          vectors like `TruthChildren`.
         * @tparam lx The type of the object pointer stored in the `objects` map (e.g., `muon*`, `jet*`, `parton*`).
         * @param topx Pointer to a map of truth tops, keyed by their index (int -> top*). This map should be pre-sorted by index.
         * @param objects Pointer to a map of objects to be matched, keyed by string (string -> lx*).
         * @return `true` if any object had a `top_index` of -2 (indicating a potential issue or specific category), `false` otherwise. Used to set `broken_event`.
         */
        template <typename lx>
        bool match_object(std::map<int, top*>* topx, std::map<std::string, lx*>* objects);

}; // End class ssml_mc20

#endif // EVENTS_SSML_MC20_H


// --- Header File: particles.h ---

#ifndef PARTICLES_SSML_MC20_H
#define PARTICLES_SSML_MC20_H

#include <templates/particle_template.h> // Include the base particle template
#include <templates/element_t.h>       // Include element_t for build methods
#include <vector>                      // For std::vector
#include <map>                         // For std::map
#include <string>                      // For std::string

// --- Helper Templates for Particle Building ---

/**
 * @brief Template helper function to populate a vector of particle objects with basic kinematics (pt, eta, phi, energy).
 * @details Retrieves vectors of pt, eta, phi, and energy from the `element_t` data source.
 *          For each element in the vectors, it creates a new particle object of type `g` (passed as template parameter),
 *          assigns the kinematic properties and the index, and adds the new object pointer to the output vector `out`.
 * @tparam g The concrete particle class type to instantiate (e.g., `jet`, `muon`). Must inherit from `particle_template`.
 * @param[out] out Pointer to the vector where the created particle pointers will be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
template <typename g>
void pmu(std::vector<g*>* out, element_t* el){
    // Implementation details...
    // Gets pt, eta, phi, energy vectors from el.
    // Loops through pt size, creates new g(), assigns kinematics and index, pushes to out vector.
};

/**
 * @brief Template helper function similar to `pmu`, but uses mass instead of energy.
 * @details Retrieves vectors of pt, eta, phi, and mass from the `element_t` data source.
 *          Creates new particle objects of type `g`, assigns pt, eta, phi, mass, and index,
 *          and adds them to the output vector `out`. Includes a check to stop if negative mass is encountered.
 * @tparam g The concrete particle class type to instantiate (e.g., `top`). Must inherit from `particle_template`.
 * @param[out] out Pointer to the vector where the created particle pointers will be stored.
 * @param el Pointer to the `element_t` object holding the raw data for the current event.
 */
template <typename g>
void pmu_mass(std::vector<g*>* out, element_t* el){
    // Implementation details...
    // Gets pt, eta, phi, mass vectors from el.
    // Loops through pt size, breaks if mass < 0, creates new g(), assigns kinematics and index, pushes to out vector.
};


// --- Particle Class Declarations ---

/**
 * @brief Represents a truth Z' boson particle.
 * @details Inherits from `particle_template`. Stores basic kinematic properties (pt, eta, phi, mass).
 */
class zboson: public particle_template
{
    public:
        /** @brief Constructor. Sets type name and registers leaves. */
        zboson();
        /** @brief Virtual destructor. */
        virtual ~zboson();

        /** @brief Clones the zboson object. */
        particle_template* clone() override;
        /** @brief Static build method to create Z' boson(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);
};

/**
 * @brief Represents a truth top quark particle.
 * @details Inherits from `particle_template`. Stores kinematics and a flag indicating
 *          if it originates from a resonance (Z'). Also holds vectors to store pointers
 *          to its associated decay products (jets, leptons, truthjets) populated during
 *          `CompileEvent`.
 */
class top: public particle_template
{
    public:
        /** @brief Constructor. Sets type name and registers leaves. */
        top();
        /** @brief Virtual destructor. */
        virtual ~top();

        /** @brief Flag: True if this top quark originates from the Z' resonance decay. */
        bool from_res = false;

        /** @brief Vector of associated reconstructed jets (pointers). Populated by `CompileEvent`. */
        std::vector<particle_template*> jets = {};
        /** @brief Vector of associated reconstructed leptons (pointers). Populated by `CompileEvent`. */
        std::vector<particle_template*> leptons = {};
        /** @brief Vector of associated truth jets (pointers). Populated by `CompileEvent`. */
        std::vector<particle_template*> truthjets = {};

        /** @brief Clones the top object. */
        particle_template* clone() override;
        /** @brief Static build method to create top quark(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);
};

/**
 * @brief Represents a truth jet particle.
 * @details Inherits from `particle_template`. Stores kinematics and parton ID.
 *          Also stores the index of the truth top it is associated with (if any).
 */
class truthjet: public particle_template
{
    public:
        /** @brief Constructor. Sets type name and registers leaves. */
        truthjet();
        /** @brief Virtual destructor. */
        virtual ~truthjet();

        /** @brief Index of the parent truth top quark (-1 if none/not matched). */
        int top_index = -1;

        /** @brief Clones the truthjet object. */
        particle_template* clone() override;
        /** @brief Static build method to create truth jet(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);
};

/**
 * @brief Represents a reconstructed jet particle.
 * @details Inherits from `particle_template`. Stores kinematics, flavor (pdgid),
 *          b-tagging information (multiple working points), and the index of the
 *          matched truth top. Includes a computed property `from_res` to check
 *          if it originates from a resonant top decay.
 */
class jet: public particle_template
{
    public:
        /** @brief Constructor. Sets type name, registers leaves, initializes cproperty. */
        jet();
        /** @brief Virtual destructor. */
        virtual ~jet();

        /** @brief Computed property: True if the jet originates from a resonant top decay. */
        cproperty<bool, jet> from_res;

        /** @brief Index of the matched truth top quark (-1 or -2 if none/ambiguous). */
        int top_index = -1;
        /** @brief B-tagging decision using the GN2v01 77% efficiency working point. */
        bool btag_77 = false;
        /** @brief B-tagging decision using the GN2v01 85% efficiency working point. */
        bool btag_85 = false;
        /** @brief B-tagging decision using the GN2v01 90% efficiency working point. */
        bool btag_90 = false;
        /** @brief Selection flag based on the GN2v01 85% WP (potentially includes kinematic cuts). */
        bool sel_85  = false;

        /** @brief Clones the jet object. */
        particle_template* clone() override;
        /** @brief Static build method to create jet(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);

    // Keep the static getter public or friend declaration if needed by cproperty
    // public: // Or make cproperty a friend
        /**
         * @brief Static getter function used by the `from_res` cproperty.
         * @param[out] val Pointer to the boolean result.
         * @param el Pointer to the jet instance being queried.
         */
        static void get_from_res(bool* val, jet* el);
};

/**
 * @brief Represents a reconstructed electron particle.
 * @details Inherits from `particle_template`. Stores kinematics, charge, PDG ID,
 *          ECIDS status, and the index of the matched truth top. Includes a
 *          computed property `from_res`.
 */
class electron: public particle_template
{
    public:
        /** @brief Constructor. Sets type name, registers leaves, initializes cproperty. */
        electron();
        /** @brief Virtual destructor. */
        virtual ~electron();

        /** @brief Computed property: True if the electron originates from a resonant top decay. */
        cproperty<bool, electron> from_res;
        /** @brief Index of the matched truth top quark (-1 or -2 if none/ambiguous). */
        int top_index = -1;
        /** @brief Flag indicating if the electron passes ECIDS criteria (-1 if not available). */
        int pass_ecids = -1;

        /** @brief Clones the electron object. */
        particle_template* clone() override;
        /** @brief Static build method to create electron(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);

    // Keep the static getter public or friend declaration if needed by cproperty
    // public: // Or make cproperty a friend
        /**
         * @brief Static getter function used by the `from_res` cproperty.
         * @param[out] val Pointer to the boolean result.
         * @param el Pointer to the electron instance being queried.
         */
        static void get_from_res(bool* val, electron* el);

};

/**
 * @brief Represents a reconstructed muon particle.
 * @details Inherits from `particle_template`. Stores kinematics, charge, PDG ID,
 *          and the index of the matched truth top. Includes a computed property `from_res`.
 */
class muon: public particle_template
{
    public:
        /** @brief Constructor. Sets type name, registers leaves, initializes cproperty. */
        muon();
        /** @brief Virtual destructor. */
        virtual ~muon();

        /** @brief Index of the matched truth top quark (-1 or -2 if none/ambiguous). */
        int top_index = -1;
        /** @brief Computed property: True if the muon originates from a resonant top decay. */
        cproperty<bool, muon> from_res;

        /** @brief Clones the muon object. */
        particle_template* clone() override;
        /** @brief Static build method to create muon(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);

    // Keep the static getter public or friend declaration if needed by cproperty
    // public: // Or make cproperty a friend
        /**
         * @brief Static getter function used by the `from_res` cproperty.
         * @param[out] val Pointer to the boolean result.
         * @param el Pointer to the muon instance being queried.
         */
        static void get_from_res(bool* val, muon* el);
};

/**
 * @brief Represents a truth parton (from W/top decay).
 * @details Inherits from `particle_template`. Stores kinematics, PDG ID, and indices
 *          linking it to the parent top, associated reco jet, truth jet, reco muon,
 *          and reco electron. Also holds maps to directly access linked jet/truthjet objects
 *          after `CompileEvent`.
 */
class parton: public particle_template
{
    public:
        /** @brief Constructor. Sets type name and registers leaves for decay products and indices. */
        parton();
        /** @brief Virtual destructor. */
        virtual ~parton();

        /** @brief Index of the parent truth top quark. */
        int top_index      = -1;
        /** @brief Index of the matched reconstructed jet (-1 if none). */
        int jet_index      = -1;
        /** @brief Index of the matched truth jet (-1 if none). */
        int truthjet_index = -1;
        /** @brief Index of the matched reconstructed muon (-1 if none). */
        int muon_index     = -1;
        /** @brief Index of the matched reconstructed electron (-1 if none). */
        int electron_index = -1;

        /** @brief Map of associated reconstructed jets (pointers). Populated by `CompileEvent`. */
        std::map<std::string, jet*> jets;
        /** @brief Map of associated truth jets (pointers). Populated by `CompileEvent`. */
        std::map<std::string, truthjet*> truthjets;

        /** @brief Clones the parton object. */
        particle_template* clone() override;
        /** @brief Static build method to create parton(s) from event data (W decays, b's). */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);
};

/**
 * @brief Represents a generic lepton particle (potentially truth or a combined collection).
 * @details Inherits from `particle_template`. Stores basic kinematics, charge,
 *          and an ambiguity flag (e.g., related to overlap removal or type definition).
 */
class lepton: public particle_template
{
    public:
        /** @brief Constructor. Sets type name and registers leaves. */
        lepton();
        /** @brief Virtual destructor. */
        virtual ~lepton();

        /** @brief Ambiguity flag (e.g., DFCommonAddAmbiguity). Default 99 indicates unset/invalid. */
        int ambiguity = 99;

        /** @brief Clones the lepton object. */
        particle_template* clone() override;
        /** @brief Static build method to create generic lepton(s) from event data. */
        static void build(std::map<std::string, particle_template*>* prt, element_t* el);
};

#endif // PARTICLES_SSML_MC20_H


// --- Cython Files (Brief Comments) ---

// File: event_ssml_mc20.pxd
/**
 * @brief Cython definition file (.pxd) for the ssml_mc20 C++ event class.
 * @details Declares the C++ `ssml_mc20` class structure to Cython, allowing
 *          Python code to interact with it efficiently. It specifies inheritance
 *          from the base `event_template`.
 */
/*
# distutils: language=c++
# cython: language_level=3

from libcpp cimport bool
from libcpp.map cimport map
from libcpp.string cimport string
from libcpp.vector cimport vector

from AnalysisG.core.particle_template cimport particle_template
from AnalysisG.core.event_template cimport *

cdef extern from "<ssml_mc20/event.h>":

    cdef cppclass ssml_mc20(event_template):
        ssml_mc20() except+ # Declare constructor, handle C++ exceptions

# Define the Python wrapper class inheriting from the base EventTemplate Python class
cdef class SSML_MC20(EventTemplate):
    cdef ssml_mc20* ev # Pointer to the underlying C++ object
*/


// File: event_ssml_mc20.pyx
/**
 * @brief Cython implementation file (.pyx) for the SSML_MC20 Python wrapper class.
 * @details Implements the Python class `SSML_MC20` which wraps the C++ `ssml_mc20`
 *          object. Handles object creation (`__cinit__`) and destruction (`__dealloc__`),
 *          linking the Python object's lifetime to the C++ object's lifetime.
 */
/*
# distutils: language=c++
# cython: language_level=3

from AnalysisG.events.ssml_mc20.event_ssml_mc20 cimport * # Import the .pxd definitions
from AnalysisG.core.event_template cimport EventTemplate # Import the base Python class

cdef class SSML_MC20(EventTemplate):

    def __cinit__(self):
        # Allocate the C++ object when the Python object is created
        self.ev = new ssml_mc20()
        # Store the base class pointer for potential use by base class methods
        self.ptr = <event_template*>self.ev

    def __init__(self):
        # Standard Python initializer (can be empty if __cinit__ does all setup)
        pass

    def __dealloc__(self):
        # Deallocate the C++ object when the Python object is garbage collected
        del self.ptr # Deleting the pointer calls the C++ destructor
*/

// File: particle_ssml_mc20.pxd
/**
 * @brief Cython definition file (.pxd) for specific ssml_mc20 C++ particle classes (example: electron).
 * @details Declares C++ particle class structures (like `electron`) derived from
 *          `particle_template` to Cython. This allows specific particle types
 *          to be potentially wrapped or accessed from Python if needed, beyond
 *          the generic `particle_template` interface.
 */
/*
# distutils: language=c++
# cython: language_level=3

from libcpp cimport bool
from libcpp.map cimport map
from libcpp.string cimport string
from libcpp.vector cimport vector
from AnalysisG.core.particle_template cimport * # Import base particle template definition

cdef extern from "<ssml_mc20/particles.h>":

    # Example: Declare the electron class inheriting from particle_template
    cdef cppclass electron(particle_template):
        electron() except+
        # Declare any specific members or methods of electron if needed in Cython
*/

// File: particle_ssml_mc20.pyx
/**
 * @brief Cython implementation file (.pyx) for ssml_mc20 particle Python wrappers (if any).
 * @details Provides the Python implementation for wrapper classes around specific
 *          C++ particles defined in `particles.h` and declared in the corresponding
 *          `.pxd` file. Often, direct wrapping of every particle type isn't necessary
 *          if interaction primarily happens through the base `ParticleTemplate` wrapper.
 *          (This file seems incomplete in the original snippet).
 */
/*
# distutils: language=c++
# cython: language_level=3

from AnalysisG.events.ssml_mc20.particle_ssml_mc20 cimport * # Import particle .pxd definitions
from AnalysisG.core.particle_template cimport ParticleTemplate # Import base Python wrapper

# Example: Define a Python wrapper for the electron class if needed
# cdef class Electron(ParticleTemplate):
#     # Implementation to wrap the C++ electron object
#     pass
*/

