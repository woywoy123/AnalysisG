/** @file topefficiency.dox
 *  @brief Implementation file for the topefficiency class.
 *
 *  This file contains the implementation of the methods declared in topefficiency.h.
 *  It defines the logic for calculating top quark reconstruction efficiency,
 *  handling event data, merging results, and defining kinematic regions.
 */

#include "topefficiency.h"

/**
 * @brief Default constructor for the topefficiency class.
 * Initializes the selection name.
 */
topefficiency::topefficiency();

/**
 * @brief Destructor for the topefficiency class.
 */
topefficiency::~topefficiency();

/**
 * @brief Creates a clone of the current topefficiency object.
 * @return A pointer to a new topefficiency object (casted to selection_template*).
 * @details This method is used for polymorphism, allowing the creation of copies
 *          of derived selection objects through a base class pointer.
 */
selection_template* topefficiency::clone();

/**
 * @brief Merges data from another topefficiency object into this one.
 * @param sl A pointer to the selection_template object to merge from. It is expected
 *           to be dynamically castable to a topefficiency object.
 * @details This method combines the statistics and collected data (like mass distributions,
 *          probabilities, counts, ROC curve variables) from the passed object (`sl`)
 *          into the current object (`this`). It uses helper functions `merge_data` and
 *          `sum_data` (presumably defined elsewhere) to perform the merging for different
 *          data structures.
 */
void topefficiency::merge(selection_template* sl);

/**
 * @brief Basic event selection criteria.
 * @param ev Pointer to the event data (event_template).
 * @return Always returns true in this implementation, indicating all events pass this initial selection.
 * @details This function can be overridden or modified to implement specific event-level cuts
 *          before the main strategy logic is applied. Currently, it acts as a pass-through.
 */
bool topefficiency::selection(event_template* ev);

/**
 * @brief Calculates the number of iterations (bins) within a given range and step size.
 * @param start The starting value of the range.
 * @param end The ending value of the range.
 * @param step The size of each step or bin.
 * @return The integer number of steps that fit within the range.
 */
int topefficiency::iters(double start, double end, double step);

/**
 * @brief Determines the kinematic region string based on particle pT and eta.
 * @param pt_p The transverse momentum (pT) of the particle (presumably in GeV).
 * @param eta_p The pseudorapidity (eta) of the particle.
 * @return A string describing the kinematic bin (e.g., "100 < $pt_{top}$ < 200, 0.5 < |$\\eta_{top}$| < 1.0").
 * @details This function uses the configured pt and eta ranges (`pt_start`, `pt_end`, `pt_step`,
 *          `eta_start`, `eta_end`, `eta_step`) to find the appropriate bin for the given
 *          particle kinematics and formats it into a human-readable string key.
 */
std::string topefficiency::region(double pt_p, double eta_p);

/**
 * @brief Generates a string representing the decay mode based on the number of leptonic tops.
 * @param ev_tops A vector of pointers to top objects in the event.
 * @return A string representing the combined decay mode (e.g., "hh", "hl", "ll"). 'h' denotes hadronic, 'l' denotes leptonic.
 * @details It iterates through the provided top quarks, counts the number of hadronic ('h') and leptonic ('l') decays
 *          (based on the `n_leps` member of the `top` object), and concatenates the characters into a summary string.
 */
std::string topefficiency::decaymode(std::vector<top*> ev_tops);

/**
 * @brief The main analysis strategy logic for processing a single event.
 * @param ev Pointer to the event data, expected to be a `gnn_event` object.
 * @return Always returns true, indicating successful processing.
 * @details This function performs the core tasks:
 *          1. Extracts truth-level information (tops, Z') and populates truth histograms/maps (`t_topmass`, `t_zmass`, `t_decay_region`, `t_nodes`, `n_tru_tops`).
 *          2. Extracts reconstructed-level information (tops, Z') and populates corresponding histograms/maps (`p_topmass`, `p_zmass`, `p_decay_region`, `p_nodes`, `prob_tops`, `prob_zprime`).
 *          3. Calculates reconstruction efficiency by comparing reconstructed tops (above varying score thresholds) to truth tops (`n_perfect_tops`, `n_pred_tops`).
 *          4. Collects truth labels and predicted scores for various graph-level tasks (edge classification, signal classification, N-top classification) used for ROC curve generation.
 */
bool topefficiency::strategy(event_template* ev);


/** @file topefficiency.h
 *  @brief Header file for the topefficiency class.
 *
 *  This file declares the topefficiency class, which inherits from selection_template.
 *  It is designed to calculate and store metrics related to top quark reconstruction
 *  efficiency, likely using inputs from Graph Neural Network (GNN) inference.
 *  It defines data members for storing kinematic distributions, probabilities, counts,
 *  and variables needed for ROC curve analysis, categorized by kinematic regions
 *  and decay modes.
 */
#ifndef TOPEFFICIENCY_H
#define TOPEFFICIENCY_H

#include <templates/selection_template.h> // Base class definition
#include <inference/gnn-event.h>         // Event data structure with GNN info

/**
 * @class topefficiency
 * @brief A selection class to analyze top quark reconstruction efficiency.
 *
 * Inherits from `selection_template` and implements methods to process
 * events (specifically `gnn_event`), extract truth and reconstructed top/Z'
 * information, categorize them into kinematic regions and decay modes,
 * and calculate efficiency metrics based on GNN scores. It also stores
 * data needed for plotting distributions and ROC curves.
 */
class topefficiency: public selection_template
{
    public:
        /**
         * @brief Constructor.
         * @see topefficiency::topefficiency()
         */
        topefficiency();

        /**
         * @brief Destructor.
         * @see topefficiency::~topefficiency()
         */
        ~topefficiency();

        /**
         * @brief Clones the object.
         * @return A pointer to the new object.
         * @see topefficiency::clone()
         */
        selection_template* clone() override;

        /**
         * @brief Applies event selection (currently passes all events).
         * @param ev Event pointer.
         * @return True if the event passes selection.
         * @see topefficiency::selection(event_template* ev)
         */
        bool selection(event_template* ev) override;

        /**
         * @brief Executes the main analysis strategy for an event.
         * @param ev Event pointer (expects gnn_event).
         * @return True upon successful processing.
         * @see topefficiency::strategy(event_template* ev)
         */
        bool strategy(event_template* ev) override;

        /**
         * @brief Merges data from another instance.
         * @param sl Pointer to the object to merge from.
         * @see topefficiency::merge(selection_template* sl)
         */
        void merge(selection_template* sl) override;

        // --- Configuration for Kinematic Binning ---

        /** @brief Starting transverse momentum (pT) value for binning (GeV). */
        double pt_start;
        /** @brief Starting pseudorapidity (eta) value for binning. */
        double eta_start;

        /** @brief Ending transverse momentum (pT) value for binning (GeV). */
        double pt_end;
        /** @brief Ending pseudorapidity (eta) value for binning. */
        double eta_end;

        /** @brief Step size for eta bins. */
        double eta_step;
        /** @brief Step size for pT bins (GeV). */
        double pt_step;
        /** @brief Step size for iterating through GNN score thresholds. */
        double score_step;

        // --- Helper Methods ---

        /**
         * @brief Calculates the number of bins/iterations.
         * @param start Range start.
         * @param end Range end.
         * @param step Step size.
         * @return Number of iterations.
         * @see topefficiency::iters(double start, double end, double step)
         */
        int iters(double start, double end, double step);

        /**
         * @brief Generates a string key for the kinematic region.
         * @param pt Particle pT.
         * @param eta Particle eta.
         * @return Region string key.
         * @see topefficiency::region(double pt_p, double eta_p)
         */
        std::string region(double pt, double eta);

        /**
         * @brief Generates a string key for the event's top decay mode.
         * @param ev_tops Vector of top objects.
         * @return Decay mode string (e.g., "hh", "hl", "ll").
         * @see topefficiency::decaymode(std::vector<top*> ev_tops)
         */
        std::string decaymode(std::vector<top*> ev_tops);

        // --- Data Storage ---
        // Structure: map<RegionKey, map<EventHash, vector<Value>>>
        // Structure: map<DecayModeKey, map<EventHash, vector<Value>>>
        // Structure: map<EventHash, map<ScoreThreshold, Value>>
        // Structure: map<EventHash, Value>

        /** @brief Reconstructed top mass distributions per region and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> p_topmass;
        /** @brief Truth top mass distributions per region and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> t_topmass;

        /** @brief Reconstructed Z' mass distributions per region and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> p_zmass;
        /** @brief Truth Z' mass distributions per region and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> t_zmass;

        /** @brief Reconstructed top average GNN score distributions per region and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> prob_tops;
        /** @brief Reconstructed Z' average GNN score distributions per region and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> prob_zprime;

        /** @brief Truth top mass distributions per decay mode and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> t_decay_region;
        /** @brief Reconstructed top mass distributions per decay mode and event. */
        std::map<std::string, std::map<std::string, std::vector<float>>> p_decay_region;

        /** @brief Number of nodes associated with reconstructed tops, indexed by event hash and top mass. */
        std::map<std::string, std::map<float, int>> p_nodes;
        /** @brief Number of nodes associated with truth tops, indexed by event hash and top mass. */
        std::map<std::string, std::map<float, int>> t_nodes;

        /** @brief Number of truth tops per event. */
        std::map<std::string, int> n_tru_tops;
        /** @brief Number of reconstructed tops passing a score threshold, per event. */
        std::map<std::string, std::map<float, int>> n_pred_tops;
        /** @brief Number of correctly reconstructed (truth-matched) tops passing a score threshold, per event. */
        std::map<std::string, std::map<float, int>> n_perfect_tops;

        // --- ROC Curve Variables ---
        // These store aggregated truth labels and predicted scores across all processed events.

        /** @brief Truth labels for resonance decay edges (e.g., Z'->tt). */
        std::vector<int> truth_res_edge;
        /** @brief Truth labels for top decay edges (e.g., t->Wb). */
        std::vector<int> truth_top_edge;

        /** @brief Truth labels for the number of tops in the event (classification task). */
        std::vector<int> truth_ntops;
        /** @brief Truth labels for signal vs background event classification. */
        std::vector<int> truth_signal;

        /** @brief Predicted scores for resonance decay edges. */
        std::vector<std::vector<float>> pred_res_edge_score;
        /** @brief Predicted scores for top decay edges. */
        std::vector<std::vector<float>> pred_top_edge_score;

        /** @brief Predicted scores for the N-tops classification task. */
        std::vector<std::vector<float>> pred_ntops_score;
        /** @brief Predicted scores for the signal vs background classification task. */
        std::vector<std::vector<float>> pred_signal_score;
};

#endif // TOPEFFICIENCY_H

// --- Cython Bindings Section ---
// The following code provides Python bindings for the C++ topefficiency class
// using Cython. It allows the C++ class and its data members to be accessed
// and manipulated from Python.

# distuils: language=c++
# cython: language_level=3

from libcpp.map cimport map
from libcpp.vector cimport vector
from libcpp.string cimport string
from AnalysisG.core.selection_template cimport *

cdef extern from "topefficiency.h":
    cdef cppclass topefficiency(selection_template):
        topefficiency() except +

        map[string, map[string, vector[float]]] p_topmass
        map[string, map[string, vector[float]]] t_topmass

        map[string, map[string, vector[float]]] p_zmass
        map[string, map[string, vector[float]]] t_zmass

        map[string, map[string, vector[float]]] prob_tops
        map[string, map[string, vector[float]]] prob_zprime

        map[string, map[string, vector[float]]] t_decay_region
        map[string, map[string, vector[float]]] p_decay_region

        map[string, map[float, int]] t_nodes
        map[string, map[float, int]] p_nodes

        map[string, int] n_tru_tops
        map[string, map[float, int]] n_pred_tops
        map[string, map[float, int]] n_perfect_tops

        vector[int] truth_res_edge
        vector[int] truth_top_edge

        vector[int] truth_ntops
        vector[int] truth_signal

        vector[vector[float]] pred_res_edge_score
        vector[vector[float]] pred_top_edge_score

        vector[vector[float]] pred_ntops_score
        vector[vector[float]] pred_signal_score


cdef class TopEfficiency(SelectionTemplate):
    cdef topefficiency* tt

    cdef public dict p_topmass
    cdef public dict t_topmass

    cdef public dict p_zmass
    cdef public dict t_zmass

    cdef public dict prob_tops
    cdef public dict prob_zprime

    cdef public dict t_decay_region
    cdef public dict p_decay_region

    cdef public dict t_nodes
    cdef public dict p_nodes

    cdef public dict n_tru_tops
    cdef public dict n_pred_tops
    cdef public dict n_perfect_tops

    cdef public list truth_res_edge
    cdef public list truth_top_edge

    cdef public list truth_ntops
    cdef public list truth_signal

    cdef public list pred_res_edge_score
    cdef public list pred_top_edge_score

    cdef public list pred_ntops_score
    cdef public list pred_signal_score




# distutils: language=c++
# cython: language_level=3

from AnalysisG.selections.performance.topefficiency.topefficiency cimport *
from AnalysisG.core.selection_template cimport *
from AnalysisG.core.tools cimport *

cdef class TopEfficiency(SelectionTemplate):
    def __cinit__(self):
        self.ptr = new topefficiency()
        self.tt = <topefficiency*>self.ptr

    def __dealloc__(self): del self.tt

    cdef void transform_dict_keys(self):

        self.p_topmass   = as_dict_dict(&self.tt.p_topmass)
        self.t_topmass   = as_dict_dict(&self.tt.t_topmass)

        self.p_zmass     = as_dict_dict(&self.tt.p_zmass)
        self.t_zmass     = as_dict_dict(&self.tt.t_zmass)

        self.prob_tops   = as_dict_dict(&self.tt.prob_tops)
        self.prob_zprime = as_dict_dict(&self.tt.prob_zprime)

        self.t_decay_region = as_dict_dict(&self.tt.t_decay_region)
        self.p_decay_region = as_dict_dict(&self.tt.p_decay_region)

        self.n_tru_tops      = as_basic_dict(&self.tt.n_tru_tops)
        self.n_pred_tops     = as_basic_dict_dict_f(&self.tt.n_pred_tops)
        self.n_perfect_tops  = as_basic_dict_dict_f(&self.tt.n_perfect_tops)

        self.t_nodes  = as_basic_dict_dict_f(&self.tt.t_nodes)
        self.p_nodes  = as_basic_dict_dict_f(&self.tt.p_nodes)

        self.truth_res_edge   = self.tt.truth_res_edge
        self.truth_top_edge   = self.tt.truth_top_edge

        self.truth_ntops      = self.tt.truth_ntops
        self.truth_signal     = self.tt.truth_signal

        self.pred_res_edge_score = self.tt.pred_res_edge_score
        self.pred_top_edge_score = self.tt.pred_top_edge_score

        self.pred_ntops_score    = self.tt.pred_ntops_score
        self.pred_signal_score   = self.tt.pred_signal_score

