/**
 * @file met.h
 * @brief Defines the met class for event selection based on Missing Transverse Energy (MET).
 *
 * This header file declares the `met` class, which inherits from `selection_template`.
 * It is designed to implement event selection strategies specifically focused on
 * the Missing Transverse Energy (MET) calculated in particle physics events.
 * It includes methods for applying selection criteria, defining the MET strategy,
 * cloning the object, merging results, and storing MET-related data.
 */

#ifndef MC16_MET_H
#define MC16_MET_H

#include <bsm_4tops/event.h> // Include necessary header for event data structure (assuming bsm_4tops::event)
#include <templates/selection_template.h> // Include the base class header

#include <map> // Include map for storing MET data
#include <string> // Include string for map keys

/**
 * @brief Implements a specific event selection strategy based on Missing Transverse Energy (MET).
 *
 * @details This class inherits from the `selection_template` base class and provides concrete
 *          implementations for the virtual methods defined therein. The primary focus of this
 *          class is to select events based on criteria related to the Missing Transverse Energy (MET).
 *          It encapsulates the logic for MET calculation or retrieval, the application of selection cuts
 *          based on MET, and the storage of relevant MET information. It is designed to be used
 *          within a larger analysis framework that utilizes the `selection_template` interface.
 *          The class also supports cloning for polymorphic use and merging for combining results,
 *          often necessary in parallel processing environments.
 */
class met: public selection_template
{
    public:
        /**
         * @brief Default constructor for the met class.
         *
         * @details Initializes a new instance of the `met` selection object.
         *          Sets the name of the selection to "met" using the base class `name` member.
         *          May perform other default initializations required for the MET selection logic,
         *          such as setting default cut values or initializing internal data structures.
         */
        met();

        /**
         * @brief Destructor for the met class.
         *
         * @details Cleans up any resources allocated specifically by the `met` object.
         *          Since this class primarily manages standard library containers and basic types
         *          in this example, the default destructor behavior is often sufficient. However,
         *          it overrides the virtual destructor from the base class `selection_template`
         *          to ensure proper cleanup in polymorphic scenarios (e.g., deleting a `met` object
         *          through a `selection_template*` pointer).
         */
        ~met() override;

        /**
         * @brief Creates a deep copy (clone) of the current `met` object.
         *
         * @details Implements the virtual `clone` method inherited from `selection_template`.
         *          This method facilitates the virtual constructor idiom, allowing for the creation
         *          of copies of derived class objects (`met` in this case) through a base class pointer.
         *          It allocates a new `met` object on the heap and returns a pointer to it,
         *          casted to the base class type `selection_template*`. The caller assumes
         *          ownership of the returned pointer and is responsible for its deletion.
         *
         * @return selection_template* A pointer to the newly created `met` object, cast to the base class pointer.
         */
        selection_template* clone() override;

        /**
         * @brief Applies the core MET selection criteria to a given event.
         *
         * @details This method evaluates whether the provided event (`ev`) passes the specific
         *          MET selection cuts defined by this class. The actual logic for determining
         *          pass/fail might depend on values calculated or retrieved in the `strategy` method
         *          or on pre-configured cut values within the `met` object. In this specific
         *          implementation, it currently returns `true` unconditionally, implying that
         *          either the selection logic is handled elsewhere (perhaps in the `strategy` or
         *          a subsequent analysis step) or this is a placeholder implementation.
         *
         * @param ev A pointer to an `event_template` object, which is expected to be dynamically
         *           castable to the specific event type (`bsm_4tops` in this context) that contains
         *           the necessary MET information.
         * @return bool Returns `true` if the event satisfies the MET selection criteria, `false` otherwise.
         *              (Currently always returns true).
         */
        bool selection(event_template* ev) override;

        /**
         * @brief Implements the specific MET strategy, such as calculation or data extraction.
         *
         * @details This method defines the procedure for obtaining or processing the MET information
         *          for the given event (`ev`). It first casts the generic `event_template` pointer
         *          to the specific event type `bsm_4tops` to access its members. It then retrieves
         *          the MET value (`evn->met`) from the event. This value is subsequently stored
         *          in two places:
         *          1. It's written to an output data structure (likely a ROOT TTree or similar)
         *             associated with the key "missing_et" using the base class `write` method.
         *          2. It's stored in the `missing_et` map member of this `met` object, using the
         *             event's hash (`evn->hash`) as the key. This allows for event-specific MET
         *             values to be potentially accessed later, although the current map uses
         *             `std::string` keys, suggesting the hash might need conversion or a different
         *             map structure might be intended if per-event storage is the goal. The current
         *             implementation seems to store the last processed event's MET under its hash key.
         *          The method returns `true`, indicating successful execution of the strategy.
         *
         * @param ev A pointer to an `event_template` object, expected to be of type `bsm_4tops`.
         * @return bool Returns `true` if the strategy was applied successfully, `false` otherwise.
         *              (Currently always returns true).
         */
        bool strategy(event_template* ev) override;

        /**
         * @brief Merges the state or results from another `met` object into this one.
         *
         * @details This method combines data accumulated in another `selection_template` object (`sl`)
         *          into the current `met` object. It assumes that the input object `sl` is also
         *          a `met` instance. It performs a dynamic cast to `met*` to access the specific
         *          members of the `met` class. The core merging logic is delegated to the
         *          `merge_data` function (presumably defined in the base class or a utility header),
         *          which takes the `missing_et` maps from both the current object (`this`) and the
         *          source object (`slt`) as arguments. This is typically used in parallel processing
         *          scenarios to aggregate statistics or histograms collected across different processing units
         *          or data chunks. The exact behavior of `merge_data` determines how the maps are combined
         *          (e.g., summing values for common keys, adding new keys).
         *
         * @param sl A pointer to another `selection_template` object, which must be dynamically
         *           castable to `met`, whose data should be merged into this object.
         */
        void merge(selection_template* sl) override;

        /**
         * @brief A map to store Missing Transverse Energy (MET) related values, keyed by string identifiers.
         *
         * @details This public member variable is a standard C++ map where keys are strings
         *          and values are floats. It is intended to store various components or results
         *          related to the Missing Transverse Energy calculation or selection for the
         *          events processed by this `met` object. The string keys could represent different
         *          aspects like "MET_pt", "MET_phi", "MET_significance", or potentially event identifiers
         *          as seen in the `strategy` method (though using `evn->hash` directly as a string key
         *          might require conversion or a different map type like `std::map<uint64_t, float>`).
         *          The `merge` method utilizes this map to combine results from different instances.
         *          In the Cython wrapper, this map's content is exposed to Python as a dictionary.
         */
        std::map<std::string, float> missing_et;
};

#endif // MC16_MET_H

// --- Start of Cython Definitions ---

// distutils: language=c++
// cython: language_level=3

// Import necessary C++ types from libcpp for Cython bindings
// from libcpp.map cimport map
// from libcpp.vector cimport vector
// from libcpp.string cimport string
// Import the base Cython class definition
// from AnalysisG.core.selection_template cimport *

// Declare the C++ met class to Cython
// cdef extern from "met.h":
    // cdef cppclass met(selection_template):
        /**
         * @brief Cython declaration of the C++ met constructor.
         * @details Maps the C++ constructor `met::met()` allowing it to be called from Cython.
         *          The `except +` specification enables C++ exception handling to be translated
         *          into Python exceptions.
         */
        // met() except +

        /**
         * @brief Cython declaration of the C++ `missing_et` member.
         * @details Exposes the public `std::map<std::string, float> missing_et` member
         *          of the C++ `met` class to Cython code. This allows direct access
         *          to the map from within Cython functions (`cdef`/`cpdef`).
         */
        // map[string, float] missing_et

/**
 * @brief Cython wrapper class for the C++ `met` selection class.
 *
 * @details This class provides a Python interface to the underlying C++ `met` object.
 *          It inherits from `SelectionTemplate`, the Cython wrapper for the C++ `selection_template` base class.
 *          It manages the lifecycle of a C++ `met` object (`tt` pointer) and provides
 *          Python-friendly access to its data, specifically converting the C++ `missing_et` map
 *          into a Python dictionary (`missing_et`).
 */
// cdef class MET(SelectionTemplate):
    /**
     * @brief Pointer to the underlying C++ `met` object.
     * @details This C++ pointer (`met*`) holds the memory address of the actual C++ `met`
     *          instance managed by this Cython wrapper object. It is used internally by
     *          Cython methods to call the C++ class's methods and access its members.
     *          It is initialized in `__cinit__` and should not be directly manipulated
     *          from Python code. It is typed specifically as `met*` for direct access
     *          to `met` specific members, while the `ptr` member in the base class
     *          `SelectionTemplate` holds the `selection_template*`.
     */
    // cdef met* tt

    /**
     * @brief Python dictionary representation of the C++ `missing_et` map.
     * @details This public attribute holds a Python dictionary that mirrors the contents
     *          of the C++ `met::missing_et` map. The `transform_dict_keys` method is
     *          responsible for populating this dictionary based on the C++ map's data.
     *          This allows Python users to easily access the MET results stored by the
     *          C++ object.
     */
    // cdef public dict missing_et


    // --- Start of Cython Implementation (.pyx) ---

    // distutils: language=c++
    // cython: language_level=3

    // Import necessary Cython utility functions and the base class
    // from AnalysisG.core.tools cimport *
    // from AnalysisG.core.selection_template cimport *

    // Re-declare the class for implementation
    // cdef class MET(SelectionTemplate):
        /**
         * @brief Cython constructor (initialization phase).
         *
         * @details This special Cython method is called when a `MET` object is created.
         *          It is responsible for allocating and initializing the underlying C++ `met` object.
         *          1. It creates a new C++ `met` object on the heap using `new met()`.
         *          2. It assigns the pointer to this new object to the `ptr` member (inherited
         *             from `SelectionTemplate`, holding the `selection_template*`).
         *          3. It casts the `ptr` to the derived type `met*` and assigns it to the `tt`
         *             member for direct access to `met`-specific features within Cython.
         *          This ensures that every Python `MET` instance safely manages a corresponding C++ `met` instance.
         */
        // def __cinit__(self):
            // Implementation details:
            // Allocate C++ object: self.ptr = new met()
            // Store typed pointer: self.tt = <met*>self.ptr

        /**
         * @brief Cython destructor (deallocation phase).
         *
         * @details This special Cython method is called when a `MET` object is about to be
         *          destroyed and its memory deallocated (e.g., when it goes out of scope or
         *          its reference count drops to zero).
         *          Its primary responsibility here is to release the memory allocated for the
         *          C++ `met` object pointed to by `tt` (and `ptr`). It uses `del self.tt`
         *          which translates to `delete this->tt;` in C++, preventing memory leaks.
         *          Note: It deletes `tt`, which points to the same object as `ptr`. Deleting
         *          it via either pointer is sufficient.
         */
        // def __dealloc__(self):
            // Implementation details:
            // Deallocate C++ object: del self.tt

        /**
         * @brief Converts the C++ `missing_et` map to the Python `missing_et` dictionary.
         *
         * @details This internal Cython method (`cdef`) is responsible for synchronizing the
         *          Python-accessible `missing_et` dictionary with the data stored in the
         *          C++ `met::missing_et` map. It calls a utility function `as_basic_dict`
         *          (presumably defined in `AnalysisG.core.tools`), passing the address of
         *          the C++ map (`&self.tt.missing_et`). This function likely iterates through
         *          the C++ map and creates a corresponding Python dictionary, which is then
         *          assigned to the `self.missing_et` attribute. This method needs to be called
         *          at appropriate times (e.g., after processing or merging) to ensure the
         *          Python dictionary reflects the current state of the C++ map.
         */
        // cdef void transform_dict_keys(self):
            // Implementation details:
            // Call conversion utility: self.missing_et = as_basic_dict(&self.tt.missing_et)
