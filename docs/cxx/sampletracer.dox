/**
 * @file sampletracer.h
 * @brief This file defines the `sampletracer` class, which is a tool for tracing and analyzing data samples.
 *
 * The `sampletracer` class inherits from `tools` and `notification` classes, providing functionalities
 * for data processing, analysis, and event notification. It manages a collection of containers, each
 * associated with a specific file, and provides methods for adding, retrieving, and processing
 * meta-data, events, graphs, and selections. The class also includes methods for compiling objects,
 * populating a data loader, and filling selections.
 */

#ifndef SAMPLETRACER_GENERATOR_H
#define SAMPLETRACER_GENERATOR_H

#include <thread>
#include <container/container.h>
#include <notification/notification.h>

/**
 * @class sampletracer
 * @brief A class for tracing and analyzing data samples.
 *
 * The `sampletracer` class provides functionalities for managing and processing data samples,
 * including meta-data, events, graphs, and selections. It inherits from `tools` and
 * `notification` classes, providing additional functionalities for data processing, analysis,
 * and event notification.
 */
class sampletracer: 
    public tools, 
    public notification
{
    public:
        /**
         * @brief Default constructor for the `sampletracer` class.
         *
         * Initializes a new `sampletracer` object with default values.
         */
        sampletracer();

        /**
         * @brief Destructor for the `sampletracer` class.
         *
         * Releases any resources held by the `sampletracer` object.
         */
        ~sampletracer();

        /**
         * @brief Adds meta-data to the container associated with the given filename.
         *
         * @param meta_ A pointer to the meta-data object to add.
         * @param filename The filename associated with the container to which the meta-data should be added.
         * @return `true` if the meta-data was successfully added, `false` otherwise (e.g., if the container already exists).
         */
        bool add_meta_data(meta* meta_, std::string filename); 

        /**
         * @brief Retrieves the meta-data associated with the given filename.
         *
         * @param filename The filename associated with the container from which to retrieve the meta-data.
         * @return A pointer to the meta-data object, or `nullptr` if no meta-data is found for the given filename.
         */
        meta* get_meta_data(std::string filename); 

        /**
         * @brief Retrieves a vector of event templates associated with the given label.
         *
         * @param label The label used to identify the events to retrieve.
         * @return A vector of pointers to the event templates associated with the given label.
         */
        std::vector<event_template*> get_events(std::string label); 

        /**
         * @brief Fills the given map with selection templates from all containers.
         *
         * @param inpt A pointer to the map to fill with selection templates. The keys of the map are strings,
         *             and the values are pointers to `selection_template` objects.
         */
        void fill_selections(std::map<std::string, selection_template*>* inpt); 

        /**
         * @brief Adds an event template to the container associated with the event's filename.
         *
         * @param ev A pointer to the event template to add.
         * @param label The label to associate with the event template.
         * @return `true` if the event template was successfully added, `false` otherwise.
         */
        bool add_event(event_template* ev, std::string label); 

        /**
         * @brief Adds a graph template to the container associated with the graph's filename.
         *
         * @param gr A pointer to the graph template to add.
         * @param label The label to associate with the graph template.
         * @return `true` if the graph template was successfully added, `false` otherwise.
         */
        bool add_graph(graph_template* gr, std::string label);

        /**
         * @brief Adds a selection template to the container associated with the selection's filename.
         *
         * @param sel A pointer to the selection template to add.
         * @return `true` if the selection template was successfully added, `false` otherwise.
         */
        bool add_selection(selection_template* sel); 

        /**
         * @brief Populates the given data loader with data from all containers.
         *
         * @param dl A pointer to the data loader to populate.
         */
        void populate_dataloader(dataloader* dl);  

        /**
         * @brief Compiles the objects in all containers using the specified number of threads.
         *
         * @param threads The number of threads to use for compilation.
         */
        void compile_objects(int threads); 

        /**
         * @brief A pointer to the output path for the compiled objects.
         */
        std::string* output_path = nullptr; 
    private:
        /**
         * @brief A map of filenames to containers, storing the data associated with each file.
         */
        std::map<std::string, container> root_container = {}; 
}; 

#endif
#include <generators/sampletracer.h>

/**
 * @brief Default constructor for the `sampletracer` class.
 *
 * Initializes a new `sampletracer` object with default values.
 */
sampletracer::sampletracer(){}

/**
 * @brief Destructor for the `sampletracer` class.
 *
 * Releases any resources held by the `sampletracer` object.
 */
sampletracer::~sampletracer(){}

/**
 * @brief Adds meta-data to the container associated with the given filename.
 *
 * @param meta_ A pointer to the meta-data object to add.
 * @param filename The filename associated with the container to which the meta-data should be added.
 * @return `true` if the meta-data was successfully added, `false` otherwise (e.g., if the container already exists).
 */
bool sampletracer::add_meta_data(meta* meta_, std::string filename){
    if (this -> root_container.count(filename)){return false;}
    this -> root_container[filename].add_meta_data(meta_, filename); 
    return true; 
}

/**
 * @brief Retrieves the meta-data associated with the given filename.
 *
 * @param filename The filename associated with the container from which to retrieve the meta-data.
 * @return A pointer to the meta-data object, or `nullptr` if no meta-data is found for the given filename.
 */
meta* sampletracer::get_meta_data(std::string filename){
    if (!this -> root_container.count(filename)){return nullptr;}
    return this -> root_container[filename].get_meta_data(); 
}

/**
 * @brief Retrieves a vector of event templates associated with the given label.
 *
 * @param label The label used to identify the events to retrieve.
 * @return A vector of pointers to the event templates associated with the given label.
 */
std::vector<event_template*> sampletracer::get_events(std::string label){
    std::vector<event_template*> out = {};
    std::map<std::string, container>::iterator itr = this -> root_container.begin(); 
    for (; itr != this -> root_container.end(); ++itr){itr -> second.get_events(&out, label);}
    return out; 
}

/**
 * @brief Adds an event template to the container associated with the event's filename.
 *
 * @param ev A pointer to the event template to add.
 * @param label The label to associate with the event template.
 * @return `true` if the event template was successfully added, `false` otherwise.
 */
bool sampletracer::add_event(event_template* ev, std::string label){
    return this -> root_container[ev -> filename].add_event_template(ev, label); 
}

/**
 * @brief Adds a graph template to the container associated with the graph's filename.
 *
 * @param gr A pointer to the graph template to add.
 * @param label The label to associate with the graph template.
 * @return `true` if the graph template was successfully added, `false` otherwise.
 */
bool sampletracer::add_graph(graph_template* gr, std::string label){
    return this -> root_container[gr -> filename].add_graph_template(gr, label); 
}

/**
 * @brief Adds a selection template to the container associated with the selection's filename.
 *
 * @param sel A pointer to the selection template to add.
 * @return `true` if the selection template was successfully added, `false` otherwise.
 */
bool sampletracer::add_selection(selection_template* sel){
    return this -> root_container[sel -> filename].add_selection_template(sel); 
}

/**
 * @brief Compiles the objects in all containers using the specified number of threads.
 *
 * This method iterates through the root containers, sets the output path for each container,
 * and then compiles the objects within each container using a thread pool.  It utilizes
 * lambdas for the compilation task and flushing titles.  A progress bar is displayed
 * during the compilation process if the `shush` flag is not set.
 *
 * @param threads The number of threads to use for compilation.
 */
void sampletracer::compile_objects(int threads){
    auto lamb = [](size_t* l, int threadidx, container* data){data -> compile(l, threadidx);}; 
    auto flush = [](std::vector<std::string*>* inpt){
        for (size_t x(0); x < inpt -> size(); ++x){delete (*inpt)[x];}
        inpt -> clear(); 
    }; 

    std::vector<size_t> progres(this -> root_container.size(), 0); 
    std::vector<size_t> handles(this -> root_container.size(), 0); 
    std::vector<std::string*> titles_(this -> root_container.size(), nullptr); 
    std::vector<std::thread*> threads_(this -> root_container.size(), nullptr); 

    std::map<std::string, container>::iterator itr = this -> root_container.begin(); 
    for (size_t x(0); itr != this -> root_container.end(); ++itr, ++x){
        progres[x] = itr -> second.len();
        itr -> second.output_path = this -> output_path; 
        std::vector<std::string> vec = this -> split(itr -> first, "/"); 
        titles_[x] = new std::string(vec[vec.size()-1]); 
    }

    if (!this -> tools::sum(&progres)){
        flush(&titles_); 
        return;
    }

    std::thread* thr = nullptr; 
    if (this -> shush){
        thr = new std::thread(this -> progressbar3, &handles, &progres, nullptr);
        flush(&titles_); 
    }
    else {thr = new std::thread(this -> progressbar3, &handles, &progres, &titles_);}

    int tidx = 0; 
    int index = 0; 
    itr = this -> root_container.begin(); 
    for (; itr != this -> root_container.end(); ++itr, ++index, ++tidx){
        threads_[index] = new std::thread(lamb, &handles[index], index, &itr -> second); 
        while (tidx > threads-1){tidx = this -> running(&threads_, &handles, &progres);}
    }
    this -> monitor(&threads_); 
    thr -> join(); delete thr; thr = nullptr; 
}

/**
 * @brief Populates the given data loader with data from all containers.
 *
 * @param dl A pointer to the data loader to populate.
 */
void sampletracer::populate_dataloader(dataloader* dl){
    std::map<std::string, container>::iterator itr = this -> root_container.begin(); 
    for (; itr != this -> root_container.end(); ++itr){itr -> second.populate_dataloader(dl);}
}

/**
 * @brief Fills the given map with selection templates from all containers.
 *
 * @param inpt A pointer to the map to fill with selection templates. The keys of the map are strings,
 *             and the values are pointers to `selection_template` objects.
 */
void sampletracer::fill_selections(std::map<std::string, selection_template*>* inpt){
    std::map<std::string, container>::iterator itr = this -> root_container.begin(); 
    for (; itr != this -> root_container.end(); ++itr){itr -> second.fill_selections(inpt);}
}

