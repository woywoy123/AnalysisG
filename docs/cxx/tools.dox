/**
 * @file tools.h
 * @brief Defines the tools class, providing static utility functions for various tasks.
 *
 * This header file declares the `tools` class, which encapsulates a collection of
 * static helper functions. These functions cover areas like file system operations,
 * string manipulation, encoding/decoding, and generic algorithms on vectors.
 * All methods are static, so no instance of the `tools` class needs to be created.
 */
#ifndef TOOLS_TOOLS_H
#define TOOLS_TOOLS_H

#include <iostream>
#include <string>
#include <vector>
#include <cstdint>
#include <map>

/**
 * @class tools
 * @brief A collection of static utility functions.
 *
 * Provides helper functions for common tasks such as file I/O, string processing,
 * Base64 encoding/decoding, and generic vector operations like finding min/max,
 * summing, splitting, and selecting elements.
 */
class tools
{
    public:
        /**
         * @brief Default constructor for the tools class.
         * @note As all methods are static, this constructor typically serves no purpose.
         */
        tools();

        /**
         * @brief Destructor for the tools class.
         * @note As all methods are static, this destructor typically serves no purpose.
         */
        ~tools();

        // --- File System Operations (io.cxx) ---

        /**
         * @brief Creates a directory path recursively.
         *
         * Given a full path (which can be a file path or directory path), this function
         * creates all necessary parent directories. If the input path points to a file,
         * the file name part is ignored, and only the directory structure is created.
         * Uses `mkdir` with permissions S_IRWXU for each directory level.
         *
         * @param path The full path (file or directory) for which the directory structure should be created.
         */
        static void create_path(std::string path);

        /**
         * @brief Deletes a file or an empty directory.
         *
         * Checks if the path exists. If it's a directory, `rmdir` is used (fails if not empty).
         * If it's a file, `unlink` is used. If the path doesn't exist, nothing happens.
         *
         * @param path The path to the file or directory to be deleted.
         */
        static void delete_path(std::string path);

        /**
         * @brief Checks if a file or directory exists at the specified path.
         *
         * Uses `stat` to determine if an entry exists at the given path.
         *
         * @param path The path to check.
         * @return `true` if a file or directory exists at the path, `false` otherwise.
         */
        static bool is_file(std::string path);

        /**
         * @brief Renames or moves a file or directory.
         *
         * Wraps `std::filesystem::rename`. Can be used to rename a file/directory
         * within the same directory or move it to a different location.
         *
         * @param start The original path of the file or directory.
         * @param target The new path for the file or directory.
         */
        static void rename(std::string start, std::string target);

        /**
         * @brief Returns the canonical absolute path for a given path.
         *
         * Wraps `std::filesystem::canonical`. Resolves symbolic links and "."/".." components
         * to produce an absolute path. Throws `std::filesystem::filesystem_error` if the
         * path does not exist or resolution fails.
         *
         * @param path The input path (relative or absolute).
         * @return The canonical absolute path as a string.
         */
        static std::string absolute_path(std::string path);

        /**
         * @brief Lists files recursively within a directory, optionally filtering by extension.
         *
         * Traverses the specified directory and its subdirectories. Returns a vector
         * containing the canonical absolute paths of all files found. If an extension
         * is provided (e.g., ".txt"), only files ending with that extension are included.
         * Handles potential exceptions during directory iteration. If the input path ends with '*',
         * the '*' is removed before processing.
         *
         * @param path The starting directory path for the recursive search. Can end with '*'.
         * @param ext Optional file extension filter (e.g., ".log", ".cpp"). If empty, all files are listed.
         * @return A vector of strings, each containing the absolute path to a found file. Returns an empty vector if the path is invalid or inaccessible.
         */
        static std::vector<std::string> ls(std::string path, std::string ext = "");

        // --- String Manipulation (strings.cxx) ---

        /**
         * @brief Converts a double-precision floating-point number to its string representation.
         *
         * Uses a stringstream for the conversion. Default precision is used.
         *
         * @param val The double value to convert.
         * @return The string representation of the double.
         */
        static std::string to_string(double val);

        /**
         * @brief Converts a double-precision floating-point number to its string representation with fixed precision.
         *
         * Uses a stringstream with `std::fixed` and the specified precision for the conversion.
         *
         * @param val The double value to convert.
         * @param prec The number of digits to display after the decimal point. If negative, default precision might be used (behavior depends on stringstream).
         * @return The string representation of the double with the specified precision.
         */
        static std::string to_string(double val, int prec);

        /**
         * @brief Replaces all occurrences of a substring within a string (in-place).
         *
         * Modifies the input string directly by replacing every instance of `repl_str` with `repl_with`.
         *
         * @param in Pointer to the string to be modified.
         * @param repl_str The substring to search for.
         * @param repl_with The string to replace `repl_str` with.
         */
        static void replace(std::string* in, std::string repl_str, std::string repl_with);

        /**
         * @brief Checks if a string contains a specific substring.
         *
         * Uses `std::string::find` to determine if `trg` exists within the string pointed to by `inpt`.
         *
         * @param inpt Pointer to the string to search within.
         * @param trg The substring to search for.
         * @return `true` if `trg` is found within `*inpt`, `false` otherwise.
         */
        static bool has_string(std::string* inpt, std::string trg);

        /**
         * @brief Checks if a string ends with a specific suffix.
         *
         * Compares the end portion of the string pointed to by `inpt` with the `val` string.
         * Returns `false` if the input string is shorter than the suffix.
         *
         * @param inpt Pointer to the string to check.
         * @param val The suffix string to check for.
         * @return `true` if `*inpt` ends with `val`, `false` otherwise.
         */
        static bool ends_with(std::string* inpt, std::string val);

        /**
         * @brief Checks if a vector of strings contains a specific string value.
         *
         * Iterates through the vector and compares each element with the target string.
         *
         * @param data Pointer to the vector of strings to search within.
         * @param trg The string value to search for.
         * @return `true` if `trg` is found in the vector, `false` otherwise.
         */
        static bool has_value(std::vector<std::string>* data, std::string trg);

        /**
         * @brief Splits a string into a vector of substrings based on a delimiter.
         *
         * Breaks the input string `in` into pieces wherever the `delim` string occurs.
         * The delimiters themselves are not included in the output vector.
         * The part of the string after the last delimiter is included as the final element.
         *
         * @param in The string to be split.
         * @param delim The delimiter string used for splitting.
         * @return A vector of strings resulting from the split.
         */
        static std::vector<std::string> split(std::string in, std::string delim);

        /**
         * @brief Splits a string into a vector of substrings of a fixed maximum size.
         *
         * Divides the input string `in` into chunks, where each chunk has a maximum length of `n`.
         * The last chunk may be shorter if the total string length is not a multiple of `n`.
         *
         * @param in The string to be split.
         * @param n The maximum size of each chunk.
         * @return A vector of strings, each representing a chunk of the original string.
         */
        static std::vector<std::string> split(std::string in, size_t n);

        /**
         * @brief Generates a hexadecimal hash string from an input string.
         *
         * Uses `std::hash<std::string>` to compute a hash value, then converts it
         * to a hexadecimal string prefixed with "0x". The resulting string is padded
         * with trailing zeros or truncated (from the end, which might not be ideal hash behavior)
         * to match the desired length `len`.
         *
         * @param input The string to hash.
         * @param len The desired length of the output hash string (including the "0x" prefix). Defaults to 18.
         * @return The generated hexadecimal hash string.
         */
        static std::string hash(std::string input, int len = 18);

        /**
         * @brief Converts a string to its lowercase equivalent.
         *
         * Creates a new string and fills it with the lowercase versions of the characters
         * from the input string.
         *
         * @param in Pointer to the string to convert.
         * @return A new string containing the lowercase version of `*in`.
         */
        static std::string lower(std::string*);

        // --- Encoding/Decoding (base64.cxx) ---

        /**
         * @brief Encodes a string into Base64 format.
         *
         * Takes a string, treats its content as raw bytes, and encodes them using Base64.
         *
         * @param data Pointer to the string to be encoded.
         * @return The Base64 encoded string.
         */
        static std::string encode64(std::string* data);

        /**
         * @brief Encodes a sequence of raw bytes into Base64 format.
         *
         * Performs Base64 encoding on the provided byte array.
         *
         * @param bytes_to_encode Pointer to the start of the byte sequence.
         * @param len The number of bytes in the sequence.
         * @return The Base64 encoded string.
         */
        static std::string encode64(unsigned char const* bytes_to_encode, unsigned int len);

        /**
         * @brief Decodes a Base64 encoded string.
         *
         * Takes a string containing Base64 data and decodes it back into its original form.
         * Assumes the input string is valid Base64. Ignores invalid characters and padding ('=') position issues.
         *
         * @param inpt Pointer to the Base64 encoded string.
         * @return The decoded string.
         */
        static std::string decode64(std::string* inpt);

        /**
         * @brief Decodes a Base64 encoded string.
         *
         * Takes a string containing Base64 data and decodes it back into its original form.
         * Assumes the input string is valid Base64. Ignores invalid characters and padding ('=') position issues.
         *
         * @param s The Base64 encoded string (passed by const reference).
         * @return The decoded string.
         */
        static std::string decode64(std::string const& s);

        // --- Template Functions ---

        /**
         * @brief Discretizes a vector into sub-vectors (chunks) of a specified size.
         *
         * Splits the input vector `v` into multiple smaller vectors, each containing
         * at most `N` elements. The last sub-vector may contain fewer than `N` elements
         * if the total size of `v` is not divisible by `N`.
         *
         * @tparam G The type of elements stored in the vector.
         * @param v Pointer to the input vector to be discretized.
         * @param N The maximum size of each chunk (sub-vector).
         * @return A vector of vectors, where each inner vector is a chunk of the original.
         */
        template <typename G>
        static std::vector<std::vector<G>> discretize(std::vector<G>* v, int N);

        /**
         * @brief Finds the maximum element in a vector.
         *
         * Iterates through the vector to find the largest element according to the
         * less-than-or-equal-to operator (`<=`) defined for type `g`. Assumes the vector is not empty.
         *
         * @tparam g The type of elements in the vector. Must support comparison (`<=`).
         * @param inpt Pointer to the input vector.
         * @return The maximum value found in the vector.
         */
        template <typename g>
        static g max(std::vector<g>* inpt);

        /**
         * @brief Finds the minimum element in a vector.
         *
         * Iterates through the vector to find the smallest element according to the
         * greater-than-or-equal-to operator (`>=`) defined for type `g`. Assumes the vector is not empty.
         *
         * @tparam g The type of elements in the vector. Must support comparison (`>=`).
         * @param inpt Pointer to the input vector.
         * @return The minimum value found in the vector.
         */
        template <typename g>
        static g min(std::vector<g>* inpt);

        /**
         * @brief Calculates the sum of all elements in a vector.
         *
         * Iterates through the vector and accumulates the sum of its elements.
         * Assumes the type `g` supports the addition assignment operator (`+=`) and
         * can be initialized from `0`.
         *
         * @tparam g The type of elements in the vector. Must support `+=` and initialization from 0.
         * @param inpt Pointer to the input vector.
         * @return The sum of all elements in the vector.
         */
        template <typename g>
        static g sum(std::vector<g>* inpt);

        /**
         * @brief Creates a new vector of pointers by selecting elements from a source vector based on indices.
         *
         * Constructs a new vector of pointers (`std::vector<g*>`). For each index in the `trg` vector,
         * it retrieves the pointer at that index from the `src` vector and adds it to the new vector.
         * The size of the output vector will be the same as the size of the `src` vector, but elements
         * not selected by `trg` indices will be `nullptr`. This seems potentially incorrect, as it initializes
         * the output vector to the size of `src` but only fills based on `trg`. The behavior might be unexpected
         * if `trg` contains indices out of bounds for `src`.
         *
         * @tparam g The underlying type pointed to by the elements in the vectors.
         * @param src Pointer to the source vector of pointers (`std::vector<g*>*`).
         * @param trg Pointer to the vector of integer indices (`std::vector<int>*`).
         * @return A new vector containing pointers selected from `src` based on indices in `trg`, with `nullptr` for unselected positions up to the size of `src`.
         */
        template <typename g>
        static std::vector<g*> put(std::vector<g*>* src, std::vector<int>* trg);

        /**
         * @brief Populates an output vector with pointers selected from a source vector based on indices, marking them as 'in_use'.
         *
         * Clears the `out` vector, reserves space based on the size of `trg`, and then populates `out`.
         * For each index `i` in the `trg` vector, it retrieves the pointer `v` from `(*src)[(*trg)[i]]`,
         * pushes `v` onto the `out` vector, and sets `v->in_use = 1`.
         * Assumes that type `g` has a member variable `in_use` and that indices in `trg` are valid for `src`.
         *
         * @tparam g The underlying type pointed to by the elements in the vectors. Must have an `in_use` member.
         * @param out Pointer to the output vector of pointers (`std::vector<g*>*`) to be populated.
         * @param src Pointer to the source vector of pointers (`std::vector<g*>*`).
         * @param trg Pointer to the vector of integer indices (`std::vector<int>*`).
         */
        template <typename g>
        static void put(std::vector<g*>* out, std::vector<g*>* src, std::vector<int>* trg);

        /**
         * @brief Adds unique elements from one vector (`inx`) to another vector (`oth`).
         *
         * Iterates through the `inx` vector. For each element, it checks if that element
         * already exists in the `oth` vector (using a map for efficient lookup). If the element
         * is not found in `oth`, it is added to `oth`.
         *
         * @tparam g The type of elements in the vectors. Must be usable as a key in `std::map`.
         * @param inx Pointer to the vector containing elements to potentially add.
         * @param oth Pointer to the vector to which unique elements from `inx` will be added.
         */
        template <typename g>
        static void unique_key(std::vector<g>* inx, std::vector<g>* oth);
};


#endif // TOOLS_TOOLS_H
#include <tools/tools.h>
#include <sys/stat.h>
#include <filesystem>
#include <unistd.h>

void tools::create_path(std::string input_path){
    bool f = false;
    if (tools::split(input_path, ".").size() > 1){f = true;}

    std::vector<std::string> cuts = tools::split(input_path, "/"); 
    std::string path = ""; 
    for (unsigned int x(0); x < cuts.size() - f; ++x){
        path += cuts[x] + "/"; 
        mkdir(path.c_str(), S_IRWXU);
    }
}

void tools::rename(std::string start, std::string target){
    std::filesystem::rename(start, target); 
}

void tools::delete_path(std::string input_path){
    struct stat sb;
    if (!stat(input_path.c_str(), &sb)){
        if (S_ISDIR(sb.st_mode)){rmdir(input_path.c_str());}
        else {unlink(input_path.c_str());}
    }
}

bool tools::is_file(std::string path){
    struct stat buffer; 
    return (stat (path.c_str(), &buffer) == 0);
}

std::vector<std::string> tools::ls(std::string path, std::string ext){
    if (tools::ends_with(&path, "*")){path = tools::split(path, "*")[0];}
    std::vector<std::string> out = {}; 
    std::filesystem::recursive_directory_iterator itr; 
    try {itr = std::filesystem::recursive_directory_iterator(path);}
    catch (...) {return {};}
    for (const std::filesystem::directory_entry& val : itr){
        std::string s = std::filesystem::canonical(val.path()).string(); 
        if (ext.size() && !tools::ends_with(&s, ext)){continue;}
        out.push_back(s); 
    }
    return out; 
}

std::string tools::absolute_path(std::string path){
    return std::filesystem::canonical(path).string(); 
}
#include <tools/tools.h>
#include <sstream>
#include <string>

void tools::replace(std::string* in, std::string to_repl, std::string repl_w) {
    std::size_t pos = 0; 
    std::size_t ppos; 
    std::string buf; 

    while (true){
        ppos = pos;
        pos = in -> find(to_repl, pos); 
        if (pos == std::string::npos){break;}
        buf.append(*in, ppos, pos - ppos); 
        buf += repl_w; 
        pos += to_repl.size(); 
    }
    
    buf.append(*in, ppos, in -> size() - ppos); 
    in -> swap(buf); 
}

std::vector<std::string> tools::split(std::string inpt, std::string search) {
    size_t pos = 0;
    size_t s_dim = search.length();
    size_t index = 0;
    std::string token;
    std::vector<std::string> out = {};
    while ((pos = inpt.find(search)) != std::string::npos){
        out.push_back(inpt.substr(0, pos));
        inpt.erase(0, pos + s_dim);
        ++index;
    }
    out.push_back(inpt);
    return out;
}

std::vector<std::string> tools::split(std::string in, size_t n){
    size_t x = 0; 
    std::vector<std::string> out = {""}; 
    for (size_t i(0); i < in.size(); ++i){
        if (out[x].size() >= n){out.push_back(""); ++x;}
        out[x] += in[i]; 
    }
    return out; 
}

std::string tools::hash(std::string input, int len) {
    std::hash<std::string> hasher; 
    std::stringstream ss; 
    ss << "0x" << std::hex << hasher(input); 
    std::string out = ss.str(); 
    int diff = out.size() - len; 
    if (!diff) { return out; }
    out += std::string(std::abs(diff), '0'); 
    return out; 
}

std::string tools::to_string(double val){
    std::stringstream ss; 
    ss << val; 
    return ss.str(); 
}

bool tools::has_string(std::string* inpt, std::string trg){
    std::size_t f = inpt -> find(trg); 
    if (f != std::string::npos){return true;}
    return false; 
}

bool tools::ends_with(std::string* inpt, std::string val){
    if (inpt -> size() < val.size()){return false;}
    std::string l = inpt -> substr(inpt -> size() - val.size(), inpt -> size()-1); 
    return val == l; 
}

bool tools::has_value(std::vector<std::string>* data, std::string trg){
    for (size_t x(0); x < data -> size(); ++x){
        if (trg != data -> at(x)){continue;}
        return true; 
    }
    return false; 
}

std::string tools::lower(std::string* in){
    std::string out = *in;
    for (size_t t(0); t < in -> size(); ++t){out[t] = std::tolower(out[t]);}
    return out;
}

std::string tools::to_string(double val, int prec){
    std::stringstream ss; 
    if (prec > -1){ss.precision(prec);}
    ss << std::fixed << val; 
    return ss.str(); 
}



static const std::string base64_chars = 
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz"
            "0123456789+/";

bool is_base64(unsigned char c){return (isalnum(c) || (c == '+') || (c == '/'));}


std::string tools::encode64(std::string* data){
    return tools::encode64(reinterpret_cast<unsigned char const*>(data -> c_str()), data -> size()); 
}

std::string tools::encode64(unsigned char const* bytes_to_encode, unsigned int in_len){
    std::string ret;
    int i = 0;
    int j = 0;
    unsigned char char_array_3[3];
    unsigned char char_array_4[4];
    
    while (in_len--) {
        char_array_3[i++] = *(bytes_to_encode++);
        if (i == 3){
            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
            char_array_4[3] = char_array_3[2] & 0x3f;

            for (i = 0; (i <4) ; i++){ret += base64_chars[char_array_4[i]];}
            i = 0;
        }
    }

    if (i){
        for(j = i; j < 3; j++){char_array_3[j] = '\0';}
        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
        char_array_4[3] = char_array_3[2] & 0x3f;
        for (j = 0; (j < i + 1); j++){ret += base64_chars[char_array_4[j]];}
        while((i++ < 3)){ret += '=';}
    }
    return ret;
}

 

std::string tools::decode64(std::string* inpt){
    return tools::decode64(*inpt); 
}


std::string tools::decode64(std::string const& encoded_string){
    size_t in_len = encoded_string.size();
    size_t i = 0;
    size_t j = 0;
    int in_ = 0;
    unsigned char char_array_4[4], char_array_3[3];
    std::string ret;

    while (in_len-- && (encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
        char_array_4[i++] = encoded_string[in_]; in_++;
        if (i ==4) {
            for (i = 0; i <4; i++){char_array_4[i] = static_cast<unsigned char>(base64_chars.find(char_array_4[i]));}
            char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

            for (i = 0; (i < 3); i++){ret += char_array_3[i];}
            i = 0;
        }
    }
    
    if (i) {
        for (j = i; j <4; j++){char_array_4[j] = 0;}
        for (j = 0; j <4; j++){char_array_4[j] = static_cast<unsigned char>(base64_chars.find(char_array_4[j]));}
        char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
        char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
        for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
    }
    return ret;
}
#include <tools/tools.h>
tools::tools(){}
tools::~tools(){}

