#ifndef PARTICLETEMPLATE_H
#define PARTICLETEMPLATE_H

#include <structs/particles.h>
#include <structs/property.h>
#include <structs/element.h>
#include <tools/tools.h>

#include <iostream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <cmath>

class event_template; 
class selection_template; 

class particle_template : public tools
{
    public:
        particle_template();
        virtual ~particle_template(); 

        explicit particle_template(particle_t* p);
        explicit particle_template(particle_template* p, bool dump = false); 
        explicit particle_template(double px, double py, double pz, double e); 
        explicit particle_template(double px, double py, double pz);

        void to_cartesian(); 
        void to_polar(); 

        cproperty<double, particle_template> e; 
        void static set_e(double*, particle_template*); 
        void static get_e(double*, particle_template*); 

        cproperty<double, particle_template> mass; 
        void static set_mass(double*, particle_template*); 
        void static get_mass(double*, particle_template*); 

        cproperty<double, particle_template> pt; 
        void static set_pt(double*, particle_template*); 
        void static get_pt(double*, particle_template*); 

        cproperty<double, particle_template> eta; 
        void static set_eta(double*, particle_template*); 
        void static get_eta(double*, particle_template*); 

        cproperty<double, particle_template> phi; 
        void static set_phi(double*, particle_template*); 
        void static get_phi(double*, particle_template*); 


        cproperty<double, particle_template> px; 
        void static set_px(double*, particle_template*); 
        void static get_px(double*, particle_template*); 

        cproperty<double, particle_template> py; 
        void static set_py(double*, particle_template*); 
        void static get_py(double*, particle_template*); 

        cproperty<double, particle_template> pz; 
        void static set_pz(double*, particle_template*); 
        void static get_pz(double*, particle_template*); 

        cproperty<int, particle_template> pdgid; 
        void static set_pdgid(int*, particle_template*); 
        void static get_pdgid(int*, particle_template*); 

        cproperty<std::string, particle_template> symbol; 
        void static set_symbol(std::string*, particle_template*); 
        void static get_symbol(std::string*, particle_template*); 

        cproperty<double, particle_template> charge; 
        void static set_charge(double*, particle_template*); 
        void static get_charge(double*, particle_template*); 

        cproperty<std::string, particle_template> hash; 
        void static get_hash(std::string*, particle_template*); 

        bool is(std::vector<int> p); 
        cproperty<bool, particle_template> is_b; 
        void static get_isb(bool*, particle_template*); 

        cproperty<bool, particle_template> is_lep; 
        void static get_islep(bool*, particle_template*); 

        cproperty<bool, particle_template> is_nu; 
        void static get_isnu(bool*, particle_template*); 

        cproperty<bool, particle_template> is_add; 
        void static get_isadd(bool*, particle_template*); 

        cproperty<bool, particle_template> lep_decay; 
        void static get_lepdecay(bool*, particle_template*); 

        cproperty<std::map<std::string, particle_template*>, particle_template> parents; 
        void static set_parents(std::map<std::string, particle_template*>*, particle_template*); 
        void static get_parents(std::map<std::string, particle_template*>*, particle_template*); 

        cproperty<std::map<std::string, particle_template*>, particle_template> children; 
        void static set_children(std::map<std::string, particle_template*>*, particle_template*); 
        void static get_children(std::map<std::string, particle_template*>*, particle_template*); 

        cproperty<std::string, particle_template> type; 
        void static set_type(std::string*, particle_template*); 
        void static get_type(std::string*, particle_template*); 

        cproperty<int, particle_template> index; 
        void static set_index(int*, particle_template*); 
        void static get_index(int*, particle_template*); 

        double DeltaR(particle_template* p);

        bool operator == (particle_template& p); 

        template <typename g>
        g operator + (g& p){
            g p2 = g(); 
            p2.data.px = double(p.px) + double(this -> px); 
            p2.data.py = double(p.py) + double(this -> py);  
            p2.data.pz = double(p.pz) + double(this -> pz); 
            p2.data.e  = double(p.e ) + double(this -> e); 
            p2.data.type = this -> data.type; 
            p2.data.polar = true; 
            return p2; 
        }

        void operator += (particle_template* p); 
        void iadd(particle_template* p); 
      
        bool register_parent(particle_template* p);
        std::map<std::string, particle_template*> m_parents; 

        bool register_child(particle_template* p);
        std::map<std::string, particle_template*> m_children; 

        void add_leaf(std::string key, std::string leaf = ""); 
        std::map<std::string, std::string> leaves = {}; 

        void apply_type_prefix(); 
        std::map<std::string, std::map<std::string, particle_t>> __reduce__(); 

        virtual void build(std::map<std::string, particle_template*>* event, element_t* el); 
        virtual particle_template* clone(); 
        particle_t data;  

        bool _is_serial = false; 
        bool _is_marked = false; 
}; 
#endif

#include <templates/particle_template.h>

void particle_template::set_px(double* val, particle_template* prt){ 
    prt -> data.px = *val; 
    prt -> data.polar = true; 
}

void particle_template::get_px(double* val, particle_template* prt){
    prt -> to_cartesian(); 
    *val = prt -> data.px;
}

void particle_template::set_py(double* val, particle_template* prt){ 
    prt -> data.py = *val; 
    prt -> data.polar = true; 
}

void particle_template::get_py(double* val, particle_template* prt){
    prt -> to_cartesian(); 
    *val = prt -> data.py;
}

void particle_template::set_pz(double* val, particle_template* prt){ 
    prt -> data.pz = *val; 
    prt -> data.polar = true; 
}

void particle_template::get_pz(double* val, particle_template* prt){
    prt -> to_cartesian(); 
    *val = prt -> data.pz;
}

void particle_template::to_cartesian(){
    particle_t* p = &this -> data; 
    if (!p -> cartesian){ return; }
    p -> px = (p -> pt)*std::cos(p -> phi); 
    p -> py = (p -> pt)*std::sin(p -> phi); 
    p -> pz = (p -> pt)*std::sinh(p -> eta); 
    p -> cartesian = false; 
}


#include <templates/particle_template.h>

void particle_template::set_pdgid(int* val, particle_template* prt){
    prt -> data.pdgid = *val; 
}

void particle_template::get_pdgid(int* val, particle_template* prt){
    particle_t* p = &prt -> data; 
    if (p -> pdgid != 0){ *val = p -> pdgid; return; }
    if (p -> symbol.size() == 0){ *val = p -> pdgid; return; }
    
    std::map<int, std::string> sym = {
             {1, "d"}, {2, "u"}, {3, "s"}, 
             {4, "c"}, {5, "b"}, {6, "t"},
             {11, "e"}, {12, "$\\nu_{e}$"}, 
             {13, "$\\mu$"}, {14, "$\\nu_{\\mu}$"}, 
             {15, "$\\tau$"}, {16, "$\\nu_{\\tau}$"},
             {21, "g"}, {22, "$\\gamma$"}
    }; 

    std::map<int, std::string>::iterator it = sym.begin(); 
    for (; it != sym.end(); ++it){
        if (it -> second != p -> symbol){continue;}
        p -> pdgid = it -> first; 
        *val = p -> pdgid; 
        return; 
    }
    *val = p -> pdgid;  
}

void particle_template::set_symbol(std::string* val, particle_template* prt){
    prt -> data.symbol = *val;
}

void particle_template::get_symbol(std::string* val, particle_template* prt){
    particle_t* p = &prt -> data; 
    if ((p -> symbol).size() != 0){*val = p -> symbol; return; }
    
    std::map<int, std::string> sym = {
             {1, "d"}, {2, "u"}, {3, "s"}, 
             {4, "c"}, {5, "b"}, {6, "t"},
             {11, "e"}, {12, "$\\nu_{e}$"}, 
             {13, "$\\mu$"}, {14, "$\\nu_{\\mu}$"}, 
             {15, "$\\tau$"}, {16, "$\\nu_{\\tau}$"},
             {21, "g"}, {22, "$\\gamma$"}
    }; 

    std::stringstream ss; 
    ss << sym[std::abs(p -> pdgid)];
    *val = ss.str(); 
}

void particle_template::set_charge(double* val, particle_template* prt){
    prt -> data.charge = *val;
}

void particle_template::get_charge(double* val, particle_template* prt){
    *val = prt -> data.charge;
}

void particle_template::get_isb(bool* val, particle_template* prt){ 
    *val = prt -> is({5}); 
}

void particle_template::get_isnu(bool* val, particle_template* prt){ 
    *val = prt -> is(prt -> data.nudef); 
}

void particle_template::get_islep(bool* val, particle_template* prt){ 
    *val = prt -> is(prt -> data.lepdef); 
}

void particle_template::get_isadd(bool* val, particle_template* prt){ 
    *val = !(prt -> is_lep || prt -> is_nu || prt -> is_b); 
}


bool particle_template::is(std::vector<int> p){
    for (int& i : p){ 
        if (std::abs(i) != std::abs(this -> data.pdgid)){continue;} 
        return true;
    }
    return false; 
}

void particle_template::get_lepdecay(bool* val, particle_template* prt){
    bool nu  = false; 
    bool lep = false; 
    std::map<std::string, particle_template*> tmp = prt -> children; 
    std::map<std::string, particle_template*>::iterator itr = tmp.begin(); 
    for (; itr != tmp.end(); ++itr){
        if (!nu) { nu  = itr -> second -> is_nu;}
        if (!lep){ lep = itr -> second -> is_lep;}
    }
    if (lep && nu){ *val = true; return;}
    *val = false; 
}

void particle_template::add_leaf(std::string key, std::string leaf){
    if (!leaf.size()){leaf = key;}
    this -> leaves[key] = leaf; 
}

void particle_template::set_parents(std::map<std::string, particle_template*>* val, particle_template* prt){
    std::map<std::string, particle_template*>::iterator itr = val -> begin();
    for (; itr != val -> end(); ++itr){prt -> register_parent(itr -> second);}
    if (val -> size()){return;}
    prt -> data.parents = {}; 
    prt -> m_parents = {};
}

void particle_template::get_parents(std::map<std::string, particle_template*>* val, particle_template* prt){
    std::map<std::string, particle_template*>::iterator itr = prt -> m_parents.begin();
    for (; itr != prt -> m_parents.end(); ++itr){
        if (val -> count(itr -> second -> hash)){continue;}
        (*val)[itr -> second -> hash] = itr -> second; 
    }
}

void particle_template::set_children(std::map<std::string, particle_template*>* val, particle_template* prt){
    std::map<std::string, particle_template*>::iterator itr = val -> begin();
    for (; itr != val -> end(); ++itr){prt -> register_child(itr -> second);}
    if (val -> size()){return;}
    prt -> data.children = {}; 
    prt -> m_children = {}; 
}

void particle_template::get_children(std::map<std::string, particle_template*>* val, particle_template* prt){
    std::map<std::string, particle_template*>::iterator itr = prt -> m_children.begin();
    for (; itr != prt -> m_children.end(); ++itr){
        if (val -> count(itr -> second -> hash)){continue;}
        (*val)[itr -> second -> hash] = itr -> second; 
    }
}

bool particle_template::register_child(particle_template* p){
    std::string hash = p -> hash; 
    if (this -> data.children[hash]){return false;}
    this -> m_children[hash] = p; 
    this -> data.children[hash] = true; 
    return true; 
}

bool particle_template::register_parent(particle_template* p){
    std::string hash = p -> hash; 
    if (this -> data.parents[hash]){return true;}
    this -> m_parents[hash] = p; 
    this -> data.parents[hash] = true; 
    return true; 
}

void particle_template::get_hash(std::string* val, particle_template* prt){
    particle_t* p = &prt -> data; 
    if ((p -> hash).size()){*val = p -> hash; return; }

    prt -> to_cartesian(); 
    p -> hash  = prt -> to_string(prt -> px); 
    p -> hash += prt -> to_string(prt -> py); 
    p -> hash += prt -> to_string(prt -> pz);
    p -> hash += prt -> to_string(prt -> e); 
    p -> hash  = prt -> tools::hash(p -> hash); 
    *val = p -> hash; 
}

void particle_template::set_type(std::string* val, particle_template* prt){
    prt -> data.type = *val;  
}

void particle_template::get_type(std::string* val, particle_template* prt){
    *val = prt -> data.type; 
}

void particle_template::set_index(int* val, particle_template* prt){
    prt -> data.index = *val;  
}

void particle_template::get_index(int* val, particle_template* prt){
    *val = prt -> data.index; 
}


#include <templates/particle_template.h>

particle_template::particle_template(){
    this -> e.set_setter(this -> set_e); 
    this -> e.set_getter(this -> get_e); 
    this -> e.set_object(this); 

    this -> mass.set_setter(this -> set_mass); 
    this -> mass.set_getter(this -> get_mass); 
    this -> mass.set_object(this); 

    this -> pt.set_setter(this -> set_pt); 
    this -> pt.set_getter(this -> get_pt); 
    this -> pt.set_object(this); 

    this -> eta.set_setter(this -> set_eta); 
    this -> eta.set_getter(this -> get_eta); 
    this -> eta.set_object(this); 

    this -> phi.set_setter(this -> set_phi); 
    this -> phi.set_getter(this -> get_phi); 
    this -> phi.set_object(this); 

    this -> px.set_setter(this -> set_px); 
    this -> px.set_getter(this -> get_px); 
    this -> px.set_object(this); 

    this -> py.set_setter(this -> set_py); 
    this -> py.set_getter(this -> get_py); 
    this -> py.set_object(this); 

    this -> pz.set_setter(this -> set_pz); 
    this -> pz.set_getter(this -> get_pz); 
    this -> pz.set_object(this); 

    this -> pdgid.set_setter(this -> set_pdgid); 
    this -> pdgid.set_getter(this -> get_pdgid); 
    this -> pdgid.set_object(this); 

    this -> symbol.set_setter(this -> set_symbol); 
    this -> symbol.set_getter(this -> get_symbol); 
    this -> symbol.set_object(this); 

    this -> charge.set_setter(this -> set_charge); 
    this -> charge.set_getter(this -> get_charge); 
    this -> charge.set_object(this); 

    this -> hash.set_getter(this -> get_hash); 
    this -> hash.set_object(this); 

    this -> is_b.set_getter(this -> get_isb); 
    this -> is_b.set_object(this); 

    this -> is_lep.set_getter(this -> get_islep); 
    this -> is_lep.set_object(this); 

    this -> is_nu.set_getter(this -> get_isnu); 
    this -> is_nu.set_object(this); 

    this -> is_add.set_getter(this -> get_isadd); 
    this -> is_add.set_object(this); 

    this -> lep_decay.set_getter(this -> get_lepdecay); 
    this -> lep_decay.set_object(this); 

    this -> parents.set_setter(this -> set_parents); 
    this -> parents.set_getter(this -> get_parents); 
    this -> parents.set_object(this); 

    this -> children.set_setter(this -> set_children); 
    this -> children.set_getter(this -> get_children); 
    this -> children.set_object(this); 

    this -> type.set_setter(this -> set_type); 
    this -> type.set_getter(this -> get_type); 
    this -> type.set_object(this); 

    this -> index.set_setter(this -> set_index); 
    this -> index.set_getter(this -> get_index); 
    this -> index.set_object(this); 
}

particle_template::particle_template(particle_t* p) : particle_template(){this -> data = *p;}

particle_template::particle_template(particle_template* p, bool dump) : particle_template(){
    if (!p){return;}
    this -> data = p -> data;
    this -> data.children.clear();
    this -> data.parents.clear(); 
    if (!dump){return;}

    p -> data.data_p = nullptr; 
    bool init = (!this -> data.data_p); 
    std::map<std::string, particle_template*>* tr = nullptr; 
    if (init){tr = new std::map<std::string, particle_template*>();}
    else {tr = this -> data.data_p;}
    (*tr)[this -> hash] = this; 
    this -> _is_serial = p -> _is_serial; 

    std::map<std::string, particle_template*> ch_ = p -> children; 
    std::map<std::string, particle_template*> pr_ = p -> parents; 

    std::map<std::string, particle_template*>::iterator itr; 
    for (itr = ch_.begin(); itr != ch_.end(); ++itr){
        itr -> second -> data.data_p = tr; 
        if (!tr -> count(itr -> first)){(*tr)[itr -> first] = new particle_template(itr -> second, true);}
        itr -> second -> data.data_p = nullptr; 

        particle_template* pr = (*tr)[itr -> first];
        this -> register_child(pr); 
        pr -> data.data_p = nullptr; 
        itr -> second -> _is_serial += p -> _is_serial; 
        pr -> _is_serial = itr -> second -> _is_serial; 
    }

    for (itr = pr_.begin(); itr != pr_.end(); ++itr){
        itr -> second -> data.data_p = tr; 
        if (!tr -> count(itr -> first)){(*tr)[itr -> first] = new particle_template(itr -> second, true);}
        itr -> second -> data.data_p = nullptr; 

        particle_template* pr = (*tr)[itr -> first];
        this -> register_parent(pr); 
        pr -> data.data_p = nullptr; 
        itr -> second -> _is_serial += p -> _is_serial; 
        pr -> _is_serial = itr -> second -> _is_serial; 
    }
    if (init){this -> data.data_p = tr;}
    else {this -> data.data_p = nullptr;}
}

std::map<std::string, std::map<std::string, particle_t>> particle_template::__reduce__(){
    std::map<std::string, particle_template*>* tmp = this -> data.data_p; 
    this -> data.data_p = nullptr; 

    particle_template* t = new particle_template(this, true); 
    std::map<std::string, std::map<std::string, particle_t>> out; 
    std::map<std::string, particle_template*>::iterator itr = t -> data.data_p -> begin(); 
    for (; itr != t -> data.data_p -> end(); ++itr){
        if (itr -> second -> _is_serial){continue;}
        out[itr -> first]["data"] = itr -> second -> data;
    }
    delete t; 
    this -> data.data_p = tmp; 
    return out; 
}

particle_template::particle_template(double px, double py, double pz, double e) : particle_template(){
    particle_t* p = &this -> data; 
    p -> px = px; p -> py = py; p -> pz = pz; p -> e = e; 
    p -> polar = true; 
}

particle_template::particle_template(double px, double py, double pz) : particle_template() {
    particle_t* p = &this -> data; 
    p -> px = px; p -> py = py; p -> pz = pz; p -> e = this -> e; 
    p -> polar = true; 
}

particle_template::~particle_template(){
    if (!this -> data.data_p){return;}
    std::string hash_ = this -> hash; 
    (*this -> data.data_p)[hash_] = nullptr; 
    std::map<std::string, particle_template*>::iterator itr = this -> data.data_p -> begin(); 
    for (; itr != this -> data.data_p -> end(); ++itr){
        if (!itr -> second){continue;}
        delete itr -> second;
        itr -> second = nullptr; 
    }
    this -> data.data_p -> clear(); 
    delete this -> data.data_p; 
}

void particle_template::operator += (particle_template* p){
    p -> to_cartesian(); 
    this -> to_cartesian();
    this -> data.px += double(p -> px); 
    this -> data.py += double(p -> py); 
    this -> data.pz += double(p -> pz); 
    this -> data.e  += double(p -> e); 
    this -> data.polar = true;
}

void particle_template::iadd(particle_template* p){
    *this += p; 
}

bool particle_template::operator == (particle_template& p){
    return this -> hash == p.hash; 
}

void particle_template::apply_type_prefix(){
    std::map<std::string, std::string> lf = {}; 
    std::map<std::string, std::string>::iterator itr = this -> leaves.begin();
    for (; itr != this -> leaves.end(); ++itr){lf[itr -> first] = this -> type + itr -> second;}
    this -> leaves = lf; 
}


void particle_template::build(std::map<std::string, particle_template*>*, element_t*){
    return; 
}

particle_template* particle_template::clone(){return new particle_template();}
#include <templates/particle_template.h>

double particle_template::DeltaR(particle_template* part){
    double sum = std::fabs( this -> phi - part -> phi);
    sum = std::fmod(sum, 2*M_PI); 
    sum = M_PI - std::fabs(sum - M_PI); 
    sum = std::pow(sum, 2);
    sum += std::pow(this -> eta - part -> eta, 2); 
    return std::pow(sum, 0.5); 
}

void particle_template::get_e(double* v, particle_template* prt) {
    particle_t* p = &prt -> data; 
    if (p -> e >= 0){*v = p -> e; return;}
    p -> e += std::pow(prt -> px, 2); 
    p -> e += std::pow(prt -> py, 2); 
    p -> e += std::pow(prt -> pz, 2); 
    if (p -> mass >= 0){p -> e += p -> mass;}
    p -> e  = std::pow(p -> e, 0.5); 
    *v = p -> e; 
}

void particle_template::set_e(double* val, particle_template* prt){ 
    prt -> data.e = *val; 
}

void particle_template::set_mass(double* val, particle_template* prt){ 
    prt -> data.mass = *val; 
}

void particle_template::get_mass(double* val, particle_template* prt){
    particle_t* p = &prt -> data; 
    if (p -> mass > -1){ *val = p -> mass; return; }
    p -> mass = 0; 
    p -> mass -= std::pow(prt -> px, 2); 
    p -> mass -= std::pow(prt -> py, 2); 
    p -> mass -= std::pow(prt -> pz, 2); 
    p -> mass += std::pow(prt -> e , 2); 
    p -> mass = (p -> mass >= 0) ? std::pow(p -> mass, 0.5) : -1; 
    *val = p -> mass; 
}



#include <templates/particle_template.h>

void particle_template::set_pt(double* val, particle_template* prt){ 
    prt -> data.pt = *val; 
    prt -> data.cartesian = true;
}

void particle_template::get_pt(double* val, particle_template* prt){
    prt -> to_polar(); 
    *val = prt -> data.pt;
}


void particle_template::set_eta(double* val, particle_template* prt){ 
    prt -> data.eta = *val; 
    prt -> data.cartesian = true; 
}

void particle_template::get_eta(double* val, particle_template* prt){
    prt -> to_polar(); 
    *val = prt -> data.eta;
}

void particle_template::set_phi(double* val, particle_template* prt){ 
    prt -> data.phi = *val; 
    prt -> data.cartesian = true; 
}


void particle_template::get_phi(double* val, particle_template* prt){
    prt -> to_polar(); 
    *val = prt -> data.phi;
}

void particle_template::to_polar(){
    particle_t* p = &this -> data; 
    if (!p -> polar){ return; }

    // Transverse Momenta
    p -> pt  = std::pow(p -> px, 2); 
    p -> pt += std::pow(p -> py, 2);
    p -> pt  = std::pow(p -> pt, 0.5); 

    // Rapidity 
    p -> eta = std::asinh(p -> pz / p -> pt); 
    p -> phi = std::atan2(p -> py, p -> px);  
    p -> polar = false; 
}

