<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="metric__template_8pyx" kind="file" language="C++">
    <compoundname>metric_template.pyx</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#<sp/>distutils:<sp/>language=c++</highlight></codeline>
<codeline><highlight class="normal">#<sp/>cython:<sp/>language_level<sp/>=<sp/>3</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">from<sp/>libcpp<sp/>cimport<sp/>string</highlight></codeline>
<codeline><highlight class="normal">from<sp/>libcpp.map<sp/>cimport<sp/>map,<sp/>pair</highlight></codeline>
<codeline><highlight class="normal">from<sp/>libcpp.vector<sp/>cimport<sp/>vector</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">from<sp/>AnalysisG.core.tools<sp/>cimport<sp/>*</highlight></codeline>
<codeline><highlight class="normal">from<sp/>AnalysisG.core.meta<sp/>cimport<sp/>*</highlight></codeline>
<codeline><highlight class="normal">from<sp/>AnalysisG.core.structs<sp/>cimport<sp/>*</highlight></codeline>
<codeline><highlight class="normal">from<sp/>cython.parallel<sp/>import<sp/>prange</highlight></codeline>
<codeline><highlight class="normal">from<sp/>cython.operator<sp/>cimport<sp/>dereference<sp/>as<sp/>deref</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">cdef<sp/>class<sp/>MetricTemplate:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__cinit__(self):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx<sp/>=<sp/>new<sp/>metric_template()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.root_leaves<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.root_fx<sp/>=<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__init__(self):<sp/>pass</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__dealloc__(self):<sp/>del<sp/>self.mtx</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__name__(self):<sp/>return<sp/>env(self.mtx.name)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@property</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>RunNames(self):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>string]<sp/>o<sp/>=<sp/>self.mtx.run_names</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>as_basic_dict(&amp;o)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@RunNames.setter</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>RunNames(self,<sp/>dict<sp/>val):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>string]<sp/>o</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>as_map(val,<sp/>&amp;o)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx.run_names<sp/>=<sp/>o</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@property</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Variables(self):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>o<sp/>=<sp/>self.mtx.variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>env_vec(&amp;o)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@Variables.setter</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Variables(self,<sp/>list<sp/>val):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx.variables<sp/>=<sp/>enc_list(val)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Postprocessing(self):<sp/>pass</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>InterpretROOT(self,<sp/>str<sp/>path,<sp/>list<sp/>epochs<sp/>=<sp/>[],<sp/>list<sp/>kfolds<sp/>=<sp/>[]):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>len(self.root_leaves)<sp/>or<sp/>not<sp/>len(self.root_fx):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx.failure(b&quot;Failed<sp/>to<sp/>interpret!&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx.failure(b&quot;Please<sp/>set<sp/>the<sp/>attributes:&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx.failure(b&quot;-&gt;<sp/>dictionary<sp/>{&lt;tree&gt;<sp/>:<sp/>[&lt;leaves&gt;]}<sp/>:<sp/>&apos;root_leaves&apos;&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.mtx.failure(b&quot;-&gt;<sp/>dictionary<sp/>{&lt;tree&gt;<sp/>:<sp/>&lt;fx(class,<sp/>data,<sp/>meta)&gt;}<sp/>or<sp/>{&lt;tree&gt;.&lt;leaves&gt;<sp/>:<sp/>&lt;fx(class,<sp/>data,<sp/>meta)&gt;}:<sp/>&apos;root_fx&apos;&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>self</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/><sp/><sp/>path.endswith(&quot;/&quot;):<sp/>path<sp/>+=<sp/>&quot;*&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>elif<sp/>path.endswith(&quot;.root&quot;):<sp/>pass</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else:<sp/>path<sp/>+=<sp/>&quot;*&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>long<sp/>ix,<sp/>il</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>int<sp/>kfold,<sp/>epoch</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>str<sp/>k,<sp/>l,<sp/>kx</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>string<sp/>key,<sp/>kl,<sp/>model_name<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>data_t*<sp/>dt<sp/>=<sp/>NULL</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>data_t*<sp/>lxk<sp/>=<sp/>NULL</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>bool<sp/>unpause,<sp/>keep_going</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>list<sp/>leaves<sp/>=<sp/>[]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>long]<sp/>idx_map</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>bool]<sp/>endx,<sp/>pause</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>lsx</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[vector[string]]<sp/>mxf<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>epochs_,<sp/>kfolds_<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>vector[string<sp/>]]<sp/>mapfx</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>vector[data_t*]]<sp/>mapdx</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>map[string,<sp/>long]]<sp/>mapx</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>dict<sp/>itx<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>dict<sp/>meta<sp/>=<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>tools<sp/>tl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>epochs_<sp/>=<sp/>[enc(str(epoch))<sp/>for<sp/>epoch<sp/>in<sp/>epochs]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>kfolds_<sp/>=<sp/>[enc(str(kfold))<sp/>for<sp/>kfold<sp/>in<sp/>kfolds]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>epochs_.size()<sp/>+<sp/>kfolds_.size():<sp/>lsx<sp/>=<sp/>self.ptr.ls(enc(path),<sp/>b&quot;.root&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>kfold<sp/>in<sp/>prange(lsx.size(),<sp/>nogil<sp/>=<sp/>True,<sp/>num_threads<sp/>=<sp/>12):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>finder(&amp;lsx[kfold],<sp/>&amp;kfolds_,<sp/>&amp;epochs_):<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_map[lsx[kfold]]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>epochs_.size()<sp/>+<sp/>kfolds_.size()<sp/>and<sp/>idx_map.size():<sp/>pass</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>elif<sp/>epochs_.size()<sp/>+<sp/>kfolds_.size()<sp/>==<sp/>0:<sp/>pass</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else:<sp/>self.mtx.failure(b&quot;Files<sp/>for<sp/>requested<sp/>epoch<sp/>and<sp/>kfolds<sp/>not<sp/>found!&quot;);<sp/>exit()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lsx<sp/>=<sp/>&lt;vector[string]&gt;(list(idx_map))</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unpause<sp/>=<sp/>True</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>keep_going<sp/>=<sp/>True</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>dict<sp/>remap<sp/>=<sp/>{enc(l)<sp/>:<sp/>self.root_fx[l]<sp/>for<sp/>l<sp/>in<sp/>self.root_fx}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>k<sp/>in<sp/>self.root_leaves:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key<sp/>=<sp/>enc(k)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>l<sp/>in<sp/>self.root_leaves[k]:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>kx<sp/>=<sp/>k<sp/>+<sp/>&quot;.&quot;<sp/>+<sp/>l</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>kl<sp/>=<sp/>enc(kx)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>k<sp/>in<sp/>self.root_fx:<sp/><sp/><sp/><sp/>mapfx[key].push_back(enc(l));<sp/>mapdx[key].push_back(NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>elif<sp/>kx<sp/>in<sp/>self.root_fx:<sp/>mapfx[kl].push_back(enc(l));<sp/><sp/>mapdx[kl].push_back(NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else:<sp/>continue<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leaves<sp/>+=<sp/>[l]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>IO<sp/>iox<sp/>=<sp/>IO(path<sp/>if<sp/>not<sp/>lsx.size()<sp/>else<sp/>env_vec(&amp;lsx))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.Trees<sp/><sp/>=<sp/>list(self.root_leaves)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.Leaves<sp/>=<sp/>list(set(leaves))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.__iter__()</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>pair[string,<sp/>data_t*]<sp/>itr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>data_t*]<sp/>dmp<sp/>=<sp/>deref(iox.data_ops)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>dmi<sp/>=<sp/>[itr.first<sp/>for<sp/>itr<sp/>in<sp/>dmp]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leaves<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>kl<sp/>=<sp/>b&quot;&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_map.clear()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mapx<sp/>=<sp/>iox.ptr.tree_entries</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>pair[string,<sp/>vector[string]]<sp/>itm</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>itr<sp/>in<sp/>dmp:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pause[itr.first]<sp/>=<sp/>False</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>itm<sp/>in<sp/>mapfx:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leaves.append([itr.second.tree_name,<sp/>itr.first,<sp/>itm.first])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>self.ptr.has_string(&amp;itr.first,<sp/>itm.first<sp/>+<sp/>b&quot;.&quot;):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>ix<sp/>in<sp/>range(itm.second.size()):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>self.ptr.ends_with(&amp;itr.first,<sp/>b&quot;.&quot;<sp/>+<sp/>itm.second[ix]):<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mapdx[itm.first][ix]<sp/>=<sp/>itr.second</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>itr.first<sp/>==<sp/>itm.first:<sp/>mapdx[itm.first][0]<sp/>=<sp/>itr.second</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>lxk<sp/>!=<sp/>NULL:<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lxk<sp/>=<sp/>itr.second</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mxf<sp/>=<sp/>&lt;vector[vector[string]]&gt;(leaves)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>keep_going:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itx<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>key<sp/>in<sp/>remap:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itx[key]<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unpause<sp/>=<sp/>False</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>dt<sp/>in<sp/>mapdx[key]:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>endx[dt.path]:<sp/>break</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>pause[dt.path]:<sp/>break</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>itx[key]<sp/>|=<sp/>switch_board(dt)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unpause<sp/>=<sp/>True</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_map[key]<sp/>+=<sp/>unpause</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>keep_going<sp/>=<sp/>False</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>il<sp/>in<sp/>prange(dmp.size(),<sp/>nogil<sp/>=<sp/>True,<sp/>num_threads<sp/>=<sp/>dmp.size()):<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dt<sp/>=<sp/>dmp[dmi[il]];<sp/>ix<sp/>=<sp/>dt.index</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>pause[dt.path]<sp/>or<sp/>endx[dt.path]:<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>endx[dt.path]<sp/>+=<sp/>dt.next()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>keep_going<sp/>+=<sp/>not<sp/>endx[dt.path]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>ix:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>kl<sp/>=<sp/>deref(lxk.fname)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leaves<sp/>=<sp/><sp/>env(kl).split(&quot;/&quot;)[-3:]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>kfold<sp/>=<sp/>int(leaves[-1].replace(&quot;.root&quot;,<sp/>&quot;&quot;).replace(&quot;kfold-&quot;,<sp/>&quot;&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>epoch<sp/>=<sp/>int(leaves[-3].replace(&quot;epoch-&quot;,<sp/>&quot;&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>model_name<sp/>=<sp/>enc(leaves[-2])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>meta<sp/>=<sp/>{b&quot;filename&quot;<sp/>:<sp/>kl,<sp/>b&quot;epoch&quot;<sp/>:<sp/>epoch,<sp/>b&quot;kfold&quot;<sp/>:<sp/>kfold,<sp/>b&quot;model_name&quot;<sp/>:<sp/>model_name}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.prg.set_description(&quot;/&quot;.join(env(kl).split(&quot;/&quot;)[-4:]))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.prg.refresh()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>key<sp/>in<sp/>remap:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>len(itx[key]):<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remap[key](self,<sp/>itx[key],<sp/>{b&quot;index&quot;<sp/>:<sp/>idx_map[key]-1}<sp/>|<sp/>meta)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>ix<sp/>in<sp/>prange(mxf.size(),<sp/>nogil<sp/>=<sp/>True,<sp/>num_threads<sp/>=<sp/>mxf.size()):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pause[mxf[ix][1]]<sp/>=<sp/>mapx[kl][mxf[ix][0]]<sp/>==<sp/>(dmp[mxf[ix][1]].index+1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unpause<sp/>=<sp/>True<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>ix<sp/>in<sp/>prange(mxf.size(),<sp/>nogil<sp/>=<sp/>True):<sp/>unpause<sp/>*=<sp/>pause[mxf[ix][1]]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>unpause:<sp/>pause.clear();<sp/>idx_map.clear();<sp/>kl<sp/>=<sp/>b&quot;&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.prg.update(1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>keep_going:<sp/>break</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.Postprocessing()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>self</highlight></codeline>
    </programlisting>
    <location file="core/metric_template.pyx"/>
  </compounddef>
</doxygen>
