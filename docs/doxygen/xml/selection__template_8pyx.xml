<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="selection__template_8pyx" kind="file" language="C++">
    <compoundname>selection_template.pyx</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#<sp/>distutils:<sp/>language=c++</highlight></codeline>
<codeline><highlight class="normal">#<sp/>cython:<sp/>language_level<sp/>=<sp/>3</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">from<sp/>libcpp<sp/>cimport<sp/>string</highlight></codeline>
<codeline><highlight class="normal">from<sp/>libcpp.map<sp/>cimport<sp/>map,<sp/>pair</highlight></codeline>
<codeline><highlight class="normal">from<sp/>libcpp.vector<sp/>cimport<sp/>vector</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">from<sp/>AnalysisG.core.tools<sp/>cimport<sp/>*</highlight></codeline>
<codeline><highlight class="normal">from<sp/>AnalysisG.core.meta<sp/>cimport<sp/>*</highlight></codeline>
<codeline><highlight class="normal">from<sp/>AnalysisG.core.io<sp/>import<sp/>IO</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">import<sp/>pathlib</highlight></codeline>
<codeline><highlight class="normal">import<sp/>pickle</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">cdef<sp/>class<sp/>SelectionTemplate:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__cinit__(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>type(self)<sp/>is<sp/>not<sp/>SelectionTemplate:<sp/>return</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.root_leaves<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.ptr<sp/>=<sp/>new<sp/>selection_template()</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__init__(self,<sp/>inpt<sp/>=<sp/>None):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>inpt<sp/>is<sp/>None:<sp/>return</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>list<sp/>keys<sp/>=<sp/>[i<sp/>for<sp/>i<sp/>in<sp/>self.__dir__()<sp/>if<sp/>not<sp/>i.startswith(&quot;__&quot;)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>i<sp/>in<sp/>keys:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try:<sp/>setattr(self,<sp/>i,<sp/>inpt[&quot;data&quot;][i])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>except<sp/>KeyError:<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>except<sp/>AttributeError:<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.ptr.passed_weights<sp/>=<sp/>&lt;map[string,<sp/>map[string,<sp/>float]]&gt;(inpt[&quot;weights&quot;])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.ptr.matched_meta<sp/><sp/><sp/>=<sp/>&lt;map[string,<sp/>meta_t]&gt;(inpt[&quot;meta&quot;])</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__dealloc__(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>type(self)<sp/>is<sp/>not<sp/>SelectionTemplate:<sp/>return</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>del<sp/>self.ptr</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__hash__(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>int(string(self.ptr.hash).substr(0,<sp/>8),<sp/>0)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__name__(self):<sp/>return<sp/>env(self.ptr.name)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>__reduce__(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>list<sp/>keys<sp/>=<sp/>[i<sp/>for<sp/>i<sp/>in<sp/>self.__dir__()<sp/>if<sp/>not<sp/>i.startswith(&quot;__&quot;)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>dict<sp/>out<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out[&quot;data&quot;]<sp/>=<sp/>{i<sp/>:<sp/>getattr(self,<sp/>i)<sp/>for<sp/>i<sp/>in<sp/>keys<sp/>if<sp/>not<sp/>callable(getattr(self,<sp/>i))}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out[&quot;weights&quot;]<sp/>=<sp/>self.ptr.passed_weights</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out[&quot;meta&quot;]<sp/><sp/><sp/><sp/>=<sp/>self.ptr.matched_meta</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>self.__class__,<sp/>(out,)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>void<sp/>transform_dict_keys(self):<sp/>pass</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>dump(self,<sp/>str<sp/>path<sp/>=<sp/>&quot;./pkl-data&quot;,<sp/>str<sp/>name<sp/>=<sp/>&quot;&quot;):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>len(name):<sp/>name<sp/>=<sp/>env(self.ptr.name)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pathlib.Path(path).mkdir(parents<sp/>=<sp/>True,<sp/>exist_ok<sp/>=<sp/>True)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try:<sp/>pickle.dump(self,<sp/>open(path<sp/>+<sp/>&quot;/&quot;<sp/>+<sp/>name<sp/>+<sp/>&quot;.pkl&quot;,<sp/>&quot;wb&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>except<sp/>OSError:<sp/>print(&quot;Failed<sp/>to<sp/>save<sp/>the<sp/>SelectionTemplate&quot;)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>load(self,<sp/>str<sp/>path<sp/>=<sp/>&quot;./pkl-data&quot;,<sp/>str<sp/>name<sp/>=<sp/>&quot;&quot;):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>len(name):<sp/>name<sp/>=<sp/>env(self.ptr.name)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try:<sp/>return<sp/>pickle.load(open(path<sp/>+<sp/>&quot;/&quot;<sp/>+<sp/>name<sp/>+<sp/>&quot;.pkl&quot;,<sp/>&quot;rb&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>except<sp/>OSError:<sp/>print(&quot;Failed<sp/>to<sp/>load<sp/>the<sp/>SelectionTemplate&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>except<sp/>EOFError:<sp/>print(&quot;Failed<sp/>to<sp/>load<sp/>the<sp/>SelectionTemplate&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>None</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@property</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PassedWeights(self):<sp/>return<sp/>as_basic_dict_dict(&amp;self.ptr.passed_weights)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>HashToWeightFile(self,<sp/>hash_):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>str<sp/>hash</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>hashes<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>isinstance(hash_,<sp/>list):<sp/><sp/><sp/>hashes<sp/>=<sp/>[enc(hash)<sp/>for<sp/>hash<sp/>in<sp/>hash_]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>elif<sp/>isinstance(hash_,<sp/>dict):<sp/>hashes<sp/>=<sp/>[enc(hash)<sp/>for<sp/>hash<sp/>in<sp/>hash_]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else:<sp/>hashes<sp/>=<sp/>[enc(hash_)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[map[string,<sp/>float]]<sp/>rev<sp/>=<sp/>self.ptr.reverse_hash(&amp;hashes)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[string,<sp/>float]<sp/>i</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>[tuple(dict(i).items())[0]<sp/>for<sp/>i<sp/>in<sp/>rev]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@property</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>GetMetaData(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>Meta<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>dict<sp/>out<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>pair[string,<sp/>meta_t]<sp/>itm</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>itm<sp/>in<sp/>self.ptr.matched_meta:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data<sp/>=<sp/>Meta()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data.ptr.meta_data<sp/>=<sp/>itm.second</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out[env(itm.first)]<sp/>=<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>out</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Postprocessing(self):<sp/>pass</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>InterpretROOT(self,<sp/>str<sp/>path,<sp/>str<sp/>tree):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>len(self.root_leaves):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(&quot;Failed<sp/>to<sp/>interpret!&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(&quot;Please<sp/>set<sp/>the<sp/>attribute<sp/>(<sp/>dictionary<sp/>{&lt;leaves&gt;<sp/>:<sp/>&lt;fx(class,<sp/>data)&gt;}<sp/>):<sp/>&apos;root_leaves&apos;&quot;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>self</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>string<sp/>kx,<sp/>ky</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>list<sp/>rn<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>list<sp/>li<sp/>=<sp/>list(self.root_leaves)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>list<sp/>lo<sp/>=<sp/>list(self.root_leaves.values())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>lx<sp/>=<sp/>&lt;vector[string]&gt;([enc(k)<sp/>for<sp/>k<sp/>in<sp/>li])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>vector[string]<sp/>lf<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>int<sp/>lk,<sp/>lt</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>dict<sp/>i</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>bool<sp/>trig<sp/>=<sp/>False</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>pair[int,<sp/>int]<sp/>pi</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>pair[int,<sp/>string]<sp/>px</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[int,<sp/>string]<sp/>associate<sp/>=<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>map[int,<sp/>int]<sp/>idx<sp/>=<sp/>{};<sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cdef<sp/>tools<sp/>tl<sp/>=<sp/>tools()</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox<sp/>=<sp/>IO()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.Files<sp/>=<sp/>path</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.Trees<sp/>=<sp/>[tree]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.Leaves<sp/>=<sp/>li</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iox.Verbose<sp/>=<sp/>False</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>i<sp/>in<sp/>iox:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>li<sp/>=<sp/>list(i.values())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>pi<sp/>in<sp/>idx:<sp/>lo[pi.second](self,<sp/>(rn[pi.second],<sp/>li[pi.first]))<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>trig:<sp/>continue</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>li<sp/>=<sp/>list(i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>lk<sp/>in<sp/>range(len(li)):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try:<sp/>kx<sp/>=<sp/>enc(li[lk])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>except<sp/>TypeError:<sp/>kx<sp/>=<sp/>li[lk]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lf<sp/>=<sp/>[ky<sp/>for<sp/>ky<sp/>in<sp/>lx<sp/>if<sp/>tl.ends_with(&amp;kx,<sp/>ky)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>not<sp/>lf.size():<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>associate[lk]<sp/>=<sp/>lf[0]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>lt<sp/>in<sp/>range(lx.size()):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lk<sp/>=<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ky<sp/>=<sp/>lx[lt]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>px<sp/>in<sp/>associate:<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>px.second<sp/>!=<sp/>ky:<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lk<sp/>=<sp/>px.first</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>lk<sp/>==<sp/>-1:<sp/>continue</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx[lk]<sp/>=<sp/>lt</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>trig<sp/>=<sp/>True</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>li<sp/>=<sp/>list(i.values())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rn<sp/>=<sp/>list(self.root_leaves)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>pi<sp/>in<sp/>idx:<sp/>lo[pi.second](self,<sp/>(rn[pi.second],<sp/>li[pi.first]))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self.Postprocessing()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>self</highlight></codeline>
    </programlisting>
    <location file="core/selection_template.pyx"/>
  </compounddef>
</doxygen>
