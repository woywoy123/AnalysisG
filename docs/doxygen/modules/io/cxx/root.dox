/**
 * @file root.cxx
 * @brief Documentation for modules/io/cxx/root.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/io/cxx/root.cxx
 */

/**
 * @defgroup modules_io_cxx_root_cxx root.cxx
 * @brief root.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `void io::trigger_pcm(){ std::string cur = this -> absolute_path("./");`
 * - `std::string cur = this -> absolute_path("./");`
 * - `std::string tmp = std::string(dict_path) + "pcm/";`
 * - `this -> create_path(tmp);`
 * - `int opx = static_cast<int>(data_enum::undef);`
 * - `int opc = this -> ls(tmp, ".pcm").size();`
 * - `if (opx-6 > opc){this -> info("Building PCM files... to:" + tmp);}`
 * - `gSystem -> SetBuildDir(tmp.c_str(), true);`
 * - `gSystem -> ChangeDirectory(tmp.c_str());`
 * - `gSystem -> AddDynamicPath(tmp.c_str());`
 * - `gSystem -> SetAclicMode(TSystem::kOpt);`
 * - `std::string mta = std::string(dict_path) + "structs/include/structs/meta.h";`
 * - `tm = new std::thread(buildDict, "meta_t"   , mta);`
 * - `tm -> join(); delete tm;`
 * - `tm = new std::thread(buildDict, "weights_t", mta);`
 * - `tm = new std::thread(buildAll);`
 * - `gSystem -> ChangeDirectory(cur.c_str());`
 * - `void io::check_root_file_paths(){ std::map<std::string, bool> tmp = {};`
 * - `std::map<std::string, bool>::iterator itr = this -> root_files.begin();`
 * - `this -> success("Checking File Path:");`
 * - `for (; itr != this -> root_files.end(); ++itr){`
 * - `int l = itr -> first.size();`
 * - `std::string last = itr -> first.substr(l - 1);`
 * - `if (last == "*"){ std::vector<std::string> files = this -> ls(itr -> first.substr(0, l-1), ".root");`
 * - `std::vector<std::string> files = this -> ls(itr -> first.substr(0, l-1), ".root");`
 * - `for (std::string x : files){tmp[x] = true;}`
 * - `if (!this -> ends_with(&last, ".root")){ std::vector<std::string> f = this -> ls(last, ".root");`
 * - `std::vector<std::string> f = this -> ls(last, ".root");`
 * - `for (size_t x(0); x < f.size(); ++x){`
 * - `this -> success(f[x]);`
 * - `if (!this -> is_file(itr -> first)){ this -> warning("File: " + itr -> first + " not found...");`
 * - `this -> warning("File: " + itr -> first + " not found...");`
 * - `this -> success(itr -> first);`
 * - `tmp[this -> absolute_path(itr -> first)] = true;`
 * - `void io::root_key_paths(std::string path, TTree*){ if (!this -> file_root){return;}`
 * - `if (!this -> file_root){return;}`
 * - `TTree* tr = this -> file_root -> Get<TTree>(path.c_str());`
 * - `if (!tr){return;}`
 * - `std::string file_name = this -> file_root -> GetTitle();`
 * - `for (size_t x(0); x < this -> trees.size(); ++x){`
 * - `if (std::string(tr -> GetName()) != name){continue;}`
 * - `this -> tree_entries[file_name][std::string(tr -> GetName())] = tr -> GetEntries();`
 * - `if (!found){return;}`
 * - `for (size_t x(0); x < this -> branches.size(); ++x){`
 * - `TBranch* br = tr -> FindBranch(name.c_str());`
 * - `if (!br){continue;}`
 * - `name = std::string(tr -> GetName()) + "." + std::string(br -> GetName());`
 * - `for (size_t x(0); x < this -> leaves.size(); ++x){`
 * - `TLeaf* _lf = tr -> FindLeaf(name.c_str());`
 * - `if (!_lf){continue;}`
 * - `TBranch* br = _lf -> GetBranch();`
 * - `std::string name_s = std::string(tr -> GetName()) + ".";`
 * - `if (!br){ this -> leaf_data[file_name][name_s] = _lf;`
 * - `this -> leaf_typed[file_name][name_s] = std::string(_lf -> GetTypeName());`
 * - `name_s += std::string(br -> GetName()) + "." + std::string(_lf -> GetName());`
 * - `if (!br -> IsFolder()){ this -> leaf_data[file_name][name_s]  = _lf;`
 * - `this -> leaf_typed[file_name][name_s] = _lf -> GetTypeName();`
 * - `for (TObject* obj : *br -> GetListOfLeaves()){ TLeaf* __lf = (TLeaf*)obj;`
 * - `TLeaf* __lf = (TLeaf*)obj;`
 * - `if (std::string(__lf -> GetName()) != name){continue;}`
 * - `std::string lx = name_s + "." + __lf -> GetName();`
 * - `this -> leaf_typed[file_name][lx] = std::string(__lf -> GetTypeName());`
 * - `void io::root_key_paths(std::string path){ TDirectory* dir = gDirectory;`
 * - `for (TObject* key : *dir -> GetListOfKeys()){tmp.push_back(key -> GetName());}`
 * - `std::vector<std::string> scrape_meta_ = this -> split(this -> sow_name, ":");`
 * - `for (size_t x(0); x < scrape_meta_.size(); ++x){`
 * - `if (!this -> sow_name.size()){continue;}`
 * - `scrape_meta.push_back(this -> split(scrape_meta_[x], "*"));`
 * - `if (this -> ends_with(&this -> metacache_path, ".h5")){} else if (!this -> ends_with(&this -> metaca`
 * - `else if (!this -> ends_with(&this -> metacache_path, "/")){this -> metacache_path += "/meta.h5";}`
 * - `if (!this -> is_file(this -> metacache_path)){ std::vector<std::string> tmpo = this -> split(this ->`
 * - `std::vector<std::string> tmpo = this -> split(this -> metacache_path, "/");`
 * - `std::string meta_s = tmpo[tmpo.size()-1];`
 * - `this -> replace(&this -> metacache_path, meta_s, "");`
 * - `this -> create_path(this -> metacache_path);`
 * - `for (size_t x(0); x < tmp.size(); ++x){`
 * - `TObject* obj = gDirectory -> Get(updated.c_str());`
 * - `if (!obj){continue;}`
 * - `std::string fname = this -> file_root -> GetTitle();`
 * - `std::string obname = std::string(obj -> GetName());`
 * - `bool is_ttree = obj -> InheritsFrom("TTree");`
 * - `bool is_th1f  = obj -> InheritsFrom("TH1");`
 * - `if (!this -> meta_data.count(fname)){this -> meta_data[fname] = new meta();}`
 * - `if (obname == "AnalysisTracking"){mtx -> scan_data(obj); continue;}`
 * - `if (obname == "EventLoop_FileExecuted"){mtx -> scan_data(obj); continue;}`
 * - `if (obname == "metadata"){mtx -> scan_data(obj); continue;}`
 * - `if (obname == "MetaData"){mtx -> scan_data(obj); continue;}`
 * - `if (this -> sow_name == obname){  mtx -> scan_data(obj); continue;}`
 * - `for (size_t t(0); t < scrape_meta.size(); ++t){`
 * - `for (size_t m(0); m < scrape_meta[t].size(); ++m){`
 * - `found = found && this -> has_string(&obname, scrape_meta[t][m]);`
 * - `if (!found){continue;}`
 * - `mtx -> scan_data(obj);`
 * - `if (is_ttree){this -> root_key_paths(updated, (TTree*)obj); continue;}`
 * - `if (is_th1f){continue;}`
 * - `dir -> cd(updated.c_str());`
 * - `this -> root_key_paths(updated + "/");`
 * - `dir -> cd(path.c_str());`
 * - `bool io::scan_keys(){ std::map<std::string, bool>::iterator itr = this -> root_files.begin();`
 * - `if (!this -> files_open.count(itr -> first)){ this -> file_root = new TFile(itr -> first.c_str(), "R`
 * - `this -> file_root = new TFile(itr -> first.c_str(), "READ");`
 * - `if (this -> file_root -> IsZombie()){ delete this -> file_root;`
 * - `this -> file_root -> SetTitle(itr -> first.c_str());`
 * - `if (!this -> file_root -> IsOpen()){this -> file_root -> ReOpen("READ");}`
 * - `this -> root_key_paths("");`
 * - `this -> file_root -> Close();`
 * - `std::map<std::string, TFile*>::iterator tf = this -> files_open.begin();`
 * - `for (; tf != this -> files_open.end(); ++tf){`
 * - `if (!this -> tree_data.count(fname)){ this -> keys[fname]["missed"]["Trees"]    = this -> trees;`
 * - `if (tr -> count(this -> trees[x])){continue;}`
 * - `bool has = this -> has_value(&this -> keys[fname]["missed"]["Trees"], this -> trees[x]);`
 * - `if (has){continue;}`
 * - `this -> keys[fname]["missed"]["Trees"].push_back(this -> trees[x]);`
 * - `std::map<std::string, TBranch*>::iterator itb = br -> begin();`
 * - `for (; itb != br -> end(); ++itb){`
 * - `if (!this -> ends_with(&br_name, this -> branches[x])){continue;}`
 * - `if (found){continue;}`
 * - `bool has = this -> has_value(&this -> keys[fname]["missed"]["Branches"], this -> branches[x]);`
 * - `this -> keys[fname]["missed"]["Branches"].push_back(this -> branches[x]);`
 * - `std::map<std::string, TLeaf*>::iterator itf = lf -> begin();`
 * - `for (; itf != lf -> end(); ++itf){`
 * - `if (!this -> ends_with(&lf_name, this -> leaves[x])){continue;}`
 * - `bool has = this -> has_value(&this -> keys[fname]["missed"]["Leaves"], this -> leaves[x]);`
 * - `this -> keys[fname]["missed"]["Leaves"].push_back(this -> leaves[x]);`
 * - `if (leaves_m.size() || branches_m.size() || trees_m.size()){this -> failure("-> " + fname);}`
 * - `else if (this -> success_trigger[fname]){continue;}`
 * - `std::map<std::string, long>::iterator itl = tree_ent.begin();`
 * - `for (; itl != tree_ent.end(); ++itl){msg += itl -> first + " - " + itl -> second + " | "; nev_ +=itl`
 * - `if (!nev_){this -> warning("(-)> " + fname + " \n (" + msg.substr(0, msg.size()-3) + ") Skipping..."`
 * - `else {this -> success("(+)> " + fname + "\n (" + msg.substr(0, msg.size()-3) + ") OK! ");}`
 * - `for (size_t x(0); x < trees_m.size(); ++x){`
 * - `if (this -> missing_trigger[trees_m[x]]){continue;}`
 * - `this -> warning("Missing Tree: " + trees_m[x]);`
 * - `for (size_t x(0); x < branches_m.size(); ++x){`
 * - `if (this -> missing_trigger[branches_m[x]]){continue;}`
 * - `this -> warning("Missing Branch: " + branches_m[x]);`
 * - `for (size_t x(0); x < leaves_m.size(); ++x){`
 * - `if (this -> missing_trigger[leaves_m[x]]){continue;}`
 * - `this -> warning("Missing Leaves: " + leaves_m[x]);`
 * - `std::map<std::string, long> io::root_size(){ this -> scan_keys();`
 * - `this -> scan_keys();`
 * - `for (itr = this -> tree_entries.begin(); itr != this -> tree_entries.end(); ++itr){`
 * - `std::map<std::string, long>::iterator itx = itr -> second.begin();`
 * - `for (; itx != itr -> second.end(); ++itx){output[itx -> first] += itx -> second;}`
 * - `void io::root_begin(){ this -> scan_keys();`
 * - `if (this -> iters){this -> root_end();}`
 * - `std::vector<data_t*> handl = std::vector<data_t*>();`
 * - `handl.reserve(1000);`
 * - `this -> iters = new std::map<std::string, data_t*>();`
 * - `std::vector<TFile*>* vx = new std::vector<TFile*>(this -> files_open.size(), nullptr);`
 * - `for (lfi = this -> leaf_data.begin(); lfi != this -> leaf_data.end(); ++lfi){`
 * - `size_t inx = cnt.size();`
 * - `for (lfii = lf_map -> begin(); lfii != lf_map -> end(); ++lfii){`
 * - `std::vector<std::string> pth_ = this -> split(lf_name, ".");`
 * - `if (!this -> tree_entries[fname][pth_[0]]){continue;}`
 * - `if (!this -> iters -> count(lf_name)){ leaf_handl[lf_name] = handl.size();`
 * - `leaf_handl[lf_name] = handl.size();`
 * - `data_t* dt      = new data_t();`
 * - `dt -> leaf_name = pth_[pth_.size()-1];`
 * - `dt -> files_s   = new std::vector<std::string>();`
 * - `dt -> files_i   = new std::vector<long>();`
 * - `handl.push_back(dt);`
 * - `(*this -> iters)[lf_name] = nullptr;`
 * - `v -> files_s -> push_back(fname);`
 * - `v -> files_i -> push_back(this -> tree_entries[fname][v -> tree_name]);`
 * - `if (!(*vx)[inx]){(*vx)[inx] = (!inx) ? fx -> Open(fx -> GetTitle()) : fx;}`
 * - `if (v -> leaf){continue;}`
 * - `v -> initialize();`
 * - `for (size_t x(0); x < handl.size(); ++x){(*this -> iters)[handl[x] -> path] = handl[x];}`
 * - `std::map<std::string, data_t*>* io::get_data(){ if (!this -> iters){this -> root_begin();}`
 * - `if (!this -> iters){this -> root_begin();}`
 * - `void io::root_end(){ if (!this -> iters){return;}`
 * - `if (!this -> iters){return;}`
 * - `std::map<std::string, data_t*>::iterator it = this -> iters -> begin();`
 * - `for (; it != this -> iters -> end(); ++it){`
 * - `it -> second -> flush();`
 * - `if (!fx){fx = it -> second -> files_t;}`
 * - `if (fx){delete fx;}`
 * - `this -> iters -> clear();`
 */

/**
 * @section variables Variables
 *
 * - `std::string cur = this -> absolute_path("./");` (::private)
 * - `std::string tmp = std::string(dict_path) + "pcm/";` (::private)
 * - `int opx = static_cast<int>(data_enum::undef);` (::private)
 * - `int opc = this -> ls(tmp, ".pcm").size();` (::private)
 * - `std::string mta = std::string(dict_path) + "structs/include/structs/meta.h";` (::private)
 * - `std::thread* tm = nullptr;` (::private)
 * - `tm = new std::thread(buildDict, "meta_t"   , mta);` (::private)
 * - `tm = new std::thread(buildDict, "weights_t", mta);` (::private)
 * - `tm = new std::thread(buildAll);` (::private)
 * - `std::map<std::string, bool> tmp = {};` (::private)
 * - `std::map<std::string, bool>::iterator itr = this -> root_files.begin();` (::private)
 * - `int l = itr -> first.size();` (::private)
 * - `std::string last = itr -> first.substr(l - 1);` (::private)
 * - `std::vector<std::string> files = this -> ls(itr -> first.substr(0, l-1), ".root"` (::private)
 * - `for (std::string x : files){tmp[x] = true;}` (::private)
 * - `std::vector<std::string> f = this -> ls(last, ".root");` (::private)
 * - `bool found = false;` (::private)
 * - `std::string file_name = this -> file_root -> GetTitle();` (::private)
 * - `std::string name = this -> trees[x];` (::private)
 * - `if (std::string(tr -> GetName()) != name){continue;}` (::private)
 * - `this -> tree_entries[file_name][std::string(tr -> GetName())] = tr -> GetEntries` (::private)
 * - `std::string name = this -> branches[x];` (::private)
 * - `name = std::string(tr -> GetName()) + "." + std::string(br -> GetName());` (::private)
 * - `std::string name = this -> leaves[x];` (::private)
 * - `std::string name_s = std::string(tr -> GetName()) + ".";` (::private)
 * - `this -> leaf_typed[file_name][name_s] = std::string(_lf -> GetTypeName());` (::private)
 * - `name_s += std::string(br -> GetName()) + "." + std::string(_lf -> GetName());` (::private)
 * - `if (std::string(__lf -> GetName()) != name){continue;}` (::private)
 * - `std::string lx = name_s + "." + __lf -> GetName();` (::private)
 * - `this -> leaf_typed[file_name][lx] = std::string(__lf -> GetTypeName());` (::private)
 * - `std::vector<std::string> tmp = {};` (::private)
 * - `std::vector<std::string> scrape_meta_ = this -> split(this -> sow_name, ":");` (::private)
 * - `std::vector<std::vector<std::string>> scrape_meta = {};` (::private)
 * - `std::vector<std::string> tmpo = this -> split(this -> metacache_path, "/");` (::private)
 * - `std::string meta_s = tmpo[tmpo.size()-1];` (::private)
 * - `std::string updated = path + tmp[x];` (::private)
 * - `std::string fname = this -> file_root -> GetTitle();` (::private)
 * - `std::string obname = std::string(obj -> GetName());` (::private)
 * - `bool is_ttree = obj -> InheritsFrom("TTree");` (::private)
 * - `bool is_th1f  = obj -> InheritsFrom("TH1");` (::private)
 * - `bool found = true;` (::private)
 * - `std::map<std::string, TFile*>::iterator tf = this -> files_open.begin();` (::private)
 * - `std::string fname = tf -> first;` (::private)
 * - `std::map<std::string, TTree*>* tr = &this -> tree_data[fname];` (::private)
 * - `bool has = this -> has_value(&this -> keys[fname]["missed"]["Trees"], this -> tr` (::private)
 * - `std::map<std::string, TBranch*>* br = &this -> branch_data[fname];` (::private)
 * - `std::map<std::string, TBranch*>::iterator itb = br -> begin();` (::private)
 * - `std::string br_name = itb -> first;` (::private)
 * - `bool has = this -> has_value(&this -> keys[fname]["missed"]["Branches"], this ->` (::private)
 * - `std::map<std::string, TLeaf*>* lf = &this -> leaf_data[fname];` (::private)
 * - `std::map<std::string, TLeaf*>::iterator itf = lf -> begin();` (::private)
 * - `std::string lf_name = itf -> first;` (::private)
 * - `bool has = this -> has_value(&this -> keys[fname]["missed"]["Leaves"], this -> l` (::private)
 * - `std::vector<std::string> leaves_m   = this -> keys[fname]["missed"]["Leaves"];` (::private)
 * - `std::vector<std::string> branches_m = this -> keys[fname]["missed"]["Branches"];` (::private)
 * - `std::vector<std::string> trees_m    = this -> keys[fname]["missed"]["Trees"];` (::private)
 * - `long nev_ = 0;` (::private)
 * - `std::string msg = "";` (::private)
 * - `std::map<std::string, long> tree_ent = this -> tree_entries[fname];` (::private)
 * - `std::map<std::string, long>::iterator itl = tree_ent.begin();` (::private)
 * - `std::map<std::string, long> output = {};` (::private)
 * - `std::map<std::string, long>::iterator itx = itr -> second.begin();` (::private)
 * - `std::vector<data_t*> handl = std::vector<data_t*>();` (::private)
 * - `this -> iters = new std::map<std::string, data_t*>();` (::private)
 * - `std::vector<TFile*>* vx = new std::vector<TFile*>(this -> files_open.size(), nul` (::private)
 * - `std::map<std::string, size_t> leaf_handl = {};` (::private)
 * - `std::map<std::string, bool> cnt = {};` (::private)
 * - `std::string fname = lfi -> first;` (::private)
 * - `size_t inx = cnt.size();` (::private)
 * - `std::map<std::string, TLeaf*>* lf_map = &lfi -> second;` (::private)
 * - `std::string lf_name = lfii -> first;` (::private)
 * - `std::vector<std::string> pth_ = this -> split(lf_name, ".");` (::private)
 * - `dt -> files_s   = new std::vector<std::string>();` (::private)
 * - `dt -> files_i   = new std::vector<long>();` (::private)
 * - `for (size_t x(0); x < handl.size(); ++x){(*this -> iters)[handl[x] -> path] = ha` (::private)
 * - `std::map<std::string, data_t*>::iterator it = this -> iters -> begin();` (::private)
 * - `std::vector<TFile*>* fx = nullptr;` (::private)
 */

/** @} */
