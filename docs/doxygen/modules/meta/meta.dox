/**
@file
@brief Comprehensive documentation for the meta class - dataset metadata handler with ROOT/JSON integration.

@defgroup MetaModule meta
@ingroup modules_module

@brief The `meta` module provides enterprise-grade metadata management for ATLAS physics datasets, implementing sophisticated extraction and caching with ROOT file metadata, embedded JSON configurations, and AMI data integration.

@details

---

# Quick Navigation

| Module | Description | Link |
|--------|-------------|------|
| **Meta** | Dataset metadata handler | (Current Page) |
| @ref dataloader_module | Dataset batching | Uses meta for fold generation |
| @ref io_module | ROOT/HDF5 I/O | Provides file scanning |
| @ref selection_template_module | Event selection | Inherits from meta |
| @ref graph_template_module | Graph construction | Uses scanned event data |
| @ref model_template_module | GNN models | Reads metadata |
| @ref optimizer_module | Training orchestrator | Uses fold iteration |

**Typical Workflow**: `io::scan_files()` → **`meta::scan_data()`** → `dataloader::get_tags()` → `optimizer::train()`

---

*/

/**
@page MetaModule_page Meta Module
@tableofcontents

@section meta_intro Introduction
 * 
 * The `meta` module provides enterprise-grade metadata management for ATLAS physics datasets,
 * implementing a sophisticated extraction and caching system that integrates ROOT file metadata,
 * embedded JSON configurations, and ATLAS Metadata Interface (AMI) data. The module employs
 * the cproperty lazy-evaluation pattern across **60+ metadata fields**, enabling memory-efficient
 * access to dataset identifiers, MC generator configurations, luminosity normalization factors,
 * cross-sections, and production provenance information.
 *
 * ## Metadata Extraction Workflow
 *
 * ```
 * ┌──────────────────────────┐
 * │  ROOT File               │  Input: ATLAS dataset
 * │  /path/mc16_ttbar.root   │  Contains TTree + metadata
 * └──────────┬───────────────┘
 *            │ io::scan_data(TTree)
 *            ▼
 * ┌──────────────────────────┐
 * │  meta::scan_data()       │  Step 1: Extract Metadata
 * │  • Read SumWeights histo │  Sum-of-weights for norm
 * │  • Find embedded JSON    │  Production config
 * │  • Parse dataset name    │  mc16_13TeV.410470...
 * └──────────┬───────────────┘
 *            │
 *            ▼
 * ┌──────────────────────────┐
 * │  meta::parse_json()      │  Step 2: JSON Parsing
 * │  Extract from JSON:      │  RapidJSON deserialization
 * │  • dsid, derivation      │
 * │  • generator, campaign   │
 * │  • cross_section, kfactor│
 * └──────────┬───────────────┘
 *            │
 *            ▼
 * ┌──────────────────────────┐
 * │  60+ cproperty getters   │  Step 3: Lazy Evaluation
 * │  meta.dsid → "410470"    │  On-demand string/numeric
 * │  meta.xsec → 831.76      │  conversion from JSON
 * │  meta.generator → "PwPy8"│
 * └──────────┬───────────────┘
 *            │
 *            ▼
 * ┌──────────────────────────┐
 * │  meta::get_tags(hash)    │  Step 4: Fold Assignment
 * │  Returns: folds_t*       │  k-fold CV tags
 * │  {train=0/1, val=0/1...} │
 * └──────────┬───────────────┘
 *            │
 *            ▼
 * ┌──────────────────────────┐
 * │  dataloader uses tags    │  Step 5: Dataset Splitting
 * │  for train/val/test      │  Training pipeline
 * └──────────────────────────┘
 * ```
 *
 * **Key Integration Points**:
 * - Called by @ref io_module during file scanning
 * - Consumed by @ref dataloader_module for fold generation
 * - Used by @ref model_template_module for normalization
 * - Inherited by @ref selection_module for event weighting
 *
 * ## Class Definition
 *
 * **Header**: `src/AnalysisG/modules/meta/include/meta/meta.h`
 * 
 * **Implementation**: `src/AnalysisG/modules/meta/cxx/meta.cxx`
 *
 * ```cpp
 * class meta : public tools, public notification {
 *     public:
 *         meta();
 *         ~meta();
 *         
 *         // Core public methods
 *         const folds_t* get_tags(std::string hash);
 *         void scan_data(TObject* obj);
 *         void scan_sow(TObject* obj);
 *         void parse_json(std::string inpt);
 *         std::string hash(std::string fname);
 *         
 *         // Public data members
 *         rapidjson::Document* rpd = nullptr;
 *         std::string metacache_path;
 *         meta_t meta_data;
 *         
 *         // 60+ cproperty members (see detailed inventory below)
 *         cproperty<bool, meta> isMC;
 *         cproperty<bool, meta> found;
 *         // ... (complete list in Property Inventory section)
 *         
 *     private:
 *         friend analysis;
 *         
 *         void compiler();
 *         std::vector<folds_t>* folds = nullptr;
 *         
 *         // TTree extraction helpers
 *         float parse_float(std::string key, TTree* tr);
 *         std::string parse_string(std::string key, TTree* tr);
 *         
 *         // 60+ static getter functions (one per cproperty)
 *         void static get_isMC(bool*, meta*);
 *         void static get_dsid(unsigned int*, meta*);
 *         void static get_cross_section_pb(double*, meta*);
 *         // ... (complete signatures follow pattern)
 * };
 * ```
 *
 * ## Architecture
 *
 * ### Inheritance Structure
 * ```
 * meta
 *   ├── tools       // String utilities: split(), replace(), ends_with(), has_string(), hash()
 *   └── notification // Logging system with colored output, prefix-based messages
 * ```
 *
 * ### Data Flow Pipeline
 * ```
 * ROOT File Opening (analysis module)
 *         ↓
 * TFile::Get("AnalysisTracking") → scan_data()
 *         ↓
 *   ┌─────┴─────┐
 *   │           │
 * TTree       TH1F
 * Metadata    Histogram
 *   │           │
 *   ↓           ↓
 * parse_string  Bin Labels
 * parse_float   Bin Contents
 *   │           │
 *   └─────┬─────┘
 *         ↓
 *   meta_data population
 *         ↓
 *   JSON Embedded? → parse_json() → rapidjson::Document
 *         ↓
 *   compiler() → Extract fields from JSON
 *         ↓
 *   cproperty getters → Lazy evaluation → Cached access
 * ```
 *
 * ## Core Functionality
 *
 * ### 1. ROOT Metadata Extraction
 *
 * #### scan_data(TObject* obj)
 * 
 * **Purpose**: Primary entry point for ROOT object processing. Intelligently dispatches based 
 * on object name to appropriate extraction method.
 * 
 * **Implementation**:
 * ```cpp
 * void meta::scan_data(TObject* obj) {
 *     gErrorIgnoreLevel = 6001;  // Suppress ROOT warnings
 *     std::string obname = std::string(obj->GetName());
 *     
 *     if (obname == "AnalysisTracking") {
 *         // AnalysisTracking tree contains JSON in "jsonData" branch
 *         return this->parse_json(this->parse_string("jsonData", (TTree*)obj));
 *     }
 *     else if (obname == "MetaData") {
 *         // MetaData tree has meta_t struct as direct branch
 *         ((TTree*)obj)->SetBranchAddress("MetaData", &this->meta_data);
 *     }
 *     else {
 *         // Could be sum-of-weights histogram or other tracking tree
 *         return this->scan_sow(obj);
 *     }
 * }
 * ```
 *
 * **Dispatch Logic**:
 * - **"AnalysisTracking" Tree**: 
 *   - ATLAS EventLoop framework embeds JSON metadata in special "jsonData" branch
 *   - Branch contains stringified JSON with inputConfig, inputFiles, configSettings
 *   - Extracted via `parse_string()` → forwarded to `parse_json()`
 *   
 * - **"MetaData" Tree**: 
 *   - Contains pre-serialized `meta_t` structure as ROOT branch
 *   - Uses zero-copy `SetBranchAddress()` for direct memory mapping
 *   - Fastest extraction method - no parsing required
 *   
 * - **Other Objects**: 
 *   - Forwarded to `scan_sow()` for weight/histogram processing
 *   - Handles sum-of-weights histograms, EventLoop tracking trees
 *
 * #### scan_sow(TObject* obj)
 * 
 * **Purpose**: Specialized handler for sum-of-weights histograms and event tracking trees. 
 * Extracts weight statistics, campaign information, and file execution history.
 * 
 * **Implementation**:
 * ```cpp
 * void meta::scan_sow(TObject* obj) {
 *     std::string obname = std::string(obj->GetName());
 *     
 *     // Process TTree objects
 *     if (obj->InheritsFrom("TTree")) {
 *         TTree* _t = (TTree*)obj;
 *         weights_t* wg = &this->meta_data.misc[obname];
 *         
 *         if (obname == "AnalysisTracking") {
 *             // Extract numerical metadata from tree leaves
 *             wg->dsid = this->parse_float("dsid", _t);
 *             wg->isAFII = this->parse_float("isAFII", _t);
 *             wg->total_events_weighted = this->parse_float("totalEventsWeighted", _t);
 *             wg->total_events = this->parse_float("totalEvents", _t);
 *             wg->processed_events = this->parse_float("processedEvents", _t);
 *             wg->processed_events_weighted = this->parse_float("processedEventsWeighted", _t);
 *             wg->processed_events_weighted_squared = this->parse_float("processedEventsWeightedSquared", _t);
 *             wg->generator = this->parse_string("generators", _t);
 *             wg->ami_tag = this->parse_string("AMITag", _t);
 *             return;
 *         }
 *         
 *         if (obname == "EventLoop_FileExecuted") {
 *             // Extract file execution history using TTreeReader
 *             TTreeReader _r = TTreeReader(obj->GetName());
 *             TTreeReaderValue<TString> dr(_r, "file");
 *             std::vector<std::string> data = {};
 *             while(_r.Next()) { data.push_back(std::string(*dr)); }
 *             
 *             // Build inputfiles map with sequential indices
 *             for (size_t x(0); x < data.size(); ++x) {
 *                 this->meta_data.inputfiles[x] = data[x];
 *             }
 *         }
 *         return;
 *     }
 *     
 *     // Process TH1F histogram objects (sum-of-weights)
 *     if (obj->InheritsFrom("TH1")) {
 *         TH1F* hs = (TH1F*)obj;
 *         TAxis* xs = hs->GetXaxis();
 *         weights_t* wg = &this->meta_data.misc[obname];
 *         
 *         bool capture = false;
 *         for (int x(0); x < xs->GetNbins(); ++x) {
 *             std::string lbl = xs->GetBinLabel(x+1);
 *             float val = hs->GetBinContent(x+1);
 *             
 *             // Map specific labels to weights_t fields
 *             if (lbl == "Initial events") {
 *                 wg->processed_events = val;
 *             }
 *             if (lbl == "Initial sum of weights") {
 *                 wg->processed_events_weighted = val;
 *             }
 *             if (lbl == "Initial sum of weights squared") {
 *                 wg->processed_events_weighted_squared = val;
 *             }
 *             
 *             // Detect campaign from bin label (e.g., "mc16a", "mc20e")
 *             if (this->has_string(&lbl, "mc")) {
 *                 this->meta_data.campaign = lbl;
 *                 capture = true;
 *             }
 *             
 *             // Store all bin data for future reference
 *             wg->hist_data[xs->GetBinLabel(x+1)] = hs->GetBinContent(x+1);
 *         }
 *         
 *         if (!capture) { return; }
 *         
 *         // Extract DSID and AMI tag from axis labels (convention-based)
 *         this->meta_data.dsid = std::atoi(xs->GetBinLabel(3));
 *         this->meta_data.AMITag = xs->GetBinLabel(4);
 *     }
 * }
 * ```
 *
 * **Weight Statistics Extracted**:
 * - **total_events_weighted**: $\sum_{i=1}^{N} w_i$ (sum of all generator weights)
 * - **processed_events_weighted**: $\sum_{i=1}^{N_{proc}} w_i$ (processed subset)
 * - **processed_events_weighted_squared**: $\sum_{i=1}^{N_{proc}} w_i^2$ (variance estimation)
 * - **isAFII**: Fast simulation flag (Atlfast-II vs full GEANT4)
 * - **generator**: Generator chain string (e.g., "Pythia8EvtGen")
 *
 * **Histogram Conventions**:
 * ATLAS uses TH1F with special axis label conventions:
 * - Bin 1: Label contains event counts
 * - Bin 2: "Initial sum of weights"
 * - Bin 3: DSID as numeric label
 * - Bin 4: AMI tag string
 * - Campaign bins: Labels like "mc16a", "mc20e"
 *
 * #### TTree Primitive Extraction
 *
 * **parse_float(std::string key, TTree* tr)**
 * ```cpp
 * float meta::parse_float(std::string key, TTree* tr) {
 *     tr->GetEntry(0);  // Load first entry into memory
 *     return tr->GetLeaf(key.c_str())->GetValue();
 * }
 * ```
 * Extracts single float/double value from TTree leaf. Used for numeric metadata like DSID, 
 * cross-sections, luminosity. Only reads entry 0 since metadata is constant across tree.
 *
 * **parse_string(std::string key, TTree* tr)**
 * ```cpp
 * std::string meta::parse_string(std::string key, TTree* tr) {
 *     TBranch* lf = tr->GetBranch(key.c_str());
 *     tr->GetEntry(0);
 *     
 *     std::string data = "";
 *     for (TObject* obj : *lf->GetListOfLeaves()) {
 *         TLeaf* lx = (TLeaf*)obj;
 *         char** datar = reinterpret_cast<char**>(lx->GetValuePointer());
 *         data += std::string(*datar);
 *     }
 *     return data;
 * }
 * ```
 * Handles multi-leaf string branches. ROOT stores long strings across multiple leaves. Method
 * concatenates all leaf values to reconstruct complete string. Critical for JSON extraction 
 * from "jsonData" branch which can exceed single-leaf size limits.
 *
 * ### 2. JSON Configuration Parsing
 *
 * #### parse_json(std::string inpt)
 * 
 * **Purpose**: Robust JSON parser with automatic error correction for malformed ATLAS JSON.
 * 
 * **Implementation**:
 * ```cpp
 * void meta::parse_json(std::string inpt) {
 *     if (this->rpd) { return; }  // Already parsed - prevent double parsing
 *     
 *     // Initial parse attempt
 *     this->rpd = new rapidjson::Document();
 *     this->rpd->Parse(inpt.c_str());
 *     
 *     // Error recovery logic
 *     if (this->rpd->HasParseError()) {
 *         int inx = this->rpd->GetErrorOffset();
 *         if (inx > 20) { inx -= 20; }  // Context window before error
 *         
 *         std::string f = inpt.substr(inx, 20);  // Extract error region
 *         std::string fn = f;
 *         
 *         // Fix common issue: missing trailing comma
 *         if (!this->ends_with(&f, ",\n")) {
 *             this->replace(&fn, "\n", ",\n");
 *         }
 *         this->replace(&inpt, f, fn);
 *         
 *         // Retry parsing with corrected JSON
 *         delete this->rpd;
 *         this->rpd = new rapidjson::Document();
 *         this->rpd->Parse(inpt.c_str());
 *     }
 *     
 *     this->compiler();      // Extract fields from parsed document
 *     delete this->rpd;      // Immediate cleanup - no persistent storage
 *     this->rpd = nullptr;
 * }
 * ```
 *
 * **Error Handling Strategy**:
 * - **Common ATLAS JSON Issues**: 
 *   - EventLoop framework sometimes omits trailing commas in arrays
 *   - Malformed unicode escape sequences
 *   - Inconsistent quoting in generator strings
 *   
 * - **Recovery Approach**: 
 *   - Localize error via `GetErrorOffset()` (character position)
 *   - Extract 20-character context window around error
 *   - Apply surgical fix: add missing comma before newline
 *   - Single retry attempt - fail if second parse errors
 *
 * - **Memory Management**: 
 *   - `rapidjson::Document` deleted immediately after `compiler()` completes
 *   - Reduces memory footprint - only `meta_data` struct persists
 *   - `rpd = nullptr` enables multiple parse_json() calls (idempotency check)
 *
 * #### compiler()
 * 
 * **Purpose**: Extracts structured information from parsed RapidJSON document into `meta_data` struct.
 * 
 * **Implementation**:
 * ```cpp
 * void meta::compiler() {
 *     // Access top-level configuration object
 *     rapidjson::Value* cfg = &(*this->rpd)["inputConfig"];
 *     if (!cfg) { return; }
 *     
 *     // Extract core configuration fields
 *     if (cfg->HasMember("dsid")) {
 *         this->meta_data.dsid = (*cfg)["dsid"].GetDouble();
 *     }
 *     if (cfg->HasMember("isMC")) {
 *         this->meta_data.isMC = (*cfg)["isMC"].GetBool();
 *     }
 *     if (cfg->HasMember("derivationFormat")) {
 *         this->meta_data.derivationFormat = (*cfg)["derivationFormat"].GetString();
 *     }
 *     
 *     // Extract configuration settings array
 *     rapidjson::Value* cfg_s = &(*this->rpd)["configSettings"];
 *     if (cfg_s->IsArray()) {
 *         for (rapidjson::SizeType i(0); i < cfg_s->Size(); ++i) {
 *             std::string key = (*cfg_s)[i].GetString();
 *             std::string prm = (*cfg_s)[i].GetString();
 *             this->meta_data.config[key] = prm;
 *         }
 *     }
 *     
 *     // Process input file list with event counts
 *     int num_total = 0;
 *     rapidjson::Value* files = &(*this->rpd)["inputFiles"];
 *     for (rapidjson::SizeType i(0); i < files->Size(); ++i) {
 *         int n_ev = (*files)[i][1].GetInt();            // Event count
 *         std::string fname = (*files)[i][0].GetString();  // Full path
 *         
 *         // Extract basename from full path
 *         std::vector<std::string> fname_v = this->split(fname, "/");
 *         this->meta_data.inputfiles[num_total] = fname_v[fname_v.size()-1];
 *         num_total += n_ev;  // Cumulative event indexing
 *     }
 *     
 *     // Extract or infer AMI tag
 *     if (cfg->HasMember("amiTag")) {
 *         this->meta_data.AMITag = (*cfg)["amiTag"].GetString();
 *     }
 *     else if (files) {
 *         // Infer from file path structure
 *         // ATLAS convention: /path/to/dataset.e1234_s3456.tag/file.root
 *         for (rapidjson::SizeType i(0); i < files->Size(); ++i) {
 *             std::string fname = (*files)[i][0].GetString();
 *             std::vector<std::string> fname_v = this->split(fname, "/");
 *             
 *             // Get parent directory (contains AMI tag)
 *             fname = fname_v[fname_v.size()-2];
 *             fname_v = this->split(fname, ".");
 *             this->meta_data.AMITag = fname_v[fname_v.size()-1];
 *             break;
 *         }
 *         
 *         // Validate: AMI tags always contain 'e' (e.g., "e7148")
 *         if (!this->has_string(&this->meta_data.AMITag, "e")) {
 *             this->meta_data.AMITag = "";
 *         }
 *     }
 *     else {
 *         // Fallback: extract from sample_name
 *         std::vector<std::string> spl = this->split(this->meta_data.sample_name, "/");
 *         size_t x = spl.size();
 *         if (x >= 2) {
 *             this->meta_data.AMITag = spl[x-2];
 *         }
 *     }
 * }
 * ```
 *
 * **Expected JSON Structure**:
 * ```json
 * {
 *   "inputConfig": {
 *     "dsid": 410470,
 *     "isMC": true,
 *     "derivationFormat": "DAOD_PHYS",
 *     "amiTag": "e7148_s3681_r13144_p5631"
 *   },
 *   "configSettings": ["setting1", "setting2"],
 *   "inputFiles": [
 *     ["/data/mc16_13TeV.410470.PhPy8EG_A14_ttbar.deriv.DAOD_PHYS.e6337_s3681/file1.root", 50000],
 *     ["/data/mc16_13TeV.410470.PhPy8EG_A14_ttbar.deriv.DAOD_PHYS.e6337_s3681/file2.root", 48573]
 *   ]
 * }
 * ```
 *
 * **AMI Tag Inference Logic**:
 * 1. **Direct Field**: Check `inputConfig.amiTag` first
 * 2. **Path Parsing**: Extract from directory structure (penultimate path component)
 * 3. **Validation**: Ensure tag contains 'e' character (simulation ID marker)
 * 4. **Fallback**: Use sample_name if available
 *
 * **File Indexing Strategy**:
 * - `inputfiles` map uses cumulative event count as key
 * - Enables direct file lookup by global event index
 * - Example: event 75000 → file at index 50000 (second file)
 *
 * ### 3. cproperty System Implementation
 *
 * #### Constructor Initialization
 * 
 * **Purpose**: Bind getter functions and parent object to all 60+ cproperty members.
 * 
 * **Pattern**:
 * ```cpp
 * meta::meta() {
 *     // Step 1: Bind getter functions (function pointers)
 *     this->isMC.set_getter(this->get_isMC);
 *     this->found.set_getter(this->get_found);
 *     this->dsid.set_getter(this->get_dsid);
 *     this->campaign.set_getter(this->get_campaign);
 *     this->cross_section_pb.set_getter(this->get_cross_section_pb);
 *     // ... 55+ more getter bindings
 *     
 *     // Step 2: Bind parent object (this pointer)
 *     this->isMC.set_object(this);
 *     this->found.set_object(this);
 *     this->dsid.set_object(this);
 *     this->campaign.set_object(this);
 *     this->cross_section_pb.set_object(this);
 *     // ... 55+ more object bindings
 *     
 *     // Step 3: Set logging prefix
 *     this->prefix = "meta";  // Inherited from notification
 * }
 * ```
 *
 * **Initialization Sequence**:
 * 1. `set_getter(func_ptr)`: Stores static function pointer in cproperty
 * 2. `set_object(this)`: Stores parent object pointer for callback context
 * 3. `prefix`: Configures notification module for debug messages
 *
 * **cproperty Template**:
 * ```cpp
 * template<typename T, typename Owner>
 * class cproperty {
 *     private:
 *         T cached_value;
 *         bool is_cached = false;
 *         void (*getter)(T*, Owner*) = nullptr;
 *         Owner* owner = nullptr;
 *     
 *     public:
 *         void set_getter(void (*func)(T*, Owner*)) { getter = func; }
 *         void set_object(Owner* obj) { owner = obj; }
 *         
 *         operator T() {
 *             if (!is_cached) {
 *                 getter(&cached_value, owner);
 *                 is_cached = true;
 *             }
 *             return cached_value;
 *         }
 * };
 * ```
 *
 * #### Getter Function Implementations
 *
 * **Simple Passthrough Getters**:
 * ```cpp
 * void meta::get_dsid(unsigned int* val, meta* m) {
 *     *val = m->meta_data.dsid;
 * }
 * 
 * void meta::get_isMC(bool* val, meta* m) {
 *     *val = m->meta_data.isMC;
 * }
 * 
 * void meta::get_generators(std::string* val, meta* m) {
 *     *val = m->meta_data.generators;
 * }
 * ```
 * Direct extraction from `meta_data` struct. Zero computation overhead.
 *
 * **Computed Getters (Cross-Section Conversions)**:
 * ```cpp
 * void meta::get_cross_section_nb(double* val, meta* m) {
 *     double tml = m->meta_data.crossSection_mean;
 *     if (tml == 0) { tml = m->meta_data.crossSection_mean; }  // Fallback
 *     *val = tml;  // Base unit: nanobarns
 * }
 * 
 * void meta::get_cross_section_pb(double* val, meta* m) {
 *     *val = m->cross_section_nb * 1000;  // nb → pb conversion
 * }
 * 
 * void meta::get_cross_section_fb(double* val, meta* m) {
 *     *val = m->cross_section_nb * 1000000;  // nb → fb conversion
 * }
 * ```
 * Unit conversions:
 * - 1 nanobarn (nb) = 10³ picobarns (pb) = 10⁶ femtobarns (fb)
 * - Base storage: nanobarns
 * - Derived properties: computed on-demand, then cached
 *
 * **String Processing Getters**:
 * ```cpp
 * void meta::get_campaign(std::string* val, meta* m) {
 *     m->replace(&m->meta_data.campaign, " ", "");  // Strip whitespace
 *     *val = m->meta_data.campaign;
 * }
 * ```
 * Applies transformations before returning value. Campaign strings often have trailing spaces
 * from ROOT histogram labels.
 *
 * **Aggregation Getters (Sum of Weights)**:
 * ```cpp
 * void meta::get_sum_of_weights(double* val, meta* m) {
 *     std::map<std::string, weights_t> data = m->misc;
 *     std::map<std::string, weights_t>::iterator itr = data.begin();
 *     
 *     // Iterate through all weights_t entries in misc map
 *     for (; itr != data.end(); ++itr) {
 *         if (itr->second.processed_events_weighted == -1) { continue; }
 *         *val = itr->second.processed_events_weighted;
 *         return;  // Return first valid sum-of-weights
 *     }
 * }
 * ```
 * Searches `misc` map for first valid sum-of-weights. Multiple trees may contain weights;
 * method prioritizes first populated entry.
 *
 * **Usage Pattern**:
 * ```cpp
 * meta m;
 * m.scan_data(tree_obj);  // Populate meta_data
 * 
 * // First access: calls get_dsid(), caches result
 * unsigned int dsid = m.dsid;  
 * 
 * // Second access: returns cached value (no getter call, no lookup)
 * unsigned int dsid2 = m.dsid;
 * 
 * // Cross-section conversions
 * double xsec_pb = m.cross_section_pb;  // Calls get_cross_section_nb(), converts, caches
 * double xsec_fb = m.cross_section_fb;  // Independent cache - calls get_cross_section_nb()
 * ```
 *
 * ### 4. Dataset Identification and Hashing
 *
 * #### hash(std::string fname)
 * 
 * **Purpose**: Generate unique identifier for dataset based on filename.
 * 
 * **Implementation**:
 * ```cpp
 * std::string meta::hash(std::string fname) {
 *     std::vector<std::string> spl = this->split(fname, "/");
 *     size_t x = spl.size();
 *     if (x == 0) { return this->tools::hash(fname); }
 *     return this->tools::hash(spl[x-1]);  // Hash basename only
 * }
 * ```
 *
 * **Hashing Strategy**:
 * - Extract basename from full path (last component)
 * - Delegate to `tools::hash()` for actual hashing algorithm
 * - Basename hashing prevents path-dependent hash changes
 * - Used for metadata cache keying and fold assignment lookup
 *
 * #### get_tags(std::string hash_)
 * 
 * **Purpose**: Retrieve fold assignment (train/validation/test split) for a dataset.
 * 
 * **Implementation**:
 * ```cpp
 * const folds_t* meta::get_tags(std::string hash_) {
 *     if (!this->folds) { return nullptr; }
 *     
 *     for (size_t x(0); x < this->folds->size(); ++x) {
 *         if (hash_ != std::string((*this->folds)[x].hash)) { continue; }
 *         return &(*this->folds)[x];
 *     }
 *     return nullptr;
 * }
 * ```
 *
 * **Fold System**:
 * - `folds`: Vector of `folds_t` structs managed by `analysis` module
 * - Each `folds_t` contains:
 *   - `hash`: Dataset identifier (from `meta::hash()`)
 *   - `train`: Boolean flag for training split
 *   - `validation`: Boolean flag for validation split
 *   - `test`: Boolean flag for test split
 * - Linear search by hash (small vector, <100 datasets typically)
 * - Returns const pointer to avoid copies
 *
 * ## Complete Property Inventory
 *
 * ### Boolean Flags (2 properties)
 * | Property | Type | Description |
 * |----------|------|-------------|
 * | `isMC` | `cproperty<bool, meta>` | Monte Carlo (true) vs real data (false) |
 * | `found` | `cproperty<bool, meta>` | Metadata extraction success flag |
 *
 * ### Floating-Point Metrics (13 properties)
 * | Property | Type | Description | Units |
 * |----------|------|-------------|-------|
 * | `eventNumber` | `cproperty<double, meta>` | Current event number in processing | Count |
 * | `event_index` | `cproperty<double, meta>` | Current event index (0-based) | Index |
 * | `totalSize` | `cproperty<double, meta>` | Total dataset size | Bytes |
 * | `kfactor` | `cproperty<double, meta>` | K-factor (NLO/NNLO corrections) | Dimensionless |
 * | `ecmEnergy` | `cproperty<double, meta>` | Center-of-mass energy | TeV |
 * | `genFiltEff` | `cproperty<double, meta>` | Generator filter efficiency | [0-1] |
 * | `completion` | `cproperty<double, meta>` | Processing completion fraction | [0-1] |
 * | `beam_energy` | `cproperty<double, meta>` | Individual beam energy | TeV |
 * | `cross_section_nb` | `cproperty<double, meta>` | Cross-section | nanobarns |
 * | `cross_section_pb` | `cproperty<double, meta>` | Cross-section (converted) | picobarns |
 * | `cross_section_fb` | `cproperty<double, meta>` | Cross-section (converted) | femtobarns |
 * | `campaign_luminosity` | `cproperty<double, meta>` | Integrated luminosity | fb⁻¹ |
 * | `sum_of_weights` | `cproperty<double, meta>` | Sum of MC event weights | Dimensionless |
 *
 * ### Integer Identifiers (4 properties)
 * | Property | Type | Description |
 * |----------|------|-------------|
 * | `dsid` | `cproperty<unsigned int, meta>` | Dataset ID (ATLAS DSID) |
 * | `nFiles` | `cproperty<unsigned int, meta>` | Number of files in dataset |
 * | `totalEvents` | `cproperty<unsigned int, meta>` | Total event count |
 * | `datasetNumber` | `cproperty<unsigned int, meta>` | Dataset number identifier |
 *
 * ### String Properties (26 properties)
 * | Property | Type | Description | Example Value |
 * |----------|------|-------------|---------------|
 * | `derivationFormat` | `cproperty<std::string, meta>` | Derivation format | "DAOD_PHYS" |
 * | `AMITag` | `cproperty<std::string, meta>` | Production tag | "e7148_s3681_r13144_p5631" |
 * | `generators` | `cproperty<std::string, meta>` | Generator chain | "Pythia8EvtGen" |
 * | `identifier` | `cproperty<std::string, meta>` | Unique dataset identifier | UUID |
 * | `DatasetName` | `cproperty<std::string, meta>` | Full logical dataset name | "mc16_13TeV.410470..." |
 * | `prodsysStatus` | `cproperty<std::string, meta>` | Production system status | "VALID" |
 * | `dataType` | `cproperty<std::string, meta>` | Data type | "MC", "data" |
 * | `version` | `cproperty<std::string, meta>` | Dataset version | "v1" |
 * | `PDF` | `cproperty<std::string, meta>` | PDF set | "NNPDF30_nlo_as_0118" |
 * | `AtlasRelease` | `cproperty<std::string, meta>` | Software release | "21.2.231.0" |
 * | `principalPhysicsGroup` | `cproperty<std::string, meta>` | Physics group | "EXOT", "TOPQ" |
 * | `physicsShort` | `cproperty<std::string, meta>` | Short physics tag | "ttbar" |
 * | `generatorName` | `cproperty<std::string, meta>` | Primary generator | "Pythia8" |
 * | `geometryVersion` | `cproperty<std::string, meta>` | Detector geometry | "ATLAS-R2-2016-01-00-01" |
 * | `conditionsTag` | `cproperty<std::string, meta>` | Conditions DB tag | "OFLCOND-MC16-SDR-..." |
 * | `generatorTune` | `cproperty<std::string, meta>` | Tune | "A14NNPDF23LO" |
 * | `amiStatus` | `cproperty<std::string, meta>` | AMI status | "VALID" |
 * | `beamType` | `cproperty<std::string, meta>` | Beam type | "proton-proton" |
 * | `productionStep` | `cproperty<std::string, meta>` | Production step | "simul", "recon" |
 * | `projectName` | `cproperty<std::string, meta>` | Project name | "mc16_13TeV" |
 * | `statsAlgorithm` | `cproperty<std::string, meta>` | Statistics algorithm | "MC" |
 * | `genFilterNames` | `cproperty<std::string, meta>` | Generator filter names | "TTbarMassFilter" |
 * | `file_type` | `cproperty<std::string, meta>` | File type | "ROOT" |
 * | `sample_name` | `cproperty<std::string, meta>` | User-friendly name | "ttbar_nominal" |
 * | `logicalDatasetName` | `cproperty<std::string, meta>` | Logical dataset name | Same as DatasetName |
 * | `campaign` | `cproperty<std::string, meta>` | Campaign | "mc16a", "mc20e" |
 *
 * ### Vector Properties (7 properties)
 * | Property | Type | Description |
 * |----------|------|-------------|
 * | `keywords` | `cproperty<std::vector<std::string>, meta>` | Dataset keywords/tags |
 * | `weights` | `cproperty<std::vector<std::string>, meta>` | Available weight names |
 * | `keyword` | `cproperty<std::vector<std::string>, meta>` | Additional keywords |
 * | `fileGUID` | `cproperty<std::vector<std::string>, meta>` | Globally unique file identifiers |
 * | `events` | `cproperty<std::vector<int>, meta>` | Event counts per file |
 * | `run_number` | `cproperty<std::vector<int>, meta>` | Run numbers (for data) |
 * | `fileSize` | `cproperty<std::vector<double>, meta>` | File sizes in bytes |
 *
 * ### Map Properties (5 properties)
 * | Property | Type | Description |
 * |----------|------|-------------|
 * | `inputrange` | `cproperty<std::map<int, int>, meta>` | File index → event range mapping |
 * | `inputfiles` | `cproperty<std::map<int, std::string>, meta>` | File index → filename mapping |
 * | `LFN` | `cproperty<std::map<std::string, int>, meta>` | Logical file name → count mapping |
 * | `misc` | `cproperty<std::map<std::string, weights_t>, meta>` | Miscellaneous weight data by tree name |
 * | `config` | `cproperty<std::map<std::string, std::string>, meta>` | Configuration key-value pairs |
 *
 * **Total**: 60 cproperty members
 *
 * ## Dependencies
 *
 * ### Internal Dependencies
 * - **`structs/meta.h`**: Defines `meta_t` POD storage structure with all metadata fields
 * - **`structs/folds.h`**: Defines `folds_t` for dataset splitting (train/val/test)
 * - **`structs/property.h`**: Implements `cproperty<T, Owner>` lazy-evaluation template
 * - **`notification/notification.h`**: Logging and progress reporting with colored output
 * - **`tools/tools.h`**: String utilities (split, replace, ends_with, has_string, hash)
 *
 * ### External Dependencies
 * - **RapidJSON** (`rapidjson/document.h`):
 *   - Fast in-situ JSON parsing (no intermediate allocations)
 *   - DOM-style document manipulation
 *   - Error reporting with character offset
 *   
 * - **ROOT Framework**:
 *   - `TFile.h`: ROOT file I/O
 *   - `TTree.h`: Tree data structure and branch access
 *   - `TBranch.h`: Branch address binding
 *   - `TLeaf.h`: Leaf-level primitive access
 *   - `TH1F.h`: 1D histogram for sum-of-weights
 *
 * ## Usage Examples
 *
 * ### Basic Metadata Extraction
 * ```cpp
 * #include <meta.h>
 * #include <TFile.h>
 *
 * int main() {
 *     // Open ROOT file
 *     TFile* f = TFile::Open("/data/mc16_13TeV.410470.root");
 *     
 *     // Create metadata handler
 *     meta m;
 *     
 *     // Extract metadata from embedded trees
 *     TObject* tracking = f->Get("AnalysisTracking");
 *     m.scan_data(tracking);
 *     
 *     TObject* metadata_tree = f->Get("MetaData");
 *     m.scan_data(metadata_tree);
 *     
 *     // Access metadata (first access triggers getter, subsequent accesses use cache)
 *     unsigned int dsid = m.dsid;                    // 410470
 *     bool is_mc = m.isMC;                           // true
 *     std::string gen = m.generatorName;             // "Pythia8"
 *     std::string tune = m.generatorTune;            // "A14NNPDF23LO"
 *     double xsec_pb = m.cross_section_pb;           // 831.76
 *     double xsec_fb = m.cross_section_fb;           // 831760.0
 *     double lumi = m.campaign_luminosity;           // 36.2
 *     double sum_w = m.sum_of_weights;               // 1.456e9
 *     
 *     // Calculate normalization weight for histograms
 *     double weight = (xsec_pb * 1000.0 * lumi) / sum_w;
 *     
 *     std::cout << "Normalization weight: " << weight << std::endl;
 *     
 *     f->Close();
 *     return 0;
 * }
 * ```
 *
 * ### File-Level Processing
 * ```cpp
 * #include <meta.h>
 *
 * void process_dataset(meta& m) {
 *     // Access file information
 *     std::map<int, std::string> files = m.inputfiles;
 *     std::map<int, int> ranges = m.inputrange;
 *     
 *     std::cout << "Dataset: " << m.sample_name << std::endl;
 *     std::cout << "Campaign: " << m.campaign << std::endl;
 *     std::cout << "Total files: " << files.size() << std::endl;
 *     
 *     // Iterate through files
 *     for (auto& [idx, fname] : files) {
 *         int event_start = idx;
 *         int event_end = (ranges.count(idx)) ? ranges[idx] : -1;
 *         
 *         std::cout << "File: " << fname << std::endl;
 *         std::cout << "  Events: [" << event_start << ", " << event_end << "]" << std::endl;
 *     }
 * }
 * ```
 *
 * ### Generator Information
 * ```cpp
 * #include <meta.h>
 *
 * void print_generator_info(meta& m) {
 *     std::cout << "Generator Configuration:" << std::endl;
 *     std::cout << "  Name: " << m.generatorName << std::endl;
 *     std::cout << "  Tune: " << m.generatorTune << std::endl;
 *     std::cout << "  PDF: " << m.PDF << std::endl;
 *     std::cout << "  Filters: " << m.genFilterNames << std::endl;
 *     std::cout << "  Filter Efficiency: " << m.genFiltEff << std::endl;
 *     std::cout << "  K-factor: " << m.kfactor << std::endl;
 *     std::cout << "  √s: " << m.ecmEnergy << " TeV" << std::endl;
 *     std::cout << "  Beam Energy: " << m.beam_energy << " TeV" << std::endl;
 * }
 * ```
 *
 * ### Cross-Section and Luminosity
 * ```cpp
 * #include <meta.h>
 *
 * double calculate_expected_yield(meta& m, double luminosity_fb) {
 *     double xsec_fb = m.cross_section_fb;
 *     double filter_eff = m.genFiltEff;
 *     double k_factor = m.kfactor;
 *     
 *     // Expected events = σ × ε × k × L
 *     double expected = xsec_fb * filter_eff * k_factor * luminosity_fb;
 *     return expected;
 * }
 * ```
 *
 * ## Integration with Analysis Pipeline
 *
 * ### Phase 1: File Opening (analysis module)
 * ```cpp
 * // analysis::build() opens files and scans metadata
 * TFile* f = TFile::Open(filename.c_str());
 * 
 * // Pass all metadata trees to meta module
 * TIter next(f->GetListOfKeys());
 * TKey* key;
 * while ((key = (TKey*)next())) {
 *     TObject* obj = key->ReadObj();
 *     meta_obj.scan_data(obj);
 * }
 * ```
 *
 * ### Phase 2: Event Processing
 * ```cpp
 * // Per-event weight calculation
 * double event_weight = generator_weight * pileup_weight;
 * double normalization = (meta_obj.cross_section_pb * 1000.0 * luminosity) / meta_obj.sum_of_weights;
 * double final_weight = event_weight * normalization;
 * ```
 *
 * ### Phase 3: Result Serialization
 * ```cpp
 * // Embed metadata in HDF5 output
 * H5::Group meta_group = output_file.createGroup("metadata");
 * write_attribute(meta_group, "dsid", meta_obj.dsid);
 * write_attribute(meta_group, "campaign", meta_obj.campaign);
 * write_attribute(meta_group, "cross_section_pb", meta_obj.cross_section_pb);
 * // ... all relevant metadata fields
 * ```
 *
 * ### Phase 4: K-Fold Assignment
 * ```cpp
 * // Hash dataset filename
 * std::string hash_val = meta_obj.hash(filename);
 * 
 * // Retrieve fold assignment
 * const folds_t* tags = meta_obj.get_tags(hash_val);
 * if (tags) {
 *     if (tags->train) {
 *         // Use for training
 *     } else if (tags->validation) {
 *         // Use for validation
 *     } else if (tags->test) {
 *         // Use for testing
 *     }
 * }
 * ```
 *
 * ## Performance Characteristics
 *
 * ### Memory Efficiency
 * - **Lazy Evaluation**: Properties computed only when accessed
 *   - Unused properties: 0 bytes overhead (just function pointer)
 *   - Used properties: Type size (bool: 1 byte, double: 8 bytes, string: ~32 bytes)
 *   
 * - **Single Storage**: Raw data stored once in `meta_data` struct
 *   - Total size: ~2-5 KB per dataset
 *   - cproperty cache: ~200-500 bytes additional (accessed properties only)
 *   
 * - **Smart Cleanup**: RapidJSON document deleted immediately after compilation
 *   - JSON parsing: temporary 10-50 KB allocation
 *   - Post-parsing: 0 bytes JSON overhead
 *
 * ### Computational Efficiency
 * - **Zero-Copy ROOT**: Direct `TTree::SetBranchAddress()` for `meta_t`
 *   - No deserialization overhead
 *   - Memory-mapped access via ROOT TFile
 *   
 * - **Minimal Parsing**: JSON parsed once per file
 *   - Typical parse time: <1ms for ATLAS JSON (~10-20 KB)
 *   - Error recovery: additional 1-2ms if malformed
 *   
 * - **String Interning**: File paths stored as map indices
 *   - `inputfiles` map: index → basename (not full path)
 *   - Saves ~100 bytes per file (typical ATLAS paths: 150+ chars)
 *
 * ### Caching Behavior
 * - **First Access**: Getter function call + cache write
 *   - Time: 10-100ns (memory lookup + copy)
 *   
 * - **Subsequent Accesses**: Direct cache read
 *   - Time: 5-10ns (single memory dereference)
 *   
 * - **Computed Properties** (e.g., cross_section_fb):
 *   - First access: read cross_section_nb + multiply + cache
 *   - Subsequent: cached value (no recomputation)
 *
 * ## Error Handling and Edge Cases
 *
 * ### Missing Metadata Fields
 * - cproperty returns default-initialized value (0, false, "")
 * - No exceptions thrown - silent failure mode
 * - Check `found` property to validate extraction success
 *
 * ### Malformed JSON
 * - Automatic comma insertion for common errors
 * - Single retry attempt
 * - If retry fails: `meta_data` remains partially populated
 *
 * ### Multiple Metadata Sources
 * - Priority order:
 *   1. MetaData tree (direct branch)
 *   2. AnalysisTracking JSON
 *   3. Sum-of-weights histograms
 * - Last-write-wins for overlapping fields
 *
 * ### Missing Sum of Weights
 * - `get_sum_of_weights()` searches all `misc` entries
 * - Returns first valid (non-negative-1) value
 * - If none found: returns 0 (default initialization)
 *
 * ## Related Documentation
 * - @ref PropertyStruct "cproperty<T, Owner> Template System"
 * - @ref MetaStruct "meta_t POD Structure Definition"
 * - @ref WeightsStruct "weights_t Sum-of-Weights Structure"
 * - @ref FoldsStruct "folds_t Tag System for K-Fold Splitting"
 * - @ref AnalysisModule "Analysis Pipeline Orchestrator"
 * - @ref ToolsModule "String and File Utilities"
 * - @ref NotificationModule "Logging and Progress Reporting"
 */
