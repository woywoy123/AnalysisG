/**
 * @file link.cxx
 * @brief Documentation for modules/metric/cxx/link.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/metric/cxx/link.cxx
 */

/**
 * @defgroup modules_metric_cxx_link_cxx link.cxx
 * @brief link.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `bool metric_template::link(model_template* mdl){ std::string mdlx = mdl -> name;`
 * - `if (this -> lnks.count(mdlx)){return true;}`
 * - `if (!this -> _var_type.count(mdlx)){ this -> failure("Invalid Variable ModelName. Got " + mdlx + " e`
 * - `this -> failure("Invalid Variable ModelName. Got " + mdlx + " expected:");`
 * - `for (itx = this -> _var_type.begin(); itx != this -> _var_type.end(); ++itx){this -> failure("Model:`
 * - `if (!this -> _epoch_kfold.count(mdlx)){ this -> failure("Invalid RunName ModelName. Got " + mdlx + "`
 * - `this -> failure("Invalid RunName ModelName. Got " + mdlx + " expected:");`
 * - `for (itx = this -> _epoch_kfold.begin(); itx != this -> _epoch_kfold.end(); ++itx){this -> failure("`
 * - `this -> info("Linking Model: " + mdlx + " to metric: " + std::string(this -> name));`
 * - `if (!ok){return ok;}`
 * - `std::string dx_hx = std::to_string(mdl -> m_option -> device().index()) + "+";`
 * - `std::map<int, std::map<int, std::string>>::iterator ite = this -> _epoch_kfold[mdlx].begin();`
 * - `for (; ite != this -> _epoch_kfold[mdlx].end(); ++ite){`
 * - `std::map<int, std::string>::iterator itk = ite -> second.begin();`
 * - `for (; itk != ite -> second.end(); ++itk){`
 * - `std::string hx = this -> hash(dx_hx + std::to_string(itk -> first));`
 * - `if (this -> hash_mdl.count(hx)){continue;}`
 * - `this -> hash_mdl[hx].push_back(mdl);`
 * - `void metric_template::link(std::string hsx, std::vector<graph_t*>* data, mode_enum mx){ if (this -> `
 * - `if (this -> hash_bta.count(hsx) && this -> hash_bta[hsx].count(mx)){return;}`
 * - `void metric_template::flush_garbage(){ std::map<std::string, std::vector<particle_template*>>::itera`
 * - `for (itr = this -> garbage.begin(); itr != this -> garbage.end(); ++itr){`
 * - `for (size_t x(0); x < itr -> second.size(); ++x){`
 * - `if (!itr -> second[x] -> _is_marked){continue;}`
 * - `itr -> second.clear();`
 * - `this -> garbage.clear();`
 * - `std::vector<particle_template*> ptx(pt -> size(), nullptr);`
 * - `for (size_t x(0); x < pt -> size(); ++x){`
 * - `particle_template* px = new particle_template();`
 * - `px -> pt    = pt  -> at(x)[0];`
 * - `px -> eta   = eta -> at(x)[0];`
 * - `px -> phi   = phi -> at(x)[0];`
 * - `px -> e     = energy -> at(x)[0];`
 * - `this -> garbage[px -> hash].push_back(px);`
 */

/**
 * @section variables Variables
 *
 * - `std::string mdlx = mdl -> name;` (::private)
 * - `bool ok = true;` (::private)
 * - `std::string dx_hx = std::to_string(mdl -> m_option -> device().index()) + "+";` (::private)
 * - `std::map<int, std::map<int, std::string>>::iterator ite = this -> _epoch_kfold[m` (::private)
 * - `std::map<int, std::string>::iterator itk = ite -> second.begin();` (::private)
 * - `std::string hx = this -> hash(dx_hx + std::to_string(itk -> first));` (::private)
 */

/** @} */
