/**
 * @file plotting.dox
 * @brief ROOT-based plotting and visualization framework
 * @defgroup plotting Plotting
 * @details 
 * Matplotlib-inspired ROOT visualization interface providing publication-quality 
 * figure generation with fine-grained control over aesthetics, histograms, and 
 * data representation. Inherits from tools and notification for utility functions 
 * and logging support.
 *
 * **Quick Navigation:**
 * - @ref notification "notification" - Logging & progress tracking
 * - @ref tools "tools" - Utility functions for common operations
 * - @ref roc "roc" - ROC curve analysis (inherits from plotting)
 * - @ref io "io" - ROOT/HDF5 I/O operations
 * - @ref meta "meta" - Metadata management
 * - @ref metric "metric" - Performance metrics
 * - @ref analysis "analysis" - Pipeline orchestrator
 * - @ref dataloader "dataloader" - Dataset batching
 *
 * @page plotting_page Plotting Module Documentation
 *
 * @section plotting_intro Introduction
 *
 * The **plotting** module is AnalysisG's ROOT-based visualization framework 
 * designed to provide matplotlib-like convenience with ROOT's publication-quality 
 * output. It serves as the foundation for all figure generation in AnalysisG, 
 * supporting histograms, error bars, variable bin widths, and extensive 
 * customization options.
 *
 * **Key Features:**
 * - **Matplotlib-inspired API**: Familiar interface for Python users
 * - **ROOT backend**: Publication-quality vector graphics output (PDF/EPS/PNG)
 * - **Flexible binning**: Fixed or variable bin widths
 * - **Error propagation**: Automatic error bar calculation
 * - **Cross-section weighting**: Monte Carlo event reweighting
 * - **Style system**: Customizable aesthetics (colors, fonts, markers)
 *
 * **Design Philosophy:**
 * The plotting module abstracts ROOT's complexity while preserving its power. 
 * Users interact through simple property assignments (similar to matplotlib's 
 * pyplot), while the module handles ROOT's TCanvas, TH1F, and TGraph management 
 * internally.
 *
 * @section plotting_purpose Purpose and Scope
 *
 * **Primary Use Cases:**
 * 1. **Histogram Generation**: Distribution plots with automatic binning
 * 2. **Error Visualization**: Asymmetric error bars for statistical uncertainties
 * 3. **Multi-Sample Overlays**: Stacked or overlaid histograms with legends
 * 4. **Publication Figures**: High-DPI vector graphics for papers
 *
 * **Module Responsibilities:**
 * - Configure histogram properties (bins, ranges, titles)
 * - Manage ROOT file I/O for figure output
 * - Calculate statistical quantities (mean, stdev, sum of weights)
 * - Apply cross-section and luminosity scaling
 * - Format axes, legends, and labels
 *
 * **Inheritance Structure:**
 * ```
 * tools ───────┐
 *              ├──► plotting ───► roc
 * notification ┘
 * ```
 *
 * The `roc` class inherits from `plotting` to leverage histogram infrastructure 
 * for ROC curve visualization.
 *
 * @section plotting_architecture Architecture
 *
 * @subsection plotting_class_structure Class Structure
 *
 * **Class Definition:**
 * ```cpp
 * class plotting: public tools, public notification {
 * public:
 *     plotting();
 *     ~plotting();
 *     
 *     // Path and I/O management
 *     std::string build_path();
 *     
 *     // Statistical utilities
 *     float get_max(std::string dim);
 *     float get_min(std::string dim);
 *     float sum_of_weights();
 *     void build_error();
 *     std::tuple<float, float> mean_stdev(std::vector<float>* data);
 *     
 *     // I/O configuration
 *     std::string extension;      // Default: ".pdf"
 *     std::string filename;       // Default: "untitled"
 *     std::string output_path;    // Default: "./Figures"
 *     
 *     // Histogram binning
 *     float x_min, x_max;
 *     float y_min, y_max;
 *     int x_bins, y_bins;         // Default: 100
 *     
 *     // Display options
 *     bool errors;                // Show error bars
 *     bool counts;                // Show bin counts
 *     bool stack;                 // Stack histograms
 *     bool density;               // Normalize to unit area
 *     
 *     // Axis scaling
 *     bool x_logarithmic;
 *     bool y_logarithmic;
 *     
 *     // Cosmetics
 *     std::string style;          // "ROOT", "seaborn", etc.
 *     std::string title;
 *     std::string xtitle, ytitle;
 *     std::string histfill;       // "fill", "step", "bar"
 *     std::string overflow;       // "sum", "ignore"
 *     std::string marker;         // ".", "o", "s", etc.
 *     std::string hatch;          // Hatch pattern
 *     std::string linestyle;      // "-", "--", ":", etc.
 *     
 *     std::string color;
 *     std::vector<std::string> colors;
 *     
 *     float line_width;
 *     float cap_size;
 *     float alpha;
 *     float x_step, y_step;       // Axis tick spacing
 *     
 *     // Font configuration
 *     float font_size;
 *     float axis_size;
 *     float legend_size;
 *     float title_size;
 *     bool use_latex;             // LaTeX rendering
 *     
 *     // Figure dimensions
 *     int dpi;                    // Default: 400
 *     float xscaling, yscaling;   // Canvas size multipliers
 *     bool auto_scale;
 *     
 *     // Data containers
 *     std::vector<float> x_data;
 *     std::vector<float> y_data;
 *     std::vector<float> y_error_up;
 *     std::vector<float> y_error_down;
 *     std::vector<float> weights;
 *     
 *     // Variable binning
 *     std::vector<float> variable_x_bins;
 *     std::vector<float> variable_y_bins;
 *     
 *     // Category labels
 *     std::unordered_map<std::string, float> x_labels;
 *     std::unordered_map<std::string, float> y_labels;
 *     
 *     // Physics parameters
 *     float cross_section;
 *     float integrated_luminosity; // Default: 140.1 fb⁻¹
 * };
 * ```
 *
 * @subsection plotting_methods Core Methods
 *
 * **1. build_path()**
 * ```cpp
 * std::string plotting::build_path()
 * ```
 * Constructs the full output file path from `output_path`, `filename`, and 
 * `extension`. Creates output directory if it doesn't exist.
 *
 * **Returns:** Absolute path to output file (e.g., `"./Figures/histogram.pdf"`)
 *
 * **Example:**
 * ```cpp
 * plotting plt;
 * plt.output_path = "./Results";
 * plt.filename = "mass_distribution";
 * plt.extension = ".eps";
 * std::string path = plt.build_path(); // "./Results/mass_distribution.eps"
 * ```
 *
 * **2. get_max() / get_min()**
 * ```cpp
 * float plotting::get_max(std::string dim)
 * float plotting::get_min(std::string dim)
 * ```
 * Retrieves maximum or minimum value from data along specified dimension.
 *
 * **Parameters:**
 * - `dim`: Dimension identifier ("x", "y", "z")
 *
 * **Returns:** Maximum/minimum value in the data container
 *
 * **Example:**
 * ```cpp
 * plt.x_data = {1.5, 2.3, 3.8, 2.1};
 * float xmax = plt.get_max("x"); // 3.8
 * float xmin = plt.get_min("x"); // 1.5
 * ```
 *
 * **3. sum_of_weights()**
 * ```cpp
 * float plotting::sum_of_weights()
 * ```
 * Calculates the total sum of event weights, accounting for cross-section 
 * and luminosity scaling.
 *
 * **Returns:** Total weighted sum (may include cross-section normalization)
 *
 * **Example:**
 * ```cpp
 * plt.weights = {1.2, 0.8, 1.5, 0.9};
 * plt.cross_section = 10.5; // pb
 * plt.integrated_luminosity = 140.1; // fb⁻¹
 * float total = plt.sum_of_weights(); // Scaled to expected events
 * ```
 *
 * **4. build_error()**
 * ```cpp
 * void plotting::build_error()
 * ```
 * Populates `y_error_up` and `y_error_down` vectors with statistical 
 * uncertainties (typically Poisson errors for counts).
 *
 * **Example:**
 * ```cpp
 * plt.y_data = {100, 144, 81};
 * plt.build_error();
 * // plt.y_error_up   = {10, 12, 9}  (√N)
 * // plt.y_error_down = {10, 12, 9}
 * ```
 *
 * **5. mean_stdev()**
 * ```cpp
 * std::tuple<float, float> plotting::mean_stdev(std::vector<float>* data)
 * ```
 * Computes mean and standard deviation of input data.
 *
 * **Parameters:**
 * - `data`: Pointer to data vector
 *
 * **Returns:** Tuple of (mean, standard_deviation)
 *
 * **Example:**
 * ```cpp
 * std::vector<float> masses = {125.1, 125.3, 124.9, 125.2};
 * auto [mean, stdev] = plt.mean_stdev(&masses);
 * // mean = 125.125, stdev ≈ 0.17
 * ```
 *
 * @section plotting_usage Usage Examples
 *
 * @subsection plotting_basic_histogram Basic Histogram
 *
 * **Creating a Simple Histogram:**
 * ```cpp
 * #include <plotting/plotting.h>
 * 
 * plotting plt;
 * 
 * // Configure histogram
 * plt.filename = "invariant_mass";
 * plt.output_path = "./Figures";
 * plt.title = "Z Boson Invariant Mass";
 * plt.xtitle = "m_{ll} [GeV]";
 * plt.ytitle = "Events / 2 GeV";
 * 
 * // Set binning
 * plt.x_min = 70;
 * plt.x_max = 110;
 * plt.x_bins = 20;
 * 
 * // Fill data
 * for (auto mass : event_masses) {
 *     plt.x_data.push_back(mass);
 * }
 * 
 * // Generate figure
 * std::string output = plt.build_path();
 * // ... ROOT histogram generation code ...
 * ```
 *
 * @subsection plotting_weighted_histogram Weighted Histogram with Errors
 *
 * **Monte Carlo Event Weighting:**
 * ```cpp
 * plotting plt;
 * plt.filename = "pt_distribution";
 * plt.title = "Transverse Momentum (Weighted)";
 * plt.xtitle = "p_{T} [GeV]";
 * plt.ytitle = "Events";
 * 
 * plt.x_min = 0;
 * plt.x_max = 200;
 * plt.x_bins = 50;
 * 
 * plt.cross_section = 870.0;           // pb
 * plt.integrated_luminosity = 140.1;    // fb⁻¹
 * plt.errors = true;
 * 
 * // Fill data with weights
 * for (size_t i = 0; i < events.size(); ++i) {
 *     plt.x_data.push_back(events[i].pt);
 *     plt.weights.push_back(events[i].weight);
 * }
 * 
 * // Compute errors
 * plt.build_error();
 * 
 * float total_expected = plt.sum_of_weights();
 * std::cout << "Expected events: " << total_expected << std::endl;
 * ```
 *
 * @subsection plotting_variable_binning Variable Bin Widths
 *
 * **Non-Uniform Binning:**
 * ```cpp
 * plotting plt;
 * plt.filename = "eta_distribution";
 * plt.xtitle = "Pseudorapidity (η)";
 * 
 * // Define variable bin edges
 * plt.variable_x_bins = {
 *     -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 
 *      0.5,  1.0,  1.5,  2.0,  2.5
 * };
 * 
 * // Fill data
 * for (auto eta : particle_etas) {
 *     plt.x_data.push_back(eta);
 * }
 * ```
 *
 * @subsection plotting_cosmetics Customizing Appearance
 *
 * **Publication-Quality Styling:**
 * ```cpp
 * plotting plt;
 * 
 * // Font configuration
 * plt.use_latex = true;
 * plt.font_size = 14;
 * plt.axis_size = 16;
 * plt.title_size = 18;
 * plt.legend_size = 12;
 * 
 * // Colors and styles
 * plt.color = "#1f77b4";           // Matplotlib blue
 * plt.histfill = "fill";
 * plt.alpha = 0.6;
 * plt.line_width = 1.5;
 * plt.linestyle = "-";
 * 
 * // Logarithmic scale
 * plt.y_logarithmic = true;
 * 
 * // High-resolution output
 * plt.dpi = 600;
 * plt.extension = ".pdf";
 * plt.xscaling = 10.0;  // 10 inches wide
 * plt.yscaling = 7.5;   // 7.5 inches tall
 * ```
 *
 * @subsection plotting_multi_sample Multi-Sample Overlay
 *
 * **Stacked Histograms:**
 * ```cpp
 * plotting plt;
 * plt.filename = "background_stack";
 * plt.title = "Background Composition";
 * plt.xtitle = "Number of Jets";
 * 
 * plt.stack = true;
 * plt.colors = {"#e41a1c", "#377eb8", "#4daf4a", "#984ea3"};
 * 
 * // Each sample has its own histogram
 * // ... populate x_data for each background ...
 * 
 * // Legend entries would be managed separately
 * ```
 *
 * @subsection plotting_categorical Categorical Data
 *
 * **Bar Charts with Category Labels:**
 * ```cpp
 * plotting plt;
 * plt.filename = "channel_counts";
 * plt.title = "Events by Decay Channel";
 * plt.xtitle = "Channel";
 * plt.ytitle = "Events";
 * 
 * // Map categories to bin positions
 * plt.x_labels["e+e-"]   = 1.0;
 * plt.x_labels["μ+μ-"]   = 2.0;
 * plt.x_labels["τ+τ-"]   = 3.0;
 * plt.x_labels["e±μ∓"]   = 4.0;
 * 
 * plt.histfill = "bar";
 * plt.x_bins = 4;
 * plt.x_min = 0.5;
 * plt.x_max = 4.5;
 * ```
 *
 * @section plotting_advanced Advanced Topics
 *
 * @subsection plotting_overflow Overflow Handling
 *
 * The `overflow` property controls how events outside the histogram range are treated:
 *
 * **Options:**
 * - **"sum"**: Add overflow events to edge bins (default)
 * - **"ignore"**: Discard overflow events
 *
 * ```cpp
 * plt.x_min = 0;
 * plt.x_max = 100;
 * plt.overflow = "sum";
 * 
 * plt.x_data = {50, 150, 75, 200, 25}; // Two values exceed x_max
 * // 150 and 200 are added to the last bin (95-100 GeV)
 * ```
 *
 * @subsection plotting_normalization Density Normalization
 *
 * The `density` flag normalizes histograms to unit area:
 *
 * ```cpp
 * plt.density = true;
 * // Integral of histogram = 1.0
 * // Y-axis: Probability density (events/bin_width)
 * ```
 *
 * Useful for shape comparisons between samples with different total counts.
 *
 * @subsection plotting_asymmetric_errors Asymmetric Error Bars
 *
 * For non-Gaussian uncertainties:
 *
 * ```cpp
 * plt.y_data = {100, 50, 25};
 * 
 * // Manual error assignment
 * plt.y_error_up   = {15, 10, 8};  // Upper uncertainty
 * plt.y_error_down = {12, 9, 6};   // Lower uncertainty
 * 
 * plt.errors = true;
 * ```
 *
 * @subsection plotting_statistics Statistical Utilities
 *
 * **Computing Summary Statistics:**
 * ```cpp
 * std::vector<float> data = plt.x_data;
 * 
 * auto [mean, sigma] = plt.mean_stdev(&data);
 * float maximum = plt.get_max("x");
 * float minimum = plt.get_min("x");
 * float sum_w = plt.sum_of_weights();
 * 
 * std::cout << "Mean ± StdDev: " << mean << " ± " << sigma << std::endl;
 * std::cout << "Range: [" << minimum << ", " << maximum << "]" << std::endl;
 * std::cout << "Total weight: " << sum_w << std::endl;
 * ```
 *
 * @section plotting_integration Integration with Other Modules
 *
 * @subsection plotting_with_io ROOT File I/O
 *
 * **Saving Histograms to ROOT Files:**
 * ```cpp
 * #include <io/io.h>
 * #include <plotting/plotting.h>
 * 
 * plotting plt;
 * io file_handler;
 * 
 * // Configure histogram
 * plt.filename = "mass_hist";
 * plt.title = "Invariant Mass";
 * plt.x_data = masses;
 * 
 * // ROOT-specific I/O would be handled via io module
 * // ... save TH1F to TFile ...
 * ```
 *
 * @subsection plotting_with_roc ROC Curve Visualization
 *
 * The `roc` class extends `plotting` for ROC curve analysis:
 *
 * ```cpp
 * #include <plotting/roc.h>
 * 
 * roc roc_analysis;
 * roc_analysis.filename = "roc_curve";
 * roc_analysis.title = "Classifier Performance";
 * roc_analysis.xtitle = "False Positive Rate";
 * roc_analysis.ytitle = "True Positive Rate";
 * 
 * // plotting properties are inherited
 * roc_analysis.x_logarithmic = false;
 * roc_analysis.line_width = 2.0;
 * ```
 *
 * @subsection plotting_with_notification Logging Integration
 *
 * Inherits from `notification` for progress tracking:
 *
 * ```cpp
 * plt.set_verbose(true);
 * plt.set_debug(true);
 * 
 * plt.add_message("Generating histogram...");
 * plt.add_warning("Overflow bin contains 15% of events");
 * plt.add_debug("x_min = " + std::to_string(plt.x_min));
 * ```
 *
 * @section plotting_best_practices Best Practices
 *
 * @subsection plotting_binning_guidelines Binning Guidelines
 *
 * **1. Fixed Bin Widths:**
 * - **Rule of Thumb**: Bins ≈ √N (Sturges' formula) or 2 × ∛N (Rice rule)
 * - **Typical**: 20-100 bins for most distributions
 *
 * ```cpp
 * int n_events = x_data.size();
 * plt.x_bins = std::ceil(std::sqrt(n_events));
 * ```
 *
 * **2. Variable Bin Widths:**
 * - Use for wide dynamic range distributions
 * - Keep bin densities roughly uniform in log-space
 *
 * ```cpp
 * // Logarithmic binning for pT
 * std::vector<float> bins;
 * for (int i = 0; i <= 10; ++i) {
 *     bins.push_back(std::pow(10, 1.0 + i*0.2)); // 10 to 1000 GeV
 * }
 * plt.variable_x_bins = bins;
 * ```
 *
 * @subsection plotting_color_schemes Color Schemes
 *
 * **Recommended Palettes:**
 * - **Colorblind-safe**: ColorBrewer qualitative schemes
 * - **Sequential data**: Viridis, Plasma (for heatmaps)
 * - **Diverging**: RdBu for positive/negative deviations
 *
 * ```cpp
 * // Tableau 10 palette (matplotlib default)
 * plt.colors = {
 *     "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
 *     "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"
 * };
 * ```
 *
 * @subsection plotting_resolution Output Resolution
 *
 * **DPI Recommendations:**
 * - **Screen viewing**: 100-150 DPI
 * - **Print publications**: 300-600 DPI
 * - **Posters**: 150-300 DPI (large format compensates)
 *
 * ```cpp
 * plt.dpi = 300;           // Journal submission
 * plt.extension = ".pdf";  // Vector format (resolution-independent)
 * ```
 *
 * @subsection plotting_memory Memory Management
 *
 * **Large Datasets:**
 * - Reserve vector capacity to avoid reallocations:
 *
 * ```cpp
 * plt.x_data.reserve(1000000);
 * plt.weights.reserve(1000000);
 * 
 * for (auto& event : dataset) {
 *     plt.x_data.push_back(event.mass);
 *     plt.weights.push_back(event.weight);
 * }
 * ```
 *
 * - Clear data after plotting to free memory:
 *
 * ```cpp
 * // After generating figure
 * std::vector<float>().swap(plt.x_data);
 * std::vector<float>().swap(plt.weights);
 * ```
 *
 * @section plotting_troubleshooting Troubleshooting
 *
 * @subsection plotting_common_errors Common Issues
 *
 * **Problem: Empty or Missing Histograms**
 * ```cpp
 * // Check data containers
 * if (plt.x_data.empty()) {
 *     std::cerr << "Error: No data to plot!" << std::endl;
 * }
 * 
 * // Verify bin ranges
 * float data_min = plt.get_min("x");
 * float data_max = plt.get_max("x");
 * if (plt.x_min > data_max || plt.x_max < data_min) {
 *     std::cerr << "Warning: Data outside histogram range!" << std::endl;
 * }
 * ```
 *
 * **Problem: Incorrect Normalization**
 * ```cpp
 * // Check cross-section and luminosity
 * if (plt.cross_section < 0) {
 *     plt.cross_section = 1.0; // Disable scaling
 * }
 * 
 * float sum_before = std::accumulate(weights.begin(), weights.end(), 0.0f);
 * float sum_after = plt.sum_of_weights();
 * std::cout << "Scaling factor: " << sum_after / sum_before << std::endl;
 * ```
 *
 * **Problem: Overlapping Labels**
 * ```cpp
 * // Increase figure size or reduce font
 * plt.xscaling *= 1.5;
 * plt.font_size *= 0.8;
 * 
 * // Rotate x-axis labels
 * // (ROOT-specific code required)
 * ```
 *
 * @subsection plotting_performance Performance Optimization
 *
 * **1. Batch Processing:**
 * ```cpp
 * // Process multiple histograms without recreating plotting objects
 * plotting plt;
 * plt.output_path = "./Results";
 * 
 * for (auto& sample : samples) {
 *     plt.filename = sample.name;
 *     plt.x_data = sample.data;
 *     // ... generate figure ...
 *     plt.x_data.clear();
 * }
 * ```
 *
 * **2. Disable Auto-Scaling for Consistent Layouts:**
 * ```cpp
 * plt.auto_scale = false;
 * plt.xscaling = 8.0;
 * plt.yscaling = 6.0;
 * ```
 *
 * @section plotting_related Related Modules
 *
 * - @ref roc "roc" - ROC curve analysis (inherits from plotting)
 * - @ref io "io" - ROOT file I/O for histogram persistence
 * - @ref notification "notification" - Logging and progress tracking
 * - @ref tools "tools" - Utility functions for data manipulation
 * - @ref meta "meta" - Metadata management for analysis tracking
 * - @ref metric "metric" - Performance metrics (may use plotting for visualization)
 * - @ref analysis "analysis" - High-level pipeline orchestrator
 *
 * @section plotting_summary Summary
 *
 * The **plotting** module provides:
 * - Matplotlib-inspired interface for ROOT-based visualization
 * - Flexible histogram configuration (fixed/variable binning)
 * - Statistical utilities (mean, stdev, sum of weights)
 * - Cross-section and luminosity scaling for Monte Carlo
 * - Publication-quality output with fine-grained aesthetic control
 * - Foundation for specialized visualization classes (e.g., `roc`)
 *
 * **Key Advantages:**
 * - **Ease of Use**: Simple property assignments instead of complex ROOT API calls
 * - **Flexibility**: Supports wide range of plot types and customizations
 * - **Integration**: Seamlessly works with AnalysisG's I/O and logging infrastructure
 * - **Quality**: Publication-ready figures with minimal effort
 *
 * **Next Steps:**
 * - Explore @ref roc "roc" for classifier performance visualization
 * - Review @ref io "io" for saving/loading histogram data
 * - See @ref metric "metric" for performance metric calculations
 */
