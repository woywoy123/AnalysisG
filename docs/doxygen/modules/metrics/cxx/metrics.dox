/**
 * @file metrics.cxx
 * @brief Documentation for modules/metrics/cxx/metrics.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/metrics/cxx/metrics.cxx
 */

/**
 * @defgroup modules_metrics_cxx_metrics_cxx metrics.cxx
 * @brief metrics.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `metrics::metrics(){ gErrorIgnoreLevel = 3000;`
 * - `metrics::~metrics(){ std::map<int, analytics_t>::iterator itr = this -> registry.begin();`
 * - `std::map<int, analytics_t>::iterator itr = this -> registry.begin();`
 * - `for (; itr != this -> registry.end(); ++itr){itr -> second.purge();}`
 * - `this -> registry.clear();`
 * - `model_report* metrics::register_model(model_template* mod, int kfold){ this -> registry[kfold].model`
 * - `this -> registry[kfold].report = new model_report();`
 * - `this -> build_th1f_loss(&mod -> m_o_graph, graph_enum::truth_graph, kfold);`
 * - `this -> build_th1f_loss(&mod -> m_o_node,  graph_enum::truth_node,  kfold);`
 * - `this -> build_th1f_loss(&mod -> m_o_edge,  graph_enum::truth_edge,  kfold);`
 * - `this -> build_th1f_accuracy(&mod -> m_o_graph, graph_enum::truth_graph, kfold);`
 * - `this -> build_th1f_accuracy(&mod -> m_o_node,  graph_enum::truth_node,  kfold);`
 * - `this -> build_th1f_accuracy(&mod -> m_o_edge,  graph_enum::truth_edge,  kfold);`
 * - `if (!this -> m_settings.targets.size()){return mr;}`
 * - `for (std::string var : this -> m_settings.targets){ this -> build_th1f_mass(var, graph_enum::truth_e`
 * - `this -> build_th1f_mass(var, graph_enum::truth_edge, kfold);`
 * - `this -> build_th1f_mass(var, graph_enum::data_edge , kfold);`
 * - `void metrics::capture(mode_enum mode, int kfold, int epoch, int smpl_len){ analytics_t* an = &this -`
 * - `this -> add_th1f_loss(&lss[graph_enum::truth_graph], &an -> loss_graph[mode], kfold, smpl_len);`
 * - `this -> add_th1f_loss(&lss[graph_enum::truth_node],  &an -> loss_node[mode],  kfold, smpl_len);`
 * - `this -> add_th1f_loss(&lss[graph_enum::truth_edge],  &an -> loss_edge[mode],  kfold, smpl_len);`
 * - `itr = lss[graph_enum::truth_graph].begin();`
 * - `for (; itr != lss[graph_enum::truth_graph].end(); ++itr){`
 * - `torch::Tensor* tru  = std::get<0>(an -> model -> m_o_graph[itr -> first]);`
 * - `this -> add_th1f_accuracy(pred, tru, an -> accuracy_graph[mode][itr -> first], kfold, smpl_len);`
 * - `itr = lss[graph_enum::truth_node].begin();`
 * - `for (; itr != lss[graph_enum::truth_node].end(); ++itr){`
 * - `torch::Tensor* tru  = std::get<0>(an -> model -> m_o_node[itr -> first]);`
 * - `this -> add_th1f_accuracy(pred, tru, an -> accuracy_node[mode][itr -> first], kfold, smpl_len);`
 * - `itr = lss[graph_enum::truth_edge].begin();`
 * - `for (; itr != lss[graph_enum::truth_edge].end(); ++itr){`
 * - `torch::Tensor* tru  = std::get<0>(an -> model -> m_o_edge[itr -> first]);`
 * - `this -> add_th1f_accuracy(pred, tru, an -> accuracy_edge[mode][itr -> first], kfold, smpl_len);`
 * - `if (!this -> m_settings.targets.size()){return;}`
 * - `torch::Tensor pmc = torch::cat({ *(node_feat)[this -> m_settings.var_pt] , *(node_feat)[this -> m_se`
 * - `pmc = pyc::transform::combined::PxPyPzE(pmc)/1000;`
 * - `for (std::string var : this -> m_settings.targets){ torch::Tensor* pred  = an -> model -> m_p_edge[v`
 * - `torch::Tensor* truth = std::get<0>(an -> model -> m_o_edge[var]);`
 * - `if (!truth){ this -> warning("Invalid Target Mass Plot: " + var + ". Skipping all targets.");`
 * - `this -> warning("Invalid Target Mass Plot: " + var + ". Skipping all targets.");`
 * - `this -> add_th1f_mass(&pmc, an -> model -> edge_index, truth, pred, kfold, mode, var);`
 * - `void metrics::dump_plots(int k){ this -> dump_loss_plots(k);`
 * - `this -> dump_loss_plots(k);`
 * - `this -> dump_accuracy_plots(k);`
 * - `this -> dump_mass_plots(k);`
 */

/**
 * @section variables Variables
 *
 * - `std::map<int, analytics_t>::iterator itr = this -> registry.begin();` (::private)
 * - `std::map<graph_enum, std::map<std::string, torch::Tensor>> lss = an -> model -> ` (::private)
 * - `torch::Tensor* pred = an -> model -> m_p_graph[itr -> first];` (::private)
 * - `torch::Tensor* tru  = std::get<0>(an -> model -> m_o_graph[itr -> first]);` (::private)
 * - `torch::Tensor* pred = an -> model -> m_p_node[itr -> first];` (::private)
 * - `torch::Tensor* tru  = std::get<0>(an -> model -> m_o_node[itr -> first]);` (::private)
 * - `torch::Tensor* pred = an -> model -> m_p_edge[itr -> first];` (::private)
 * - `torch::Tensor* tru  = std::get<0>(an -> model -> m_o_edge[itr -> first]);` (::private)
 * - `std::map<std::string, torch::Tensor*> node_feat = an -> model -> m_i_node;` (::private)
 * - `torch::Tensor pmc = torch::cat({` (::private)
 * - `torch::Tensor* pred  = an -> model -> m_p_edge[var];` (::private)
 * - `torch::Tensor* truth = std::get<0>(an -> model -> m_o_edge[var]);` (::private)
 */

/** @} */
