/**
 * @file htilde.cxx
 * @brief Documentation for modules/nusol/conuix/cxx/htilde.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/nusol/conuix/cxx/htilde.cxx
 */

/**
 * @defgroup modules_nusol_conuix_cxx_htilde_cxx htilde.cxx
 * @brief htilde.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `void Conuix::get_kinematic(particle_template* ptr, Conuix::kinematic_t* kin){ kin -> beta = (long do`
 * - `kin -> beta = (long double)(ptr -> beta);`
 * - `kin -> mass = (long double)(std::abs(ptr -> mass));`
 * - `kin -> energy = (long double)(ptr -> e);`
 * - `void Conuix::get_rotation(particle_template* jet, particle_template* lep, Conuix::rotation_t* rot){ `
 * - `long double lpx = (long double)(lep -> px);`
 * - `long double lpy = (long double)(lep -> py);`
 * - `long double lpz = (long double)(lep -> pz);`
 * - `long double lpe = (long double)(lep -> e);`
 * - `long double lpb = (long double)(lep -> beta);`
 * - `rot -> phi   = std::atan2(lpy, lpx);`
 * - `rot -> theta = std::acos(lpz / (lpe * lpb));`
 * - `rot -> vec = matrix_t(3, 1);`
 * - `rot -> vec.at(0, 0) = (long double)(jet -> px);`
 * - `rot -> vec.at(1, 0) = (long double)(jet -> py);`
 * - `rot -> vec.at(2, 0) = (long double)(jet -> pz);`
 * - `matrix_t Rz(3, 3);`
 * - `Rz.at(0, 0) =  std::cos(-rot -> phi);`
 * - `Rz.at(0, 1) = -std::sin(-rot -> phi);`
 * - `Rz.at(2, 2) = 1;`
 * - `Rz.at(1, 0) = std::sin(-rot -> phi);`
 * - `Rz.at(1, 1) = std::cos(-rot -> phi);`
 * - `matrix_t Ry(3, 3);`
 * - `Ry.at(0, 0) = std::cos(0.5 * M_PI - rot -> theta);`
 * - `Ry.at(0, 2) = std::sin(0.5 * M_PI - rot -> theta);`
 * - `Ry.at(1, 1) = 1;`
 * - `Ry.at(2, 0) = -std::sin(0.5 * M_PI - rot -> theta);`
 * - `Ry.at(2, 2) =  std::cos(0.5 * M_PI - rot -> theta);`
 * - `matrix_t b_p = Ry.dot(Rz.dot(rot -> vec));`
 * - `long double alpha = -std::atan2(b_p.at(2, 0), b_p.at(1, 0));`
 * - `matrix_t Rx(3, 3);`
 * - `Rx.at(0, 0) = 1;`
 * - `Rx.at(1, 1) =  std::cos(alpha);`
 * - `Rx.at(1, 2) = -std::sin(alpha);`
 * - `Rx.at(2, 1) =  std::sin(alpha);`
 * - `Rx.at(2, 2) =  std::cos(alpha);`
 * - `rot -> R_T = matrix_t(Rz.T().dot(Ry.T().dot(Rx.T())));`
 * - `void Conuix::get_psi_theta_mapping(Conuix::base_t* base, Conuix::thetapsi_t* msp){ long double r = b`
 * - `long double d = std::pow(1 + base -> w * base -> w - r * r, 0.5);`
 * - `msp -> p_sin = (r * base -> w + d) / (1 + base -> w * base -> w);`
 * - `msp -> m_sin = (r * base -> w - d) / (1 + base -> w * base -> w);`
 * - `msp -> p_cos = (r + base -> w * d) / (1 + base -> w * base -> w);`
 * - `msp -> m_cos = (r - base -> w * d) / (1 + base -> w * base -> w);`
 * - `void Conuix::get_base(Conuix::kinematic_t* jet, Conuix::kinematic_t* lep, Conuix::base_t* bs){ //NOT`
 * - `bs -> w  = ((lep -> beta / jet -> beta) - bs -> cos) / bs -> sin;`
 * - `bs -> o  = std::sqrt(bs -> o2);`
 * - `bs -> cpsi = 1.0 / std::sqrt(1 + bs -> w * bs -> w);`
 * - `pen -> a = (1 - base -> o2) / base -> o2;`
 * - `pen -> c = (base -> w2 - base -> o2) / base -> o2;`
 * - `void Conuix::get_sx(Conuix::base_t* base, Conuix::Sx_t* sx){ // Sx(tau) = Z [ (Omega / beta_mu) cos(`
 * - `sx -> a =  (base -> cpsi / base -> beta) * base -> o;`
 * - `sx -> c = - base -> mass * base -> mass / (base -> E * base -> beta);`
 * - `void Conuix::get_sy(Conuix::base_t* base, Conuix::Sy_t* sy){ // Sy(tau) = Z [(sin(psi) / beta_mu) Om`
 * - `sy -> a = (base -> spsi / base -> beta) * base -> o;`
 * - `sy -> c = - (base -> E / base -> beta) * base -> tpsi;`
 * - `void Conuix::get_hmatrix(Conuix::base_t* base, Conuix::rotation_t* rot, Conuix::H_matrix_t* H){ // .`
 * - `H -> HBX.at(0, 0) = 1            / base -> o;`
 * - `H -> HBX.at(1, 0) = base -> tpsi / base -> o;`
 * - `H -> HBX.at(2, 0) = 0;`
 * - `H -> HBX.at(0, 1) = 0;`
 * - `H -> HBX.at(1, 1) = 0;`
 * - `H -> HBX.at(2, 1) = 1;`
 * - `H -> HBX.at(0, 2) = 0;`
 * - `H -> HBX.at(1, 2) = 0;`
 * - `H -> HBX.at(2, 2) = 0;`
 * - `H -> HTX = rot -> R_T.dot(H -> HBX);`
 * - `H -> HBC.at(0, 0) = 0;`
 * - `H -> HBC.at(1, 0) = 0;`
 * - `H -> HBC.at(2, 0) = 0;`
 * - `H -> HBC.at(0, 1) = 0;`
 * - `H -> HBC.at(1, 1) = 0;`
 * - `H -> HBC.at(2, 1) = 0;`
 * - `H -> HBC.at(0, 2) = base -> beta * base -> cpsi / base -> o;`
 * - `H -> HBC.at(1, 2) = base -> beta * base -> spsi / base -> o;`
 * - `H -> HBC.at(2, 2) = 0;`
 * - `H -> HTC = rot -> R_T.dot(H -> HBC);`
 * - `H -> HBS.at(0, 0) = 0;`
 * - `H -> HBS.at(1, 0) = 0;`
 * - `H -> HBS.at(2, 0) = 0;`
 * - `H -> HBS.at(0, 1) = 0;`
 * - `H -> HBS.at(1, 1) = 0;`
 * - `H -> HBS.at(2, 1) = 0;`
 * - `H -> HBS.at(0, 2) =   base -> spsi;`
 * - `H -> HBS.at(1, 2) = - base -> cpsi;`
 * - `H -> HBS.at(2, 2) = 0;`
 * - `H -> HTS = rot -> R_T.dot(H -> HBS);`
 */

/**
 * @section variables Variables
 *
 * - `kin -> beta = (long double)(ptr -> beta);` (::private)
 * - `kin -> mass = (long double)(std::abs(ptr -> mass));` (::private)
 * - `kin -> energy = (long double)(ptr -> e);` (::private)
 * - `long double lpx = (long double)(lep -> px);` (::private)
 * - `long double lpy = (long double)(lep -> py);` (::private)
 * - `long double lpz = (long double)(lep -> pz);` (::private)
 * - `long double lpe = (long double)(lep -> e);` (::private)
 * - `long double lpb = (long double)(lep -> beta);` (::private)
 * - `rot -> phi   = std::atan2(lpy, lpx);` (::private)
 * - `rot -> theta = std::acos(lpz / (lpe * lpb));` (::private)
 * - `rot -> vec.at(0, 0) = (long double)(jet -> px);` (::private)
 * - `rot -> vec.at(1, 0) = (long double)(jet -> py);` (::private)
 * - `rot -> vec.at(2, 0) = (long double)(jet -> pz);` (::private)
 * - `Rz.at(0, 0) =  std::cos(-rot -> phi);` (::private)
 * - `Rz.at(0, 1) = -std::sin(-rot -> phi);` (::private)
 * - `Rz.at(1, 0) = std::sin(-rot -> phi);` (::private)
 * - `Rz.at(1, 1) = std::cos(-rot -> phi);` (::private)
 * - `Ry.at(0, 0) = std::cos(0.5 * M_PI - rot -> theta);` (::private)
 * - `Ry.at(0, 2) = std::sin(0.5 * M_PI - rot -> theta);` (::private)
 * - `Ry.at(2, 0) = -std::sin(0.5 * M_PI - rot -> theta);` (::private)
 * - `Ry.at(2, 2) =  std::cos(0.5 * M_PI - rot -> theta);` (::private)
 * - `long double alpha = -std::atan2(b_p.at(2, 0), b_p.at(1, 0));` (::private)
 * - `Rx.at(1, 1) =  std::cos(alpha);` (::private)
 * - `Rx.at(1, 2) = -std::sin(alpha);` (::private)
 * - `Rx.at(2, 1) =  std::sin(alpha);` (::private)
 * - `Rx.at(2, 2) =  std::cos(alpha);` (::private)
 * - `long double r = base -> rbl;` (::private)
 * - `long double d = std::pow(1 + base -> w * base -> w - r * r, 0.5);` (::private)
 * - `bs -> o  = std::sqrt(bs -> o2);` (::private)
 * - `bs -> cpsi = 1.0 / std::sqrt(1 + bs -> w * bs -> w);` (::private)
 */

/** @} */
