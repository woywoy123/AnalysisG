/**
 * @file matrix.cxx
 * @brief Documentation for modules/nusol/tmp/multisol/cxx/matrix.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/nusol/tmp/multisol/cxx/matrix.cxx
 */

/**
 * @defgroup modules_nusol_tmp_multisol_cxx_matrix_cxx matrix.cxx
 * @brief matrix.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `vec3 vec3::operator-(const vec3& o) const { return {this -> x - o.x, this -> y - o.y, this -> z - o.`
 * - `vec3 vec3::operator+(const vec3& o) const { return {this -> x + o.x, this -> y + o.y, this -> z + o.`
 * - `vec3 vec3::operator*(double s) const { return {this -> x*s, this -> y*s, this -> z*s};`
 * - `double vec3::mag()  const { return std::pow(this -> mag2(), 0.5);`
 * - `return std::pow(this -> mag2(), 0.5);`
 * - `double vec3::mag2() const { return this -> x*this -> x + this -> y*this -> y + this -> z*this -> z;`
 * - `double vec3::dot(const vec3& o) const { return this -> x*o.x + this -> y*o.y + this -> z*o.z;`
 * - `vec3 vec3::cross(const vec3& o) const { return {this -> y*o.z - this -> z*o.y, this -> z*o.x - this `
 * - `void vec3::print() const { std::cout << "(" << this -> x << ", " << this -> y << ", " << this -> z <`
 * - `std::cout << "(" << this -> x << ", " << this -> y << ", " << this -> z << ")" << std::endl;`
 * - `vec4 vec4::operator-(const vec4& o) const { return {this -> x - o.x, this -> y - o.y, this -> z - o.`
 * - `vec4 vec4::operator+(const vec4& o) const { return {this -> x + o.x, this -> y + o.y, this -> z + o.`
 * - `vec4 vec4::operator*(double s) const { return {this -> x*s, this -> y*s, this -> z*s, this -> w*s};`
 * - `double vec4::dot(const vec4& o) const { return this -> x*o.x + this -> y*o.y + this -> z*o.z + this `
 * - `void vec4::print() { std::cout << "(" << this -> x << ", " << this -> y << ", " << this -> z << ", "`
 * - `std::cout << "(" << this -> x << ", " << this -> y << ", " << this -> z << ", " << this -> w << ")\n`
 * - `matrix::matrix(int r, int c){ this -> _c = c; this -> _r = r;`
 * - `for (int i(0); i < r; ++i){this -> data[i] = new double[c]();}`
 * - `matrix::matrix(const matrix& other){ this -> _r = other._r; this -> _c = other._c;`
 * - `for (int i(0); i < this -> _r; ++i){`
 * - `for (int j(0); j < this -> _c; ++j){this -> data[i][j] = other.data[i][j];}`
 * - `matrix::~matrix(){ for (int i(0); i < this -> _r; ++i){ delete [] this -> data[i]; }`
 * - `for (int i(0); i < this -> _r; ++i){ delete [] this -> data[i]; }`
 * - `int matrix::rows() const { return this -> _r;`
 * - `int matrix::cols() const { return this -> _c;`
 * - `double& matrix::at(int r, int c) { return this -> data[r][c];`
 * - `const double& matrix::at(int r, int c) const { return this -> data[r][c];`
 * - `void matrix::print(int p){ std::cout << "--------------" << std::endl;`
 * - `for (int i(0); i < this -> _r; ++i) {`
 * - `for (int j(0); j < this -> _c; ++j){`
 * - `std::cout << std::fixed << std::setprecision(p) << this -> data[i][j] << " \t";`
 * - `double matrix::mag() const { if (this -> _c != 1) { return 0; }`
 * - `if (this -> _c != 1) { return 0; }`
 * - `for (int i = 0; i < this -> _r; ++i){`
 * - `return std::pow(sum_sq, 0.5);`
 * - `matrix matrix::I(int size){ matrix mx(size, size);`
 * - `matrix mx(size, size);`
 * - `for (int k(0); k < size; ++k){ mx.data[k][k] = 1.0; }`
 * - `matrix matrix::T() const{ matrix mx(this -> _c, this -> _r);`
 * - `matrix mx(this -> _c, this -> _r);`
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[j][i] = this -> data[i][j]; }`
 * - `double matrix::det(){ double c00 = this -> data[0][0] * (this -> data[1][1] * this -> data[2][2] - t`
 * - `double c00 = this -> data[0][0] * (this -> data[1][1] * this -> data[2][2] - this -> data[1][2] * th`
 * - `double c11 = this -> data[0][1] * (this -> data[1][0] * this -> data[2][2] - this -> data[1][2] * th`
 * - `double c22 = this -> data[0][2] * (this -> data[1][0] * this -> data[2][1] - this -> data[1][1] * th`
 * - `matrix matrix::inverse(){ double det_ = this -> det();`
 * - `double det_ = this -> det();`
 * - `if (std::abs(det_) < 1e-12){ return matrix::I(3); }`
 * - `matrix mx(3, 3);`
 * - `mx.data[0][0] = (this -> data[1][1]*this -> data[2][2] - this -> data[1][2]*this -> data[2][1]) * in`
 * - `mx.data[0][1] = (this -> data[0][2]*this -> data[2][1] - this -> data[0][1]*this -> data[2][2]) * in`
 * - `mx.data[0][2] = (this -> data[0][1]*this -> data[1][2] - this -> data[0][2]*this -> data[1][1]) * in`
 * - `mx.data[1][0] = (this -> data[1][2]*this -> data[2][0] - this -> data[1][0]*this -> data[2][2]) * in`
 * - `mx.data[1][1] = (this -> data[0][0]*this -> data[2][2] - this -> data[0][2]*this -> data[2][0]) * in`
 * - `mx.data[1][2] = (this -> data[0][2]*this -> data[1][0] - this -> data[0][0]*this -> data[1][2]) * in`
 * - `mx.data[2][0] = (this -> data[1][0]*this -> data[2][1] - this -> data[1][1]*this -> data[2][0]) * in`
 * - `mx.data[2][1] = (this -> data[0][1]*this -> data[2][0] - this -> data[0][0]*this -> data[2][1]) * in`
 * - `mx.data[2][2] = (this -> data[0][0]*this -> data[1][1] - this -> data[0][1]*this -> data[1][0]) * in`
 * - `matrix matrix::dot(const matrix& o){ matrix mx(this -> _r, o._c);`
 * - `matrix mx(this -> _r, o._c);`
 * - `for (int j(0); j < o._c; ++j){`
 * - `for (int k(0); k < this -> _c; ++k){ mx.data[i][j] += this -> data[i][k] * o.data[k][j]; }`
 * - `void matrix::eigenvalues(vec3* real, vec3* imag){ if (this -> _c != 3 || this -> _r != 3){return;}`
 * - `if (this -> _c != 3 || this -> _r != 3){return;}`
 * - `double b = -(a00 + a11 + a22);`
 * - `double c =  (a00 * a11 - a01 * a10) + (a00 * a22 - a02 * a20) + (a11 * a22 - a12 * a21);`
 * - `double d = -this -> det();`
 * - `mtx* solx = solve_cubic(a, b, c, d);`
 * - `matrix& matrix::operator=(const matrix& o){ if (this == &o){ return *this; }`
 * - `if (this == &o){ return *this; }`
 * - `for (int j(0); j < this -> _c; ++j){ this -> data[i][j] = o.data[i][j]; }`
 * - `matrix matrix::operator+(const matrix& o) const { matrix mx(this -> _r, this -> _c);`
 * - `matrix mx(this -> _r, this -> _c);`
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[i][j] = this -> data[i][j] + o.data[i][j]; }`
 * - `matrix matrix::operator-(const matrix& o) const { matrix mx(this -> _r, this -> _c);`
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[i][j] = this -> data[i][j] - o.data[i][j]; }`
 * - `matrix matrix::operator*(const matrix& o) const { matrix mx(this -> _r, o._c);`
 * - `matrix matrix::operator*(double scalar) const { matrix mx(this -> _r, this -> _c);`
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[i][j] = this -> data[i][j] * scalar; }`
 * - `vec4 matrix::operator*(const vec4& v) const { return {`
 * - `vec3 matrix::operator*(const vec3& v) const { return {`
 * - `bool solve_linear(const matrix& A_in, const matrix& b_in, matrix& x_out){ const int size = A_in.rows`
 * - `const int size = A_in.rows();`
 * - `matrix aug(size, size + 1);`
 * - `for (int i(0); i < size; ++i){`
 * - `for (int j(0); j < size; ++j){aug.at(i, j) = A_in.at(i, j);}`
 * - `aug.at(i, size) = b_in.at(i, 0);`
 * - `for (int k(0); k < size; ++k){`
 * - `double max_val = std::abs(aug.at(k, k));`
 * - `for (int row(k + 1); row < size; ++row){`
 * - `double vx = std::abs(aug.at(row, k));`
 * - `if (vx <= max_val){ continue; }`
 * - `if (max_val < 1e-15){ return false; }`
 * - `for (int col(0); col < (size + 1)*(pr != k); ++col){`
 * - `std::swap(aug.at(k, col), aug.at(pr, col));`
 * - `for (int col(k); col <= size; ++col){`
 * - `aug.at(k, col) /= aug.at(k, k);`
 * - `for (int row(0); row < size; ++row){`
 * - `if (row == k){ continue; }`
 * - `double f = aug.at(row, k);`
 * - `aug.at(row, col) -= f * aug.at(k, col);`
 * - `aug.print();`
 * - `x_out = matrix(size, 1);`
 * - `for (int i(0); i < size; ++i){x_out.at(i, 0) = aug.at(i, size);}`
 * - `bool invert_matrix(const matrix& M, matrix& M_inv){ const int n = M.rows();`
 * - `const int n = M.rows();`
 * - `M_inv = matrix(n, n);`
 * - `matrix ic(n, 1), sc(n, 1);`
 * - `for (int j(0); j < n; ++j){`
 * - `ic.at(j, 0) = 1.0;`
 * - `if (!solve_linear(M, ic, sc)){ matrix M_regularized = M;`
 * - `for (int i(0); i < n; ++i){ M_regularized.at(i, i) += 1e-8; }`
 * - `if (!solve_linear(M_regularized, ic, sc)){return false;}`
 * - `for (int i(0); i < n; ++i){M_inv.at(i, j) = sc.at(i, 0);}`
 * - `ic.at(j, 0) = 0.0;`
 * - `void print(double v, int p){ std::cout << std::fixed << std::setprecision(p) << v << "\n";`
 * - `std::cout << std::fixed << std::setprecision(p) << v << "\n";`
 */

/**
 * @section variables Variables
 *
 * - `for (int i(0); i < r; ++i){this -> data[i] = new double[c]();}` (::private)
 * - `for (int j(0); j < this -> _c; ++j){this -> data[i][j] = other.data[i][j];}` (::private)
 * - `double sum_sq = 0;` (::private)
 * - `for (int i = 0; i < this -> _r; ++i){` (::private)
 * - `for (int k(0); k < size; ++k){ mx.data[k][k] = 1.0; }` (::private)
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[j][i] = this -> data[i][j]; }` (::private)
 * - `double c00 = this -> data[0][0] * (this -> data[1][1] * this -> data[2][2] - thi` (::private)
 * - `double c11 = this -> data[0][1] * (this -> data[1][0] * this -> data[2][2] - thi` (::private)
 * - `double c22 = this -> data[0][2] * (this -> data[1][0] * this -> data[2][1] - thi` (::private)
 * - `double det_ = this -> det();` (::private)
 * - `double inv_det = 1.0 / det_;` (::private)
 * - `for (int k(0); k < this -> _c; ++k){ mx.data[i][j] += this -> data[i][k] * o.dat` (::private)
 * - `double a00 = this -> data[0][0], a01 = this -> data[0][1], a02 = this -> data[0]` (::private)
 * - `double a10 = this -> data[1][0], a11 = this -> data[1][1], a12 = this -> data[1]` (::private)
 * - `double a20 = this -> data[2][0], a21 = this -> data[2][1], a22 = this -> data[2]` (::private)
 * - `double a = 1;` (::private)
 * - `double b = -(a00 + a11 + a22);` (::private)
 * - `double c =  (a00 * a11 - a01 * a10) + (a00 * a22 - a02 * a20) + (a11 * a22 - a12` (::private)
 * - `double d = -this -> det();` (::private)
 * - `for (int j(0); j < this -> _c; ++j){ this -> data[i][j] = o.data[i][j]; }` (::private)
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[i][j] = this -> data[i][j] + o.data` (::private)
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[i][j] = this -> data[i][j] - o.data` (::private)
 * - `for (int j(0); j < this -> _c; ++j){ mx.data[i][j] = this -> data[i][j] * scalar` (::private)
 * - `const int size = A_in.rows();` (::private)
 * - `for (int j(0); j < size; ++j){aug.at(i, j) = A_in.at(i, j);}` (::private)
 * - `int pr = k;` (::private)
 * - `double max_val = std::abs(aug.at(k, k));` (::private)
 * - `double vx = std::abs(aug.at(row, k));` (::private)
 * - `for (int col(0); col < (size + 1)*(pr != k); ++col){` (::private)
 * - `for (int col(k); col <= size; ++col){` (::private)
 * - `double f = aug.at(row, k);` (::private)
 * - `for (int i(0); i < size; ++i){x_out.at(i, 0) = aug.at(i, size);}` (::private)
 * - `const int n = M.rows();` (::private)
 * - `for (int i(0); i < n; ++i){ M_regularized.at(i, i) += 1e-8; }` (::private)
 * - `for (int i(0); i < n; ++i){M_inv.at(i, j) = sc.at(i, 0);}` (::private)
 */

/** @} */
