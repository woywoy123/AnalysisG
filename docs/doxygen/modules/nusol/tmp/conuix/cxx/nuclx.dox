/**
 * @file nuclx.cxx
 * @brief Documentation for modules/nusol/tmp/conuix/cxx/nuclx.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/nusol/tmp/conuix/cxx/nuclx.cxx
 */

/**
 * @defgroup modules_nusol_tmp_conuix_cxx_nuclx_cxx nuclx.cxx
 * @brief nuclx.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `double _mag(particle_template* p){ double p2 = double(p -> px) * double(p -> px);`
 * - `double p2 = double(p -> px) * double(p -> px);`
 * - `p2 += double(p -> py) * double(p -> py);`
 * - `p2 += double(p -> pz) * double(p -> pz);`
 * - `return std::pow(p2, 0.5);`
 * - `double _beta(particle_template* prt){ return _mag(prt) / double(prt -> e);`
 * - `return _mag(prt) / double(prt -> e);`
 * - `double cos_theta(particle_template* b, particle_template* mu){ double _d = double(b -> px) * double(`
 * - `double _d = double(b -> px) * double(mu -> px);`
 * - `_d += double(b -> py) * double(mu -> py);`
 * - `_d += double(b -> pz) * double(mu -> pz);`
 * - `return _d / (_mag(b) * _mag(mu));`
 * - `nuclx_t::nuclx_t(particle_template* b, particle_template* mu){  // --------- fetch all the kinematic`
 * - `this -> beta_lep = _beta(mu);  this -> beta_jet = _beta(b);`
 * - `this -> p_lep    = _mag(mu);   this -> p_jet    = _mag(b);`
 * - `this -> phi_mu   = std::atan2(mu -> py, mu -> px);`
 * - `this -> theta_mu = std::acos(mu -> pz / this -> p_lep);`
 * - `this -> cos_t    = cos_theta(b, mu);`
 * - `this -> sin_t    = std::pow(1 - this -> cos_t * this -> cos_t, 0.5);`
 * - `this -> w  = ((this -> beta_lep / this -> beta_jet) - this -> cos_t)/this -> sin_t;`
 * - `this -> wr = std::pow(1 + this -> w2, -0.5);`
 * - `this -> o2 = this -> w2 + std::pow(std::abs(this -> mass_lep / this -> e_lep), 2);`
 * - `this -> o  = std::pow(this -> o2, 0.5);`
 * - `this -> vec_jet = matrix_t(3, 1);`
 * - `this -> vec_jet.at(0, 0) = b -> px;`
 * - `this -> vec_jet.at(1, 0) = b -> py;`
 * - `this -> vec_jet.at(2, 0) = b -> pz;`
 * - `this -> rotation();`
 * - `this -> surface();`
 * - `this -> shifts();`
 * - `this -> H_bar(); this -> H();`
 * - `this -> sx(); this -> sy();`
 * - `this -> mw(); this -> mt();`
 * - `this -> polynomial();`
 * - `void nuclx_t::polynomial(){ // characteristic polynomial coefficients // a_l: - 1.0 / o // b_l: beta`
 * - `this -> d_l = std::pow(1 + this -> w2, 0.5) / this -> o;`
 * - `void nuclx_t::critical_t0(){ double r = std::pow(1 - this -> beta_lep * this -> beta_lep, 0.5);`
 * - `double r = std::pow(1 - this -> beta_lep * this -> beta_lep, 0.5);`
 * - `double b = std::pow(1 + this -> w2, 0.5) / (3 * this -> o * r);`
 * - `this -> t_0 = std::asinh(a) - std::asinh(b);`
 * - `void nuclx_t::rotation(){ matrix_t Rz(3, 3);`
 * - `matrix_t Rz(3, 3);`
 * - `Rz.at(0, 0) =  std::cos(this -> phi_mu);`
 * - `Rz.at(0, 1) = -std::sin(this -> phi_mu);`
 * - `Rz.at(2, 2) = 1;`
 * - `Rz.at(1, 0) = std::sin(this -> phi_mu);`
 * - `Rz.at(1, 1) = std::cos(this -> phi_mu);`
 * - `matrix_t Ry(3, 3);`
 * - `Ry.at(0, 0) = std::cos(this -> theta_mu);`
 * - `Ry.at(0, 2) = std::sin(this -> theta_mu);`
 * - `Ry.at(1, 1) = 1;`
 * - `Ry.at(2, 0) = -std::sin(this -> theta_mu);`
 * - `Ry.at(2, 2) =  std::cos(this -> theta_mu);`
 * - `matrix_t b_p = Ry.dot(Rz.dot(this -> vec_jet));`
 * - `double alpha = -std::atan2(b_p.at(2, 0), b_p.at(1, 0));`
 * - `matrix_t Rx(3, 3);`
 * - `Rx.at(0, 0) = 1;`
 * - `Rx.at(1, 1) =  std::cos(alpha);`
 * - `Rx.at(1, 2) = -std::sin(alpha);`
 * - `Rx.at(2, 1) =  std::sin(alpha);`
 * - `Rx.at(2, 2) =  std::cos(alpha);`
 * - `this -> R_T  =  matrix_t(Rz.T().dot(Ry.T().dot(Rx.T())));`
 * - `void nuclx_t::H_bar(){ // H_bar = 1.0/O * [ HC + (beta_mu / sqrt(1 + w^2)) * H1 * cosh(t) + (O / sqr`
 * - `this -> HBc.at(0, 0) = 1.0 / this -> o;`
 * - `this -> HBc.at(1, 0) = this -> w / this -> o;`
 * - `this -> HBc.at(2, 1) = 1.0;`
 * - `this -> HB1.at(0, 2) = - this -> beta_lep * this -> wr / this -> o;`
 * - `this -> HB1.at(1, 2) = - this -> beta_lep * this -> wr * this -> w / this -> o;`
 * - `this -> HB2.at(0, 2) = - this -> w * this -> wr;`
 * - `this -> HB2.at(1, 2) =   this -> wr;`
 * - `void nuclx_t::H(){ // same as H_Bar but with rotation: R_T this -> Hc = this -> R_T.dot(this -> HBc)`
 * - `this -> Hc = this -> R_T.dot(this -> HBc);`
 * - `this -> H1 = this -> R_T.dot(this -> HB1);`
 * - `this -> H2 = this -> R_T.dot(this -> HB2);`
 * - `void nuclx_t::surface(){ this -> A = 1.0 / this -> o2 - 1;`
 * - `this -> B = - std::pow(this -> mass_lep / this -> e_lep, 2) * (1.0 / this -> o2);`
 * - `void nuclx_t::shifts(){ this -> s0x = - std::pow(this -> mass_lep, 2) / this -> p_lep;`
 * - `this -> s0x = - std::pow(this -> mass_lep, 2) / this -> p_lep;`
 * - `this -> s0y = - this -> w * this -> p_lep / (this -> beta_lep * this -> beta_lep);`
 * - `this -> psi = std::atan(this -> w);`
 * - `this -> lmb2 = (this -> beta_lep * this -> beta_lep);`
 * - `void nuclx_t::sx(){ // Sx(t, Z) = |Z| * (a_x * cosh(t) + b_x * sinh(t)) + c_x;`
 * - `this -> a_x =  (this -> o / this -> beta_lep) * this -> cpsi;`
 * - `void nuclx_t::sy(){ // Sy(t, Z) = |Z| * (a_y * cosh(t) + b_y * sinh(t)) + c_y;`
 * - `this -> a_y = (this -> o / this -> beta_lep) * this -> spsi;`
 * - `void nuclx_t::mw(){ // mW^2: - m^2_mu - 2 * p_mu * Sx(t, Z) // mW^2: a_w + b_w * Sx(t, Z) this -> a_`
 * - `void nuclx_t::mt(){ // mT^2: m^2_b - m^2_mu - 2 * (p_mu + p_b * cos(theta)) * Sx(t, Z) - 2 * p_b * s`
 * - `this -> b_t = -2 * (this -> p_lep + this -> p_jet * this -> cos_t);`
 * - `nuclx_t nuclx_t::from_sx_sy(double _sx, double _sy){ nuclx_t out = *this;`
 * - `out.z_v = this -> get_z(_sx, _sy);`
 * - `out.t_v = this -> get_t(out.u_p, out.v_p, out.z_v);`
 * - `double nuclx_t::get_z(double _sx, double _sy){ double _z = this -> A * _sx * _sx + this -> B * _sy *`
 * - `return (_z >= 0) ? std::pow(_z, 0.5) : -1.0;`
 * - `double nuclx_t::get_t(double _up, double _vp, double _z){ // Calculate the ratio a/b from the parame`
 * - `double r = this -> o / this -> beta_lep * (_vp / _up);`
 * - `if (_up > 0 && std::fabs(r) < 1){_t = std::atanh(r);}`
 * - `else if (_up < 0 && _vp < 0){_t = std::asinh(_vp / _z);}`
 * - `else {_t = std::acosh(fabs(_up) * this -> beta_lep / (_z * this -> o))*(1 - 2 * (_vp < 0));}`
 * - `nuclx_t nuclx_t::from_z_t(double _z, double _t){ nuclx_t out = *this;`
 * - `double sh = std::sinh(_t);`
 * - `double ch = std::cosh(_t);`
 * - `out.sx_v = _z * (this -> a_x * ch + this -> b_x * sh) + this -> c_x;`
 * - `out.sy_v = _z * (this -> a_y * ch + this -> b_y * sh) + this -> c_y;`
 * - `out.mt_v = this -> get_mt(out.sx_v, out.sy_v);`
 * - `out.mw_v = this -> get_mw(out.sx_v);`
 * - `double nuclx_t::get_mt(double _sx, double _sy){ // mT^2: m^2_b - m^2_mu - 2 * (p_mu + p_b * cos(thet`
 * - `return std::pow(std::abs(this -> b_t * _sx + this -> c_t * _sy + this -> a_t), 0.5);`
 * - `double nuclx_t::get_mw(double _sx){ // mW^2: - m^2_mu - 2 * p_mu * Sx(t, Z) // mW^2: a_w + b_w * Sx(`
 * - `return std::pow(std::abs(this -> b_w * _sx + this -> a_w), 0.5);`
 */

/**
 * @section variables Variables
 *
 * - `double p2 = double(p -> px) * double(p -> px);` (::private)
 * - `double _d = double(b -> px) * double(mu -> px);` (::private)
 * - `this -> phi_mu   = std::atan2(mu -> py, mu -> px);` (::private)
 * - `this -> theta_mu = std::acos(mu -> pz / this -> p_lep);` (::private)
 * - `this -> sin_t    = std::pow(1 - this -> cos_t * this -> cos_t, 0.5);` (::private)
 * - `this -> wr = std::pow(1 + this -> w2, -0.5);` (::private)
 * - `this -> o2 = this -> w2 + std::pow(std::abs(this -> mass_lep / this -> e_lep), 2` (::private)
 * - `this -> o  = std::pow(this -> o2, 0.5);` (::private)
 * - `this -> d_l = std::pow(1 + this -> w2, 0.5) / this -> o;` (::private)
 * - `double r = std::pow(1 - this -> beta_lep * this -> beta_lep, 0.5);` (::private)
 * - `double a = this -> beta_lep * this -> w * this -> wr * 1.0 / r;` (::private)
 * - `double b = std::pow(1 + this -> w2, 0.5) / (3 * this -> o * r);` (::private)
 * - `this -> t_0 = std::asinh(a) - std::asinh(b);` (::private)
 * - `Rz.at(0, 0) =  std::cos(this -> phi_mu);` (::private)
 * - `Rz.at(0, 1) = -std::sin(this -> phi_mu);` (::private)
 * - `Rz.at(1, 0) = std::sin(this -> phi_mu);` (::private)
 * - `Rz.at(1, 1) = std::cos(this -> phi_mu);` (::private)
 * - `Ry.at(0, 0) = std::cos(this -> theta_mu);` (::private)
 * - `Ry.at(0, 2) = std::sin(this -> theta_mu);` (::private)
 * - `Ry.at(2, 0) = -std::sin(this -> theta_mu);` (::private)
 * - `Ry.at(2, 2) =  std::cos(this -> theta_mu);` (::private)
 * - `double alpha = -std::atan2(b_p.at(2, 0), b_p.at(1, 0));` (::private)
 * - `Rx.at(1, 1) =  std::cos(alpha);` (::private)
 * - `Rx.at(1, 2) = -std::sin(alpha);` (::private)
 * - `Rx.at(2, 1) =  std::sin(alpha);` (::private)
 * - `Rx.at(2, 2) =  std::cos(alpha);` (::private)
 * - `this -> B = - std::pow(this -> mass_lep / this -> e_lep, 2) * (1.0 / this -> o2)` (::private)
 * - `this -> s0x = - std::pow(this -> mass_lep, 2) / this -> p_lep;` (::private)
 * - `this -> psi = std::atan(this -> w);` (::private)
 * - `double _z = this -> A * _sx * _sx + this -> B * _sy * _sy + this -> C * _sx * _s` (::private)
 * - `return (_z >= 0) ? std::pow(_z, 0.5) : -1.0;` (::private)
 * - `double r = this -> o / this -> beta_lep * (_vp / _up);` (::private)
 * - `double _t = 0;` (::private)
 * - `if (_up > 0 && std::fabs(r) < 1){_t = std::atanh(r);}` (::private)
 * - `else if (_up < 0 && _vp < 0){_t = std::asinh(_vp / _z);}` (::private)
 * - `else {_t = std::acosh(fabs(_up) * this -> beta_lep / (_z * this -> o))*(1 - 2 * ` (::private)
 * - `double sh = std::sinh(_t);` (::private)
 * - `double ch = std::cosh(_t);` (::private)
 */

/** @} */
