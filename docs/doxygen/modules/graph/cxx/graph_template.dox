/**
 * @file graph_template.cxx
 * @brief Documentation for modules/graph/cxx/graph_template.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/graph/cxx/graph_template.cxx
 */

/**
 * @defgroup modules_graph_cxx_graph_template_cxx graph_template.cxx
 * @brief graph_template.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `graph_template::graph_template(){ this -> op = new torch::TensorOptions(torch::kCPU);`
 * - `this -> op = new torch::TensorOptions(torch::kCPU);`
 * - `this -> name.set_setter(this -> set_name);`
 * - `this -> name.set_object(this);`
 * - `this -> preselection.set_setter(this -> set_preselection);`
 * - `this -> preselection.set_getter(this -> get_preselection);`
 * - `this -> preselection.set_object(this);`
 * - `this -> hash.set_getter(this -> get_hash);`
 * - `this -> hash.set_object(this);`
 * - `this -> tree.set_getter(this -> get_tree);`
 * - `this -> tree.set_object(this);`
 * - `this -> index.set_getter(this -> get_index);`
 * - `this -> index.set_object(this);`
 * - `this -> weight.set_getter(this -> get_weight);`
 * - `this -> weight.set_object(this);`
 * - `graph_template::~graph_template(){ if (!this -> op){return;}`
 * - `if (!this -> op){return;}`
 * - `bool graph_template::operator == (graph_template& p){ return this -> hash == p.hash;`
 * - `graph_template* graph_template::clone(){ return new graph_template();`
 * - `return new graph_template();`
 * - `void graph_template::flush_particles(){ this -> m_event = nullptr;`
 * - `for (size_t x(0); x < this -> garbage.size(); ++x){`
 * - `if (!this -> garbage[x]){continue;}`
 * - `this -> garbage.clear();`
 * - `void graph_template::define_particle_nodes(std::vector<particle_template*>* prt){ for (size_t x(0); `
 * - `for (size_t x(0); x < prt -> size(); ++x){`
 * - `std::string hash_ = (*prt)[x] -> hash;`
 * - `if (this -> nodes.count(hash_)){continue;}`
 * - `int n_nodes = (int)this -> nodes.size();`
 * - `this -> node_particles[n_nodes] = (*prt)[x];`
 * - `this -> num_nodes = this -> nodes.size();`
 * - `void graph_template::define_topology(std::function<bool(particle_template*, particle_template*)> fx)`
 * - `for (itr1 = this -> node_particles.begin(); itr1 != this -> node_particles.end(); ++itr1){`
 * - `for (itr2 = this -> node_particles.begin(); itr2 != this -> node_particles.end(); ++itr2){`
 * - `if (!fx(itr1 -> second, itr2 -> second)){ this -> _topology.push_back({});`
 * - `this -> _topology.push_back({});`
 * - `this -> _topological_index.push_back(-1);`
 * - `src_.push_back(itr1 -> first);`
 * - `dst_.push_back(itr2 -> first);`
 * - `this -> _topology.push_back({itr1 -> first, itr2 -> first});`
 * - `this -> _topological_index.push_back(idx);`
 * - `torch::Tensor t1 = this -> to_tensor(src_, torch::kInt, int()).view({1, -1});`
 * - `torch::Tensor t2 = this -> to_tensor(dst_, torch::kInt, int()).view({1, -1});`
 * - `this -> m_topology = torch::cat({t1, t2}, 0);`
 * - `graph_t* graph_template::data_export(){  std::map<std::string, torch::Tensor*> g_tru_t = {};`
 * - `std::map<std::string, int>* g_tru_i = new std::map<std::string, int>();`
 * - `std::map<std::string, int>* g_dat_i = new std::map<std::string, int>();`
 * - `this -> build_export(&g_tru_t, g_tru_i, &g_dat_t, g_dat_i, &this -> graph_fx);`
 * - `std::map<std::string, int>* n_tru_i = new std::map<std::string, int>();`
 * - `std::map<std::string, int>* n_dat_i = new std::map<std::string, int>();`
 * - `this -> build_export(&n_tru_t, n_tru_i, &n_dat_t, n_dat_i, &this -> node_fx);`
 * - `std::map<std::string, int>* e_tru_i = new std::map<std::string, int>();`
 * - `std::map<std::string, int>* e_dat_i = new std::map<std::string, int>();`
 * - `this -> build_export(&e_tru_t, e_tru_i, &e_dat_t, e_dat_i, &this -> edge_fx);`
 * - `graph_t* gr = new graph_t();`
 * - `gr -> edge_index = new torch::Tensor(this -> m_topology);`
 * - `gr -> add_truth_graph(&g_tru_t, g_tru_i);`
 * - `gr -> add_truth_node(&n_tru_t, n_tru_i);`
 * - `gr -> add_truth_edge(&e_tru_t, e_tru_i);`
 * - `gr -> add_data_graph(&g_dat_t, g_dat_i);`
 * - `gr -> add_data_node(&n_dat_t, n_dat_i);`
 * - `gr -> add_data_edge(&e_dat_t, e_dat_i);`
 * - `gr -> graph_name   = new std::string(this -> name);`
 * - `graph_template* graph_template::build(event_template* ev){ event_t* data_ = &ev -> data;`
 * - `graph_template* gr = this -> clone();`
 * - `void graph_template::CompileEvent(){} bool graph_template::PreSelection(){return true;}`
 * - `bool graph_template::PreSelection(){return true;}`
 */

/**
 * @section variables Variables
 *
 * - `this -> op = new torch::TensorOptions(torch::kCPU);` (::private)
 * - `bool graph_template::operator == (graph_template& p){` (::private)
 * - `std::string hash_ = (*prt)[x] -> hash;` (::private)
 * - `int n_nodes = (int)this -> nodes.size();` (::private)
 * - `int idx = 0;` (::private)
 * - `std::vector<int> src_, dst_ = {};` (::private)
 * - `torch::Tensor t1 = this -> to_tensor(src_, torch::kInt, int()).view({1, -1});` (::private)
 * - `torch::Tensor t2 = this -> to_tensor(dst_, torch::kInt, int()).view({1, -1});` (::private)
 * - `this -> m_topology = torch::cat({t1, t2}, 0);` (::private)
 * - `std::map<std::string, torch::Tensor*> g_tru_t = {};` (::private)
 * - `std::map<std::string, torch::Tensor*> g_dat_t = {};` (::private)
 * - `std::map<std::string, int>* g_tru_i = new std::map<std::string, int>();` (::private)
 * - `std::map<std::string, int>* g_dat_i = new std::map<std::string, int>();` (::private)
 * - `std::map<std::string, torch::Tensor*> n_tru_t = {};` (::private)
 * - `std::map<std::string, torch::Tensor*> n_dat_t = {};` (::private)
 * - `std::map<std::string, int>* n_tru_i = new std::map<std::string, int>();` (::private)
 * - `std::map<std::string, int>* n_dat_i = new std::map<std::string, int>();` (::private)
 * - `std::map<std::string, torch::Tensor*> e_tru_t = {};` (::private)
 * - `std::map<std::string, torch::Tensor*> e_dat_t = {};` (::private)
 * - `std::map<std::string, int>* e_tru_i = new std::map<std::string, int>();` (::private)
 * - `std::map<std::string, int>* e_dat_i = new std::map<std::string, int>();` (::private)
 * - `gr -> edge_index = new torch::Tensor(this -> m_topology);` (::private)
 * - `gr -> graph_name   = new std::string(this -> name);` (::private)
 */

/** @} */
