/**
 * @file graph_template.h
 * @brief Documentation for modules/graph/include/templates/graph_template.h
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/graph/include/templates/graph_template.h
 */

/**
 * @defgroup modules_graph_include_templates_graph_template_h graph_template.h
 * @brief graph_template.h
 * @{
 */

/**
 * @section classes Classes and Structures
 *
 * - **graph_template** (class)
 * - **dataloader** (class)
 * - **container** (class)
 * - **analysis** (class)
 * - **meta** (class)
 * - **graph_t** (struct)
 * - **graph_template** (class)
 */

/**
 * @section functions Functions
 *
 * - `torch::Tensor* get_truth_graph(std::string _name, g* mdl){ return this -> has_feature(graph_enum::tr` (graph_t::public)
 * - `return this -> has_feature(graph_enum::truth_graph, _name, mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_truth_node(std::string _name, g* mdl){ return this -> has_feature(graph_enum::tru` (graph_t::public)
 * - `return this -> has_feature(graph_enum::truth_node, _name, mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_truth_edge(std::string _name, g* mdl){ return this -> has_feature(graph_enum::tru` (graph_t::public)
 * - `return this -> has_feature(graph_enum::truth_edge, _name, mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_data_graph(std::string _name, g* mdl){ return this -> has_feature(graph_enum::dat` (graph_t::public)
 * - `return this -> has_feature(graph_enum::data_graph, _name, mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_data_node(std::string _name, g* mdl){ return this -> has_feature(graph_enum::data` (graph_t::public)
 * - `return this -> has_feature(graph_enum::data_node, _name, mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_data_edge(std::string _name, g* mdl){ return this -> has_feature(graph_enum::data` (graph_t::public)
 * - `return this -> has_feature(graph_enum::data_edge, _name, mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_edge_index(g* mdl){ return this -> has_feature(graph_enum::edge_index, "", mdl ->` (graph_t::public)
 * - `return this -> has_feature(graph_enum::edge_index, "", mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_event_weight(g* mdl){ return this -> has_feature(graph_enum::weight, "", mdl -> d` (graph_t::public)
 * - `return this -> has_feature(graph_enum::weight, "", mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_batch_index(g* mdl){ return this -> has_feature(graph_enum::batch_index, "", mdl ` (graph_t::public)
 * - `return this -> has_feature(graph_enum::batch_index, "", mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* get_batched_events(g* mdl){ return this -> has_feature(graph_enum::batch_events, "", ` (graph_t::public)
 * - `return this -> has_feature(graph_enum::batch_events, "", mdl -> device_index);` (graph_t::public)
 * - `torch::Tensor* has_feature(graph_enum tp, std::string _name, int dev);` (graph_t::public)
 * - `void add_truth_graph(std::map<std::string, torch::Tensor*>* data, std::map<std::string, int>* maps);` (graph_t::public)
 * - `void add_truth_node( std::map<std::string, torch::Tensor*>* data, std::map<std::string, int>* maps);` (graph_t::public)
 * - `void add_truth_edge( std::map<std::string, torch::Tensor*>* data, std::map<std::string, int>* maps);` (graph_t::public)
 * - `void add_data_graph( std::map<std::string, torch::Tensor*>* data, std::map<std::string, int>* maps);` (graph_t::public)
 * - `void add_data_node(  std::map<std::string, torch::Tensor*>* data, std::map<std::string, int>* maps);` (graph_t::public)
 * - `void add_data_edge(  std::map<std::string, torch::Tensor*>* data, std::map<std::string, int>* maps);` (graph_t::public)
 * - `void transfer_to_device(torch::TensorOptions* dev);` (graph_t::public)
 * - `void _purge_all();` (graph_t::public)
 * - `void meta_serialize(std::map<std::string, int>* data, std::string* out);` (graph_t::private)
 * - `void meta_serialize(std::vector<torch::Tensor*>* data, std::string* out);` (graph_t::private)
 * - `void meta_serialize(torch::Tensor* data, std::string* out);` (graph_t::private)
 * - `void serialize(graph_hdf5* m_hdf5);` (graph_t::private)
 * - `void meta_deserialize(std::map<std::string, int>* data, std::string* inpt);` (graph_t::private)
 * - `void meta_deserialize(std::vector<torch::Tensor*>* data, std::string* inpt);` (graph_t::private)
 * - `torch::Tensor* meta_deserialize(std::string* inpt);` (graph_t::private)
 * - `void deserialize(graph_hdf5* m_hdf5);` (graph_t::private)
 * - `void _purge_data(std::vector<torch::Tensor*>* data);` (graph_t::private)
 * - `void _purge_data(std::map<int, torch::Tensor*>* data);` (graph_t::private)
 * - `void _purge_data(std::map<int, std::vector<torch::Tensor*>*>* data);` (graph_t::private)
 * - `std::vector<torch::Tensor*>* add_content(std::map<std::string, torch::Tensor*>* inpt);` (graph_t::private)
 * - `bool static fulltopo(particle_template*, particle_template*){return true;};`
 * - `graph_template();`
 * - `virtual ~graph_template();`
 * - `virtual graph_template* clone();`
 * - `virtual void CompileEvent();`
 * - `virtual bool PreSelection();`
 * - `void define_particle_nodes(std::vector<particle_template*>* prt);`
 * - `void define_topology(std::function<bool(particle_template*, particle_template*)> fx);`
 * - `void flush_particles();`
 * - `bool operator == (graph_template& p);`
 * - `G* get_event(){return (G*)this -> m_event;}`
 * - `void add_graph_truth_feature(O* ev, X fx, std::string _name){ cproperty<G, O> cdef;`
 * - `cdef.set_getter(fx);`
 * - `cdef.set_object(ev);`
 * - `this -> add_graph_feature(r, "T-" + _name);`
 * - `void add_graph_data_feature(O* ev, X fx, std::string _name){ cproperty<G, O> cdef;`
 * - `this -> add_graph_feature(r, "D-" + _name);`
 * - `void add_node_truth_feature(X fx, std::string _name){ std::vector<G> nodes_data = {};`
 * - `std::map<int, particle_template*>::iterator itr = this -> node_particles.begin();`
 * - `for (; itr != this -> node_particles.end(); ++itr){`
 * - `cdef.set_object((O*)itr -> second);`
 * - `nodes_data.push_back((G)cdef);`
 * - `this -> add_node_feature(nodes_data, "T-" + _name);`
 * - `void add_node_data_feature(X fx, std::string _name){ std::vector<G> nodes_data = {};`
 * - `this -> add_node_feature(nodes_data, "D-" + _name);`
 * - `void add_edge_truth_feature(X fx, std::string _name){ int dx = -1;`
 * - `if (!this -> _topological_index.size()){this -> define_topology(fulltopo);}`
 * - `for (itr1 = this -> node_particles.begin(); itr1 != this -> node_particles.end(); ++itr1){`
 * - `for (itr2 = this -> node_particles.begin(); itr2 != this -> node_particles.end(); ++itr2){`
 * - `if (this -> _topological_index[dx] < 0){continue;}`
 * - `std::tuple<O*, O*> p_ij((O*)itr1 -> second, (O*)itr2 -> second);`
 * - `cdef.set_object(&p_ij);`
 * - `edge_data.push_back(cdef);`
 * - `this -> add_edge_feature(edge_data, "T-" + _name);`
 * - `void add_edge_data_feature(X fx, std::string _name){ int dx = -1;`
 * - `std::tuple<O*, O*> p_ij(itr1 -> second, itr2 -> second);`
 * - `this -> add_edge_feature(edge_data, "D-" + _name);`
 * - `void add_graph_feature(bool, std::string);`
 * - `void add_graph_feature(std::vector<bool>, std::string);`
 * - `void add_graph_feature(float, std::string);`
 * - `void add_graph_feature(std::vector<float>, std::string);`
 * - `void add_graph_feature(double, std::string);`
 * - `void add_graph_feature(std::vector<double>, std::string);`
 * - `void add_graph_feature(long, std::string);`
 * - `void add_graph_feature(std::vector<long>, std::string);`
 * - `void add_graph_feature(int, std::string);`
 * - `void add_graph_feature(std::vector<int>, std::string);`
 * - `void add_graph_feature(std::vector<std::vector<int>>, std::string);`
 * - `void add_node_feature(bool, std::string);`
 * - `void add_node_feature(std::vector<bool>, std::string);`
 * - `void add_node_feature(float, std::string);`
 * - `void add_node_feature(std::vector<float>, std::string);`
 * - `void add_node_feature(double, std::string);`
 * - `void add_node_feature(std::vector<double>, std::string);`
 * - `void add_node_feature(long, std::string);`
 * - `void add_node_feature(std::vector<long>, std::string);`
 * - `void add_node_feature(int, std::string);`
 * - `void add_node_feature(std::vector<int>, std::string);`
 * - `void add_node_feature(std::vector<std::vector<int>>, std::string);`
 * - `void add_edge_feature(bool, std::string);`
 * - `void add_edge_feature(std::vector<bool>, std::string);`
 * - `void add_edge_feature(float, std::string);`
 * - `void add_edge_feature(std::vector<float>, std::string);`
 * - `void add_edge_feature(double, std::string);`
 * - `void add_edge_feature(std::vector<double>, std::string);`
 * - `void add_edge_feature(long, std::string);`
 * - `void add_edge_feature(std::vector<long>, std::string);`
 * - `void add_edge_feature(int, std::string);`
 * - `void add_edge_feature(std::vector<int>, std::string);`
 * - `void add_edge_feature(std::vector<std::vector<int>>, std::string);`
 * - `torch::Tensor to_tensor(std::vector<G> _data, at::ScalarType _op, g prim){ return build_tensor(&_dat`
 * - `return build_tensor(&_data, _op, prim, this -> op);`
 * - `void static set_name(std::string*, graph_template*);`
 * - `void static set_preselection(bool*, graph_template*);`
 * - `void static get_hash(std::string*, graph_template*);`
 * - `void static get_index(long*, graph_template*);`
 * - `void static get_weight(double*, graph_template*);`
 * - `void static get_tree(std::string*, graph_template*);`
 * - `void static get_preselection(bool*, graph_template*);`
 * - `graph_template* build(event_template* el);`
 * - `graph_t* data_export();`
 */

/**
 * @section variables Variables
 *
 * - `int       num_nodes = 0;` (graph_t::public)
 * - `long    event_index = 0;` (graph_t::public)
 * - `double event_weight = 1;` (graph_t::public)
 * - `bool   preselection = false;` (graph_t::public)
 * - `std::vector<long> batched_events = {};` (graph_t::public)
 * - `std::vector<std::string*> batched_filenames = {};` (graph_t::public)
 * - `std::string* hash       = nullptr;` (graph_t::public)
 * - `std::string* filename   = nullptr;` (graph_t::public)
 * - `std::string* graph_name = nullptr;` (graph_t::public)
 * - `int in_use = 1;` (graph_t::public)
 * - `bool is_owner = false;` (graph_t::private)
 * - `std::mutex mut;` (graph_t::private)
 * - `torch::Tensor* edge_index = nullptr;` (graph_t::private)
 * - `std::map<std::string, int>* data_map_graph = nullptr;` (graph_t::private)
 * - `std::map<std::string, int>* data_map_node  = nullptr;` (graph_t::private)
 * - `std::map<std::string, int>* data_map_edge  = nullptr;` (graph_t::private)
 * - `std::map<std::string, int>* truth_map_graph = nullptr;` (graph_t::private)
 * - `std::map<std::string, int>* truth_map_node  = nullptr;` (graph_t::private)
 * - `std::map<std::string, int>* truth_map_edge  = nullptr;` (graph_t::private)
 * - `std::vector<torch::Tensor*>* data_graph = nullptr;` (graph_t::private)
 * - `std::vector<torch::Tensor*>* data_node  = nullptr;` (graph_t::private)
 * - `std::vector<torch::Tensor*>* data_edge  = nullptr;` (graph_t::private)
 * - `std::vector<torch::Tensor*>* truth_graph = nullptr;` (graph_t::private)
 * - `std::vector<torch::Tensor*>* truth_node  = nullptr;` (graph_t::private)
 * - `std::vector<torch::Tensor*>* truth_edge  = nullptr;` (graph_t::private)
 * - `std::map<int, std::vector<torch::Tensor>> dev_data_graph = {};` (graph_t::private)
 * - `std::map<int, std::vector<torch::Tensor>> dev_data_node  = {};` (graph_t::private)
 * - `std::map<int, std::vector<torch::Tensor>> dev_data_edge  = {};` (graph_t::private)
 * - `std::map<int, std::vector<torch::Tensor>> dev_truth_graph = {};` (graph_t::private)
 * - `std::map<int, std::vector<torch::Tensor>> dev_truth_node  = {};` (graph_t::private)
 * - `std::map<int, std::vector<torch::Tensor>> dev_truth_edge  = {};` (graph_t::private)
 * - `std::map<int, torch::Tensor> dev_edge_index   = {};` (graph_t::private)
 * - `std::map<int, torch::Tensor> dev_batch_index  = {};` (graph_t::private)
 * - `std::map<int, torch::Tensor> dev_event_weight = {};` (graph_t::private)
 * - `std::map<int, torch::Tensor> dev_batched_events = {};` (graph_t::private)
 * - `std::map<int, bool> device_index = {};` (graph_t::private)
 * - `std::string _name, int dev_);` (graph_t::private)
 * - `bool operator == (graph_template& p);` (::private)
 * - `int threadIdx = -1;` (::private)
 * - `std::string filename = "";` (::private)
 * - `std::vector<G> nodes_data = {};` (::private)
 * - `std::map<int, particle_template*>::iterator itr = this -> node_particles.begin()` (::private)
 * - `int dx = -1;` (::private)
 * - `std::vector<G> edge_data = {};` (::private)
 * - `int num_nodes = 0;` (::private)
 * - `std::map<std::string, int> nodes = {};` (::private)
 * - `std::map<int, particle_template*> node_particles = {};` (::private)
 * - `std::map<std::string, torch::Tensor> graph_fx = {};` (::private)
 * - `std::map<std::string, torch::Tensor> node_fx  = {};` (::private)
 * - `std::map<std::string, torch::Tensor> edge_fx  = {};` (::private)
 * - `std::vector<particle_template*> garbage = {};` (::private)
 * - `torch::TensorOptions* op = nullptr;` (::private)
 * - `bool m_preselection = false;` (::private)
 */

/** @} */
