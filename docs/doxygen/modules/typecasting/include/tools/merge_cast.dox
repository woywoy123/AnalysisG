/**
 * @file merge_cast.h
 * @brief Documentation for modules/typecasting/include/tools/merge_cast.h
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/typecasting/include/tools/merge_cast.h
 */

/**
 * @defgroup modules_typecasting_include_tools_merge_cast_h merge_cast.h
 * @brief merge_cast.h
 * @{
 */

/**
 * @section functions Functions
 *
 * - `void merge_data(std::vector<G>* out, std::vector<G>* p2){ out -> insert(out -> end(), p2 -> begin(),`
 * - `out -> insert(out -> end(), p2 -> begin(), p2 -> end());`
 * - `void merge_data(G* out, G* p2){(*out) = *p2;}`
 * - `void merge_data(std::map<g, G>* out, std::map<g, G>* p2){ typename std::map<g, G>::iterator itr = p2`
 * - `typename std::map<g, G>::iterator itr = p2 -> begin();`
 * - `for (; itr != p2 -> end(); ++itr){merge_data(&(*out)[itr -> first], &itr -> second);}`
 * - `void sum_data(G* out, G* p2){(*out) += (*p2);}`
 * - `void sum_data(std::vector<G>* out, std::vector<G>* p2){ out -> insert(out -> end(), p2 -> begin(), p`
 * - `void sum_data(std::map<g, G>* out, std::map<g, G>* p2){ typename std::map<g, G>::iterator itr = p2 -`
 * - `for (; itr != p2 -> end(); ++itr){sum_data(&(*out)[itr -> first], &itr -> second);}`
 * - `void reserve_count(g* inp, long* ix){*ix += 1;}`
 * - `void reserve_count(std::vector<g>* inp, long* ix){ for (size_t x(0); x < inp -> size(); ++x){reserve`
 * - `for (size_t x(0); x < inp -> size(); ++x){reserve_count(&inp -> at(x), ix);}`
 * - `void contract_data(std::vector<g>* out, g* p2){out -> push_back(*p2);}`
 * - `void contract_data(std::vector<g>* out, std::vector<g>* p2){ for (size_t i(0); i < p2 -> size(); ++i`
 * - `for (size_t i(0); i < p2 -> size(); ++i){contract_data(out, &p2 -> at(i));}`
 * - `void contract_data(std::vector<g>* out, std::vector<std::vector<g>>* p2){ long ix = 0;`
 * - `reserve_count(p2, &ix);`
 * - `out -> reserve(ix);`
 * - `void release_vector(std::vector<g>* ipt){ ipt -> shrink_to_fit(); }`
 */

/**
 * @section variables Variables
 *
 * - `typename std::map<g, G>::iterator itr = p2 -> begin();` (::private)
 * - `long ix = 0;` (::private)
 */

/** @} */
