/**
 * @file analysis.cxx
 * @brief Documentation for modules/analysis/analysis.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/analysis/analysis.cxx
 */

/**
 * @defgroup modules_analysis_analysis_cxx analysis.cxx
 * @brief analysis.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `analysis::analysis(){ this -> prefix = "Analysis";`
 * - `this -> tags    = new std::vector<folds_t>();`
 * - `this -> tracer  = new sampletracer();`
 * - `this -> loader  = new dataloader();`
 * - `this -> reader  = new io();`
 * - `std::string cur = this -> absolute_path("./");`
 * - `std::string tmp = std::string(dict_path) + "pcm/";`
 * - `this -> create_path(tmp);`
 * - `int opx = static_cast<int>(data_enum::undef);`
 * - `int opc = this -> ls(tmp, ".pcm").size();`
 * - `if (opx-6 > opc){this -> info("Building PCM files... to:" + tmp);}`
 * - `gSystem -> SetBuildDir(tmp.c_str(), true);`
 * - `gSystem -> ChangeDirectory(tmp.c_str());`
 * - `gSystem -> AddDynamicPath(tmp.c_str());`
 * - `gSystem -> SetAclicMode(TSystem::kOpt);`
 * - `std::string mta = std::string(dict_path) + "structs/include/structs/meta.h";`
 * - `tm = new std::thread(buildDict, "meta_t"   , mta);`
 * - `tm -> join(); delete tm;`
 * - `tm = new std::thread(buildDict, "weights_t", mta);`
 * - `tm = new std::thread(buildAll);`
 * - `gSystem -> ChangeDirectory(cur.c_str());`
 * - `analysis::~analysis(){ for (size_t x(0); x < this -> tags -> size(); ++x){(*this -> tags)[x].flush_d`
 * - `for (size_t x(0); x < this -> tags -> size(); ++x){(*this -> tags)[x].flush_data();}`
 * - `flush(&this -> trainer);`
 * - `flush(&this -> model_metrics);`
 * - `flush(&this -> metric_names);`
 * - `void analysis::add_samples(std::string path, std::string label){ if (this -> ends_with(&path, ".root`
 * - `if (this -> ends_with(&path, ".root")){path = this -> absolute_path(path);}`
 * - `else if (this -> ends_with(&path, "*")){ std::vector<std::string> vx = this -> ls(path);`
 * - `std::vector<std::string> vx = this -> ls(path);`
 * - `for (size_t x(0); x < vx.size(); ++x){this -> add_samples(vx[x], label);}`
 * - `if (!this -> ends_with(&path, ".root")){return;}`
 * - `void analysis::add_event_template(event_template* ev, std::string label){ this -> event_labels[label`
 * - `void analysis::add_graph_template(graph_template* ev, std::string label){ this -> graph_labels[label`
 * - `void analysis::add_selection_template(selection_template* sel){ this -> selection_names[sel -> name]`
 * - `void analysis::add_metric_template(metric_template* mx, model_template* mdl){ this -> safe_clone(&th`
 * - `this -> safe_clone(&this -> model_metrics, mdl); this -> safe_clone(&this -> metric_names, mx);`
 * - `if (this -> metric_names[mx -> name] -> link(this -> model_metrics[mdl -> name])){return;}`
 * - `abort();`
 * - `void analysis::add_model(model_template* model, optimizer_params_t* op, std::string run_name){ std::`
 * - `this -> model_session_names.push_back(run_name);`
 * - `this -> model_sessions.push_back(para);`
 * - `void analysis::add_model(model_template* model, std::string run_name){ this -> model_session_names.p`
 * - `void analysis::build_project(){ this -> create_path(this -> m_settings.output_path);`
 * - `this -> create_path(this -> m_settings.output_path);`
 * - `for (size_t x(0); x < this -> model_session_names.size(); ++x){`
 * - `model_template* mdl = std::get<0>(this -> model_sessions.at(x));`
 * - `pth += std::string(mdl -> name) + "/";`
 * - `std::map<std::string, metric_template*>::iterator itm = this -> metric_names.begin();`
 * - `for (; itm != this -> metric_names.end(); ++itm){`
 * - `void analysis::check_cache(){ std::string pth_cache = this -> m_settings.graph_cache;`
 * - `std::vector<std::string> cache = this -> ls(pth_cache, ".h5");`
 * - `std::map<std::string, std::string>::iterator tx = this -> file_labels.begin();`
 * - `for (; tx != this -> file_labels.end(); ++tx){`
 * - `if (this -> graph_labels.count(lbl)){ std::map<std::string, graph_template*>::iterator itg;`
 * - `itg = this -> graph_labels[lbl].begin();`
 * - `for (; itg != this -> graph_labels[lbl].end(); ++itg){`
 * - `graph_cache.push_back(itg -> first);`
 * - `std::vector<std::string> files = this -> ls(lbl, ".root");`
 * - `if (this -> ends_with(&base, ".root")){files.push_back(tx -> first);}`
 * - `for (size_t x(0); x < files.size(); ++x){`
 * - `std::vector<std::string> spl = this -> split(file_n, "/");`
 * - `std::string fname = this -> hash(spl[spl.size()-1]) + "-" + spl[spl.size()-1];`
 * - `this -> replace(&fname, ".root", ".h5");`
 * - `for (size_t y(0); y < graph_cache.size(); ++y){`
 * - `for (size_t y(0); y < cache.size(); ++y){`
 * - `std::vector<std::string> spl_ = this -> split(cache[y], "/");`
 * - `std::string fname_ = spl_[spl_.size()-2] + "/" + spl_[spl_.size()-1];`
 * - `if (this -> has_string(&cache[y], "/." + spl_[spl_.size()-1])){continue;}`
 * - `if (!this -> in_cache[file_n].count(fname_)){continue;}`
 * - `if (s == sg && s){this -> skip_event_build[file_n] = true;}`
 * - `void analysis::fetchtags(){ if (this -> tags -> size()){return;}`
 * - `if (this -> tags -> size()){return;}`
 * - `io* io_g = new io();`
 * - `io_g -> start(this -> m_settings.training_dataset, "read");`
 * - `io_g -> read(this -> tags, "kfolds");`
 * - `io_g -> end();`
 * - `void analysis::start(){ this -> tracer -> shush = this -> m_settings.debug_mode;`
 * - `if (this -> tracer -> shush){this -> m_settings.threads = 1;}`
 * - `if (this -> m_settings.pretagevents){this -> fetchtags();}`
 * - `this -> create_path(this -> m_settings.output_path + "/");`
 * - `if (!this -> started){ this -> success("+============================+");`
 * - `this -> success("+============================+");`
 * - `this -> success("| Starting Analysis Session! |");`
 * - `this -> check_cache();`
 * - `this -> build_events();`
 * - `if (!this -> started){ if (!this -> event_labels.size() && !this -> graph_labels.size()){`
 * - `if (!this -> event_labels.size() && !this -> graph_labels.size()){ this -> reader -> import_settings`
 * - `this -> reader -> import_settings(&this -> m_settings);`
 * - `std::map<std::string, std::string>::iterator itf = this -> file_labels.begin();`
 * - `for (; itf != this -> file_labels.end(); ++itf){this -> reader -> root_files[itf -> first] = true;}`
 * - `this -> reader -> check_root_file_paths();`
 * - `this -> reader -> scan_keys();`
 * - `ROOT::EnableImplicitMT(threads_);`
 * - `if (pth_cache.size() && !this -> ends_with(&pth_cache, "/")){pth_cache += "/";}`
 * - `if (this -> selection_names.size()){this -> build_selections();}`
 * - `if (this -> graph_labels.size()){this -> build_graphs();}`
 * - `this -> tracer -> compile_objects(threads_);`
 * - `if (this -> selection_names.size()){return this -> tracer -> fill_selections(&this -> selection_name`
 * - `this -> build_dataloader(false);`
 * - `this -> build_metric_folds();`
 * - `if (this -> m_settings.build_cache && !this -> loader -> data_set -> size()){return;}`
 * - `if (pth_cache.size() && this -> loader -> data_set -> size()){this -> loader -> dump_graphs(pth_cach`
 * - `else if (pth_cache.size() && this -> file_labels.size()){ std::vector<std::string> cached = {};`
 * - `std::map<std::string, std::string>::iterator itg = this -> graph_types.begin();`
 * - `for (; itg != this -> graph_types.end(); ++itg){`
 * - `std::map<std::string, std::string>::iterator itc = this -> file_labels.begin();`
 * - `for (; itc != this -> file_labels.end(); ++itc){`
 * - `std::vector<std::string> spl = this -> split(itc -> first, "/");`
 * - `cached.push_back(pth_cache + itg -> first + "/" + fname);`
 * - `this -> loader -> restore_graphs(cached, threads_);`
 * - `else if (pth_cache.size()){this -> loader -> restore_graphs(pth_cache, threads_);}`
 * - `if (!this -> build_metric()){return;}`
 * - `if (this -> model_sessions.size()){ if (!this -> loader -> data_set -> size()){return this -> failur`
 * - `if (!this -> loader -> data_set -> size()){return this -> failure("No Dataset was found for training`
 * - `this -> loader -> restore_dataset(this -> m_settings.training_dataset);`
 * - `this -> build_dataloader(true);`
 * - `this -> loader -> start_cuda_server();`
 * - `this -> build_project();`
 * - `this -> build_model_session();`
 * - `if (this -> model_inference.size()){ if (!this -> loader -> data_set -> size()){return this -> failu`
 * - `if (!this -> loader -> data_set -> size()){return this -> failure("No Dataset was found for inferenc`
 * - `this -> build_inference();`
 */

/**
 * @section variables Variables
 *
 * - `this -> tags    = new std::vector<folds_t>();` (::private)
 * - `std::string cur = this -> absolute_path("./");` (::private)
 * - `std::string tmp = std::string(dict_path) + "pcm/";` (::private)
 * - `int opx = static_cast<int>(data_enum::undef);` (::private)
 * - `int opc = this -> ls(tmp, ".pcm").size();` (::private)
 * - `std::string mta = std::string(dict_path) + "structs/include/structs/meta.h";` (::private)
 * - `std::thread* tm = nullptr;` (::private)
 * - `tm = new std::thread(buildDict, "meta_t"   , mta);` (::private)
 * - `tm = new std::thread(buildDict, "weights_t", mta);` (::private)
 * - `tm = new std::thread(buildAll);` (::private)
 * - `std::vector<std::string> vx = this -> ls(path);` (::private)
 * - `std::tuple<model_template*, optimizer_params_t*> para = {model, op};` (::private)
 * - `std::string model_path = this -> m_settings.output_path;` (::private)
 * - `model_template* mdl = std::get<0>(this -> model_sessions.at(x));` (::private)
 * - `std::string pth = model_path + "/";` (::private)
 * - `pth += std::string(mdl -> name) + "/";` (::private)
 * - `std::map<std::string, metric_template*>::iterator itm = this -> metric_names.beg` (::private)
 * - `std::string pth_cache = this -> m_settings.graph_cache;` (::private)
 * - `std::vector<std::string> cache = this -> ls(pth_cache, ".h5");` (::private)
 * - `std::map<std::string, std::string> relabel = {};` (::private)
 * - `std::map<std::string, std::string>::iterator tx = this -> file_labels.begin();` (::private)
 * - `std::string base = tx -> first;` (::private)
 * - `std::string lbl  = tx -> second;` (::private)
 * - `std::vector<std::string> graph_cache = {};` (::private)
 * - `std::vector<std::string> files = this -> ls(lbl, ".root");` (::private)
 * - `std::string file_n = files[x];` (::private)
 * - `std::vector<std::string> spl = this -> split(file_n, "/");` (::private)
 * - `std::string fname = this -> hash(spl[spl.size()-1]) + "-" + spl[spl.size()-1];` (::private)
 * - `int s = 0;` (::private)
 * - `int sg = 0;` (::private)
 * - `std::vector<std::string> spl_ = this -> split(cache[y], "/");` (::private)
 * - `std::string fname_ = spl_[spl_.size()-2] + "/" + spl_[spl_.size()-1];` (::private)
 * - `std::map<std::string, std::string>::iterator itf = this -> file_labels.begin();` (::private)
 * - `int threads_ = this -> m_settings.threads;` (::private)
 * - `std::vector<std::string> cached = {};` (::private)
 * - `std::map<std::string, std::string>::iterator itg = this -> graph_types.begin();` (::private)
 * - `std::map<std::string, std::string>::iterator itc = this -> file_labels.begin();` (::private)
 * - `std::vector<std::string> spl = this -> split(itc -> first, "/");` (::private)
 */

/** @} */
