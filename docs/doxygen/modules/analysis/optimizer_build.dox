/**
 * @file optimizer_build.cxx
 * @brief Documentation for modules/analysis/optimizer_build.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/analysis/optimizer_build.cxx
 */

/**
 * @defgroup modules_analysis_optimizer_build_cxx optimizer_build.cxx
 * @brief optimizer_build.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `void analysis::build_model_session(){  if (!this -> model_sessions.size()){return this -> info("No M`
 * - `if (!this -> model_sessions.size()){return this -> info("No Models Specified. Skipping.");}`
 * - `if (!kfold.size()){for (int k(0); k < this -> m_settings.kfolds; ++k){kfold.push_back(k);}}`
 * - `else {for (size_t k(0); k < kfold.size(); ++k){kfold[k] = kfold[k]-1;}}`
 * - `for (size_t x(0); x < this -> model_sessions.size(); ++x){`
 * - `torch::TensorOptions* op = std::get<0>(this -> model_sessions[x]) -> m_option;`
 * - `int dx = op -> device().index();`
 * - `if (dev_map.count(dx)){continue;}`
 * - `this -> loader -> datatransfer(&dev_map);`
 * - `optimizer* optim = new optimizer();`
 * - `optim -> import_dataloader(this -> loader);`
 * - `optim -> import_model_sessions(&para);`
 * - `for (size_t k(0); k < this -> m_settings.kfold.size(); ++k){`
 * - `std::vector<graph_t*>* check = this -> loader -> get_k_train_set(k_);`
 * - `if (!check){continue;}`
 * - `if (this -> m_settings.debug_mode){initialize_loop(optim, k_, std::get<0>(para), std::get<1>(para), `
 * - `else {this -> threads.push_back(new std::thread(initialize_loop, optim, k_, std::get<0>(para), std::`
 * - `while (!mx){std::this_thread::sleep_for(std::chrono::microseconds(10));}`
 * - `this -> reports[mx -> run_name + std::to_string(mx -> k)] = mx;`
 * - `std::map<std::string, std::vector<float>> analysis::progress(){ std::map<std::string, std::vector<fl`
 * - `for (itx = this -> reports.begin(); itx != this -> reports.end(); ++itx){`
 * - `if (!mr -> num_evnt){mr -> num_evnt = 1;}`
 * - `mr -> progress = float(mr -> iters) / float(mr -> num_evnt);`
 * - `output[itx -> first] = {itx -> second -> progress*100, float(mr -> iters), float(mr -> num_evnt)};`
 * - `std::map<std::string, std::string> analysis::progress_mode(){ std::map<std::string, std::string> out`
 * - `o += "| k-" + std::to_string(itx -> second -> k+1);`
 * - `o += "| Epoch: " + std::to_string(itx -> second -> epoch);`
 * - `std::map<std::string, std::string> analysis::progress_report(){ std::map<std::string, std::string> o`
 * - `output[itx -> first] = itx -> second -> print();`
 * - `if (!plt){continue;}`
 * - `plt -> dump_plots(itx -> second -> k);`
 * - `std::map<std::string, bool> analysis::is_complete(){ std::map<std::string, bool> output;`
 * - `std::map<std::string, model_report*>::iterator itx = this -> reports.begin();`
 * - `for (; itx != this -> reports.end(); ++itx){output[itx -> first] = itx -> second -> is_complete;}`
 * - `void analysis::attach_threads(){this -> monitor(&this -> threads);}`
 */

/**
 * @section variables Variables
 *
 * - `std::vector<int> kfold = this -> m_settings.kfold;` (::private)
 * - `else {for (size_t k(0); k < kfold.size(); ++k){kfold[k] = kfold[k]-1;}}` (::private)
 * - `torch::TensorOptions* op = std::get<0>(this -> model_sessions[x]) -> m_option;` (::private)
 * - `int dx = op -> device().index();` (::private)
 * - `std::string name = this -> model_session_names[x];` (::private)
 * - `std::tuple<model_template*, optimizer_params_t*> para = this -> model_sessions[x` (::private)
 * - `int k_ = this -> m_settings.kfold[k];` (::private)
 * - `std::vector<graph_t*>* check = this -> loader -> get_k_train_set(k_);` (::private)
 * - `this -> reports[mx -> run_name + std::to_string(mx -> k)] = mx;` (::private)
 * - `std::string o = itx -> second -> mode;` (::private)
 * - `o += "| k-" + std::to_string(itx -> second -> k+1);` (::private)
 * - `o += "| Epoch: " + std::to_string(itx -> second -> epoch);` (::private)
 * - `std::map<std::string, model_report*>::iterator itx = this -> reports.begin();` (::private)
 */

/** @} */
