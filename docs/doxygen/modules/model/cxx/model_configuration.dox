/**
 * @file model_configuration.cxx
 * @brief Documentation for modules/model/cxx/model_configuration.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/modules/model/cxx/model_configuration.cxx
 */

/**
 * @defgroup modules_model_cxx_model_configuration_cxx model_configuration.cxx
 * @brief model_configuration.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `void model_template::clone_settings(model_settings_t* setd){ setd -> e_optim = this -> e_optim;`
 * - `model_template* model_template::clone(int){ model_template* mo = this -> clone();`
 * - `model_template* mo = this -> clone();`
 * - `this -> clone_settings(&mds);`
 * - `mo -> import_settings(&mds);`
 * - `void model_template::import_settings(model_settings_t* setd){ this -> e_optim = setd -> e_optim;`
 * - `void model_template::set_name(std::string* nx, model_template* md){md -> m_name = *nx;}`
 * - `void model_template::get_name(std::string* nx, model_template* md){*nx = md -> m_name;}`
 * - `void model_template::set_device(std::string* dev, model_template* md){ if (md -> m_option){delete md`
 * - `if (md -> m_option){delete md -> m_option; md -> m_option = nullptr;}`
 * - `std::string _device = md -> lower(dev);`
 * - `if (md -> has_string(&_device, "cuda:")){ device_enum = c10::kCUDA;`
 * - `device_n = std::stoi(md -> split(_device, ":")[1]);`
 * - `else if (md -> has_string(&_device, "cuda")){device_enum = c10::kCUDA; device_n = 0;}`
 * - `switch(device_enum){ case c10::kCPU:  md -> m_option = new torch::TensorOptions(device_enum); break;`
 * - `case c10::kCPU:  md -> m_option = new torch::TensorOptions(device_enum); break;`
 * - `case c10::kCUDA: md -> m_option = new torch::TensorOptions(device_enum, device_n); break;`
 * - `default: md -> m_option = new torch::TensorOptions(device_enum); break;`
 * - `for (size_t x(0); x < md -> m_data.size(); ++x){(*md -> m_data[x]) -> to(md -> m_option -> device(),`
 * - `void model_template::get_dev_index(int* nx, model_template* md){ if (!md -> m_option){*nx = -2; retu`
 * - `if (!md -> m_option){*nx = -2; return;}`
 * - `if (md -> m_device_idx == -2){md -> m_device_idx = md -> m_option -> device().index();}`
 * - `void model_template::set_dev_index(int*, model_template*){}  void model_template::set_optimizer(std:`
 * - `void model_template::set_optimizer(std::string _name){ this -> e_optim = this -> m_loss -> optim_str`
 * - `this -> e_optim = this -> m_loss -> optim_string(this -> lower(&_name));`
 * - `if (this -> e_optim != opt_enum::invalid_optimizer){} else {return this -> failure("Invalid Optimize`
 * - `else {return this -> failure("Invalid Optimizer");}`
 * - `this -> success("Using " + _name + " as Optimizer");`
 * - `void model_template::initialize(optimizer_params_t* op_params){ this -> prefix = this -> name;`
 * - `this -> info("------------- Checking Model Parameters ---------------");`
 * - `if (!this -> m_data.size()){return this -> failure("No parameters defined!");}`
 * - `this -> success("OK > Parameters defined.");`
 * - `bool in_feats = this -> m_i_graph.size();`
 * - `in_feats += this -> m_i_node.size();`
 * - `in_feats += this -> m_i_edge.size();`
 * - `if (!in_feats){return this -> failure("No input features defined!");}`
 * - `this -> success("OK > Input features defined.");`
 * - `bool o_feats = this -> m_o_graph.size();`
 * - `o_feats += this -> m_o_node.size();`
 * - `o_feats += this -> m_o_edge.size();`
 * - `if (!o_feats){return this -> failure("No ouput features defined!");}`
 * - `this -> success("OK > Output features defined.");`
 * - `if (!this -> s_optim.size()){return this -> failure("Failed to register Optimizer!");}`
 * - `this -> success("OK > Optimizer defined.");`
 * - `for (size_t x(0); x < this -> m_data.size(); ++x){`
 * - `std::vector<torch::Tensor> p_ = (*this -> m_data[x]).ptr() -> parameters();`
 * - `params.insert(params.end(), p_.begin(), p_.end());`
 * - `this -> m_optim = this -> m_loss -> build_optimizer(op_params, &params);`
 * - `this -> success("OK > Using device: " + std::string(this -> device));`
 * - `void model_template::save_state(){ std::string pth = this -> model_checkpoint_path;`
 * - `pth += "state/epoch-" + std::to_string(this -> epoch) + "/";`
 * - `this -> create_path(pth);`
 * - `pth += "kfold-" + std::to_string(this -> kfold);`
 * - `this -> m_loss -> step();`
 * - `if (this -> use_pkl){ std::vector<std::vector<torch::Tensor>> data;`
 * - `data.push_back((*this -> m_data[x]) -> parameters());`
 * - `std::vector<char> chars = torch::pickle_save(data);`
 * - `std::ofstream ofs((pth + "_model.zip").c_str(), std::ios::out | std::ios::binary);`
 * - `ofs.write(chars.data(), chars.size());`
 * - `ofs.close();`
 * - `for (size_t x(0); x < this -> m_data.size(); ++x){(*this -> m_data[x]) -> save(state_session);}`
 * - `state_session.save_to(pth + "_model.pt");`
 * - `this -> m_optim -> save(state_optim);`
 * - `state_optim.save_to(pth + "_optimizer.pt");`
 * - `bool model_template::restore_state(){ std::string model_pth = "";`
 * - `if (this -> ends_with(&this -> model_checkpoint_path, ".pt")){ model_pth = this -> model_checkpoint_`
 * - `if (!this -> is_file(model_pth)){return false;}`
 * - `state_session.load_from(model_pth, this -> m_option -> device());`
 * - `(*this -> m_data[x]) -> load(state_session);`
 * - `if (this -> inference_mode){(*this -> m_data[x]) -> eval();}`
 * - `else {(*this -> m_data[x]) -> train(true);}`
 * - `if (this -> inference_mode){return true;}`
 * - `this -> success("OK > Found Prior training at: " + model_pth);`
 * - `state_optim.load_from(optim_pth, this -> m_option -> device());`
 * - `this -> m_optim -> load(state_optim);`
 * - `this -> m_optim -> step();`
 */

/**
 * @section variables Variables
 *
 * - `void model_template::set_name(std::string* nx, model_template* md){md -> m_name ` (::private)
 * - `void model_template::get_name(std::string* nx, model_template* md){*nx = md -> m` (::private)
 * - `int device_n = -1;` (::private)
 * - `std::string _device = md -> lower(dev);` (::private)
 * - `device_n = std::stoi(md -> split(_device, ":")[1]);` (::private)
 * - `case c10::kCPU:  md -> m_option = new torch::TensorOptions(device_enum); break;` (::private)
 * - `case c10::kCUDA: md -> m_option = new torch::TensorOptions(device_enum, device_n` (::private)
 * - `default: md -> m_option = new torch::TensorOptions(device_enum); break;` (::private)
 * - `bool in_feats = this -> m_i_graph.size();` (::private)
 * - `bool o_feats = this -> m_o_graph.size();` (::private)
 * - `std::vector<torch::Tensor> params = {};` (::private)
 * - `std::vector<torch::Tensor> p_ = (*this -> m_data[x]).ptr() -> parameters();` (::private)
 * - `std::string pth = this -> model_checkpoint_path;` (::private)
 * - `pth += "state/epoch-" + std::to_string(this -> epoch) + "/";` (::private)
 * - `pth += "kfold-" + std::to_string(this -> kfold);` (::private)
 * - `std::vector<char> chars = torch::pickle_save(data);` (::private)
 * - `std::string model_pth = "";` (::private)
 * - `std::string optim_pth = "";` (::private)
 */

/** @} */
