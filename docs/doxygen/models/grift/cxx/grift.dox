/**
 * @file grift.cxx
 * @brief Documentation for models/grift/cxx/grift.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/models/grift/cxx/grift.cxx
 */

/**
 * @defgroup models_grift_cxx_grift_cxx grift.cxx
 * @brief grift.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `grift::grift(){  // create the null buffers this ->  x_nulls = torch::zeros({1, this -> _xrec}).to(t`
 * - `this ->  x_nulls = torch::zeros({1, this -> _xrec}).to(torch::kInt);`
 * - `this -> dx_nulls = torch::zeros({1, this -> _xrec}).to(torch::kFloat32);`
 * - `this -> te_nulls = torch::zeros({1, this -> _xout}).to(torch::kFloat32);`
 * - `this -> rnn_x = new torch::nn::Sequential({ {"rnn_x_l1", torch::nn::Linear(this -> _xin + this -> _x`
 * - `{"rnn_x_l1", torch::nn::Linear(this -> _xin + this -> _xrec, this -> _hidden)}, {"rnn_x_n1", torch::`
 * - `{"rnn_x_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _hidden}))}, {"rnn_x_l2", tor`
 * - `{"rnn_x_l2", torch::nn::Linear(this -> _hidden, this -> _hidden)}, {"rnn_x_n2", torch::nn::LayerNorm`
 * - `{"rnn_x_n2", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _hidden}))}, {"rnn_x_l3", tor`
 * - `{"rnn_x_l3", torch::nn::Linear(this -> _hidden, this -> _xrec)} });`
 * - `int dxx_1 = (this -> _xin + this -> _xrec)*3;`
 * - `this -> rnn_dx = new torch::nn::Sequential({ {"rnn_dx_l1", torch::nn::Linear(dxx_1, this -> _hidden)`
 * - `{"rnn_dx_l1", torch::nn::Linear(dxx_1, this -> _hidden)}, {"rnn_dx_r1", torch::nn::ReLU()},`
 * - `{"rnn_dx_r1", torch::nn::ReLU()}, {"rnn_dx_l2", torch::nn::Linear(this -> _hidden, this -> _hidden)}`
 * - `{"rnn_dx_l2", torch::nn::Linear(this -> _hidden, this -> _hidden)}, {"rnn_dx_s2", torch::nn::Sigmoid`
 * - `{"rnn_dx_s2", torch::nn::Sigmoid()}, {"rnn_dx_n2", torch::nn::LayerNorm(torch::nn::LayerNormOptions(`
 * - `{"rnn_dx_n2", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _hidden}))}, {"rnn_dx_l3", t`
 * - `{"rnn_dx_l3", torch::nn::Linear(this -> _hidden, this -> _xrec)} });`
 * - `this -> rnn_hxx = new torch::nn::Sequential({ {"rnn_hxx_l1", torch::nn::Linear(this -> _xrec*4, this`
 * - `{"rnn_hxx_l1", torch::nn::Linear(this -> _xrec*4, this -> _hidden)}, {"rnn_hxx_n1", torch::nn::Layer`
 * - `{"rnn_hxx_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _hidden}))}, {"rnn_hxx_l2",`
 * - `{"rnn_hxx_l2", torch::nn::Linear(this -> _hidden, this -> _xrec)} });`
 * - `this -> rnn_txx = new torch::nn::Sequential({ {"rnn_txx_l1", torch::nn::Linear(this -> _xrec*4, this`
 * - `{"rnn_txx_l1", torch::nn::Linear(this -> _xrec*4, this -> _hidden)}, {"rnn_txx_r1", torch::nn::ReLU(`
 * - `{"rnn_txx_r1", torch::nn::ReLU()}, {"rnn_txx_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({`
 * - `{"rnn_txx_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _hidden}))}, {"rnn_txx_l2",`
 * - `{"rnn_txx_l2", torch::nn::Linear(this -> _hidden, this -> _hidden)}, {"rnn_txx_t2", torch::nn::Sigmo`
 * - `{"rnn_txx_t2", torch::nn::Sigmoid()}, {"rnn_txx_l3", torch::nn::Linear(this -> _hidden, this -> _xou`
 * - `{"rnn_txx_l3", torch::nn::Linear(this -> _hidden, this -> _xout)} });`
 * - `this -> rnn_rxx = new torch::nn::Sequential({ {"rnn_rxx_l1", torch::nn::Linear(dxx_r, this -> _hidde`
 * - `{"rnn_rxx_l1", torch::nn::Linear(dxx_r, this -> _hidden)}, {"rnn_rxx_r1", torch::nn::ReLU()},`
 * - `{"rnn_rxx_r1", torch::nn::ReLU()}, {"rnn_rxx_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({`
 * - `{"rnn_rxx_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _hidden}))}, {"rnn_rxx_l2",`
 * - `{"rnn_rxx_l2", torch::nn::Linear(this -> _hidden, this -> _hidden)}, {"rnn_rxx_t2", torch::nn::Sigmo`
 * - `{"rnn_rxx_t2", torch::nn::Sigmoid()}, {"rnn_rxx_l3", torch::nn::Linear(this -> _hidden, this -> _xou`
 * - `{"rnn_rxx_l3", torch::nn::Linear(this -> _hidden, this -> _xout)} });`
 * - `this -> mlp_ntop = new torch::nn::Sequential({ {"ntop_l1", torch::nn::Linear(this -> _xtop + this ->`
 * - `{"ntop_l1", torch::nn::Linear(this -> _xtop + this -> _xrec, this -> _xrec)}, {"ntop_r1", torch::nn:`
 * - `{"ntop_r1", torch::nn::ReLU()}, {"ntop_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -`
 * - `{"ntop_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _xrec}))}, {"ntop_l2", torch::`
 * - `{"ntop_l2", torch::nn::Linear(this -> _xrec, this -> _xrec)}, {"ntop_t2", torch::nn::Sigmoid()},`
 * - `{"ntop_t2", torch::nn::Sigmoid()}, {"ntop_l3", torch::nn::Linear(this -> _xrec, this -> _xtop)}`
 * - `{"ntop_l3", torch::nn::Linear(this -> _xrec, this -> _xtop)} });`
 * - `this -> mlp_sig = new torch::nn::Sequential({ {"res_l1", torch::nn::Linear(this -> _xout*2 + dxx_r +`
 * - `{"res_l1", torch::nn::Linear(this -> _xout*2 + dxx_r + this -> _xtop*2, this -> _xrec*2)}, {"res_r1"`
 * - `{"res_r1", torch::nn::ReLU()}, {"res_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> `
 * - `{"res_n1", torch::nn::LayerNorm(torch::nn::LayerNormOptions({this -> _xrec*2}))}, {"res_l2", torch::`
 * - `{"res_l2", torch::nn::Linear(this -> _xrec*2, this -> _xrec)}, {"res_t2", torch::nn::Sigmoid()},`
 * - `{"res_t2", torch::nn::Sigmoid()}, {"res_l3", torch::nn::Linear(this -> _xrec, this -> _xout)}`
 * - `{"res_l3", torch::nn::Linear(this -> _xrec, this -> _xout)} });`
 * - `this -> register_module(this -> rnn_x   );`
 * - `this -> register_module(this -> rnn_dx  );`
 * - `this -> register_module(this -> rnn_hxx );`
 * - `this -> register_module(this -> rnn_txx );`
 * - `this -> register_module(this -> rnn_rxx );`
 * - `this -> register_module(this -> mlp_ntop);`
 * - `this -> register_module(this -> mlp_sig );`
 * - `torch::Tensor grift::node_encode(torch::Tensor pmc, torch::Tensor num_node, torch::Tensor* node_rnn)`
 * - `if (!node_rnn){return torch::cat({pyc::physics::cartesian::combined::M(pmc), pmc, num_node}, {-1}).t`
 * - `torch::Tensor nox = torch::cat({pyc::physics::cartesian::combined::M(pmc), pmc, num_node, *node_rnn}`
 * - `return (*this -> rnn_x) -> forward(nox.to(torch::kFloat32));`
 * - `aggr = pyc::graph::unique_aggregation(torch::cat({_trk_i, _trk_j}, {-1}), pmc);`
 * - `torch::Tensor pmc_ij = aggr.at(key_smx);`
 * - `torch::Tensor m_ij   = pyc::physics::cartesian::combined::M(pmc_ij);`
 * - `torch::Tensor nds_ij = (aggr.at(key_idx) > -1).sum({-1}, true);`
 * - `torch::Tensor fx_ij  = torch::cat({m_ij, pmc_ij, nds_ij, hx_i+hx_j}, {-1});`
 * - `aggr = pyc::graph::unique_aggregation(_trk_i, pmc);`
 * - `torch::Tensor pmc_i = aggr.at(key_smx);`
 * - `torch::Tensor m_i   = pyc::physics::cartesian::combined::M(pmc_i);`
 * - `torch::Tensor nds_i = (aggr.at(key_idx) > -1).sum({-1}, true);`
 * - `torch::Tensor fx_i  = torch::cat({m_i, pmc_i, nds_i, hx_i}, {-1});`
 * - `aggr = pyc::graph::unique_aggregation(_trk_j, pmc);`
 * - `torch::Tensor pmc_j = aggr.at(key_smx);`
 * - `torch::Tensor m_j   = pyc::physics::cartesian::combined::M(pmc_j);`
 * - `torch::Tensor nds_j = (aggr.at(key_idx) > -1).sum({-1}, true);`
 * - `torch::Tensor fx_j  = torch::cat({m_j, pmc_j, nds_j, hx_j}, {-1});`
 * - `return (*this -> rnn_dx) -> forward(torch::cat({fx_ij, fx_i, fx_j - fx_i}, {-1}).to(torch::kFloat32)`
 * - `void grift::forward(graph_t* data){  // get the particle 4-vector and convert it to cartesian torch:`
 * - `torch::Tensor batch_index  = data -> get_batch_index(this) -> view({-1}).clone();`
 * - `torch::Tensor event_index  = std::get<0>(torch::_unique(batch_index));`
 * - `torch::Tensor* pt          = data -> get_data_node("pt", this);`
 * - `torch::Tensor* eta         = data -> get_data_node("eta", this);`
 * - `torch::Tensor* phi         = data -> get_data_node("phi", this);`
 * - `torch::Tensor* energy      = data -> get_data_node("energy", this);`
 * - `torch::Tensor* is_lep      = data -> get_data_node("is_lep", this);`
 * - `torch::Tensor pmc          = pyc::transform::separate::PxPyPzE(*pt, *eta, *phi, *energy) / 1000.0;`
 * - `torch::Tensor edge_index   = data -> get_edge_index(this) -> to(torch::kLong);`
 * - `torch::Tensor src          = edge_index.index({0}).view({-1});`
 * - `torch::Tensor dst          = edge_index.index({1}).view({-1});`
 * - `torch::Tensor* num_jets = data -> get_data_graph("num_jets", this);`
 * - `torch::Tensor* num_leps = data -> get_data_graph("num_leps", this);`
 * - `torch::Tensor* met_phi  = data -> get_data_graph("phi", this);`
 * - `torch::Tensor* met      = data -> get_data_graph("met", this);`
 * - `torch::Tensor num_bjet = data -> get_data_node("is_b", this) -> clone();`
 * - `torch::Tensor num_bjets_ = torch::zeros({event_index.size({0}), 1}, num_bjet.device()).to(num_bjet.d`
 * - `num_bjets_.index_add_({0}, batch_index, num_bjet);`
 * - `torch::Tensor pid = torch::cat({*num_jets, num_bjets_, *num_leps, (*met)/1000.0, *met_phi}, {-1});`
 * - `if (!this -> init){ this -> x_nulls = this -> x_nulls.to(src.device());`
 * - `this -> x_nulls = this -> x_nulls.to(src.device());`
 * - `this -> dx_nulls = this -> dx_nulls.to(src.device());`
 * - `this -> te_nulls = this -> te_nulls.to(src.device());`
 * - `torch::Tensor trk = torch::zeros_like(*pt).to(torch::kInt);`
 * - `torch::Tensor null_idx = torch::zeros_like(src);`
 * - `torch::Tensor node_rnn = this -> x_nulls.index({trk.view({-1})}).to(torch::kFloat32);`
 * - `torch::Tensor edge_rnn = torch::zeros_like(this -> dx_nulls.index({null_idx}));`
 * - `torch::Tensor top_edge = torch::zeros_like(this -> te_nulls.index({null_idx}));`
 * - `torch::Tensor num_node = torch::ones_like(trk);`
 * - `torch::Tensor node_i   = num_node.cumsum({0})-1;`
 * - `torch::Tensor node_i_  = num_node.cumsum({0})-1;`
 * - `node_rnn = this -> node_encode(pmc, num_node, &node_rnn);`
 * - `torch::Tensor idx_mat = torch::zeros({n_nodes, n_nodes}, src.device()).to(torch::kLong);`
 * - `idx_mat.index_put_({src, dst}, (null_idx+1).cumsum({-1})-1);`
 * - `torch::Tensor norm  = torch::zeros_like(idx_mat);`
 * - `norm.index_put_({src, dst}, (null_idx+1));`
 * - `torch::Tensor hx_i   = node_rnn.index({src});`
 * - `torch::Tensor hx_j   = node_rnn.index({dst});`
 * - `torch::Tensor top_edge_   = top_edge.clone();`
 * - `torch::Tensor edge_index_ = edge_index.clone();`
 * - `while (edge_index_.size({1})){ torch::Tensor node_state, hx_ij;`
 * - `torch::Tensor src_ = edge_index_.index({0});`
 * - `torch::Tensor dst_ = edge_index_.index({1});`
 * - `hx_i  = this -> message(node_i.index({src_}) , node_i_.index({dst_}), pmc, hx_i, node_s.index({dst_}`
 * - `hx_j  = this -> message(node_i_.index({src_}), node_i.index({dst_}) , pmc, node_s.index({src_}), hx_`
 * - `hx_ij = this -> message(node_i.index({src_}) , node_i.index({dst_}) , pmc, hx_i, hx_j);`
 * - `hx_ij = torch::cat({hx_ij, edge_rnn, hx_i, hx_j + hx_i}, {-1});`
 * - `top_edge_ = (*this -> rnn_txx) -> forward(hx_ij);`
 * - `edge_rnn  = (*this -> rnn_hxx) -> forward(hx_ij);`
 * - `torch::Tensor idx = idx_mat.index({src_, dst_});`
 * - `top_edge.index_put_({idx}, top_edge_);`
 * - `torch::Tensor sel = std::get<1>((top_edge_).max({-1}));`
 * - `if (!sel.index({sel == false}).size({0})){break;}`
 * - `node_s  = node_rnn.clone();`
 * - `gr_ = pyc::graph::edge_aggregation(edge_index, top_edge, pmc);`
 * - `node_state = this -> node_encode(gr_.at(key_smx), num_node = (gr_.at(key_idx) > -1).sum({-1}, true),`
 * - `torch::Tensor skp = (norm.sum({-1}, true) > 0).view({-1});`
 * - `node_rnn.index_put_({skp}, node_state.index({skp}));`
 * - `norm.index_put_({src_, dst_}, sel*1);`
 * - `hx_i        = hx_i.index({sel});`
 * - `hx_j        = hx_j.index({sel});`
 * - `edge_rnn    = edge_rnn.index({sel});`
 * - `top_edge_   = top_edge_.index({sel});`
 * - `node_i      = gr_.at(key_idx);`
 * - `edge_index_ = edge_index_.index({torch::indexing::Slice(), sel});`
 * - `torch::Tensor node_trk = gr_.at(key_idx);`
 * - `torch::Tensor ntops = this -> node_encode(gr_.at(key_smx), (node_trk > -1).sum({-1}, true), &node_rn`
 * - `torch::Tensor tmlp  = torch::zeros({event_index.size({0}), ntops.size({1})}, ntops.device()).to(ntop`
 * - `tmlp.index_add_({0}, batch_index, ntops);`
 * - `tmlp = torch::cat({tmlp, pid}, {-1});`
 * - `tmlp = (*this -> mlp_ntop) -> forward(tmlp.to(torch::kFloat32));`
 * - `torch::Tensor hxt_i = node_rnn.index({src});`
 * - `torch::Tensor hxt_j = node_rnn.index({dst});`
 * - `gr_ = pyc::graph::unique_aggregation(torch::cat({node_trk.index({src}), node_trk.index({dst})}, {-1}`
 * - `torch::Tensor node_res = this -> node_encode(gr_.at("node-sum"), (gr_.at("unique") > -1).sum({-1}, t`
 * - `torch::Tensor fx_ij    = torch::cat({node_res, ntops.index({src}), hxt_i, hxt_j - hxt_i}, {-1});`
 * - `torch::Tensor res_edge = (*this -> rnn_rxx) -> forward(fx_ij);`
 * - `torch::Tensor isres_ = torch::cat({res_edge, top_edge - res_edge, fx_ij}, {-1});`
 * - `torch::Tensor tmp = torch::zeros({event_index.size({0}), isres_.size({1})}, isres_.device()).to(isre`
 * - `tmp.index_add_({0}, batch_index.index({src}), isres_);`
 * - `isres_ = torch::cat({tmp, pid, tmlp}, {-1});`
 * - `isres_ = (*this -> mlp_sig) -> forward(isres_.to(torch::kFloat32));`
 * - `this -> prediction_edge_feature("top_edge", top_edge);`
 * - `this -> prediction_edge_feature("res_edge", res_edge);`
 * - `this -> prediction_graph_feature("ntops" , tmlp);`
 * - `this -> prediction_graph_feature("signal", isres_);`
 * - `if (!this -> inference_mode){return;}`
 * - `if (this -> pagerank){ gr_ = pyc::graph::PageRankReconstruction(edge_index, top_edge, pmc);`
 * - `gr_ = pyc::graph::PageRankReconstruction(edge_index, top_edge, pmc);`
 * - `this -> prediction_extra("page-nodes", gr_.at("page-nodes"));`
 * - `this -> prediction_extra("page-mass" , gr_.at("page-mass" ));`
 * - `this -> prediction_extra("top_edge_score", top_edge.softmax(-1));`
 * - `this -> prediction_extra("res_edge_score", res_edge.softmax(-1));`
 * - `this -> prediction_extra("ntops_score"   , tmlp.softmax(-1));`
 * - `this -> prediction_extra("is_res_score"  , isres_.softmax(-1));`
 * - `this -> prediction_extra("is_lep"        , *is_lep);`
 * - `this -> prediction_extra("num_leps"      , *num_leps);`
 * - `this -> prediction_extra("num_jets"      , *num_jets);`
 * - `this -> prediction_extra("num_bjets"     , num_bjets_);`
 * - `if (!this -> is_mc){return;}`
 * - `torch::Tensor* ntops_t  = data -> get_truth_graph("ntops"  , this);`
 * - `torch::Tensor* signa_t  = data -> get_truth_graph("signal" , this);`
 * - `torch::Tensor* r_edge_t = data -> get_truth_edge("res_edge", this);`
 * - `torch::Tensor* t_edge_t = data -> get_truth_edge("top_edge", this);`
 * - `this -> prediction_extra("truth_ntops"   , *ntops_t);`
 * - `this -> prediction_extra("truth_signal"  , *signa_t);`
 * - `this -> prediction_extra("truth_res_edge", *r_edge_t);`
 * - `this -> prediction_extra("truth_top_edge", *t_edge_t);`
 * - `grift::~grift(){} model_template* grift::clone(){`
 * - `model_template* grift::clone(){ grift* md = new grift();`
 * - `grift* md = new grift();`
 */

/**
 * @section variables Variables
 *
 * - `this ->  x_nulls = torch::zeros({1, this -> _xrec}).to(torch::kInt);` (::private)
 * - `this -> dx_nulls = torch::zeros({1, this -> _xrec}).to(torch::kFloat32);` (::private)
 * - `this -> te_nulls = torch::zeros({1, this -> _xout}).to(torch::kFloat32);` (::private)
 * - `this -> rnn_x = new torch::nn::Sequential({` (::private)
 * - `int dxx_1 = (this -> _xin + this -> _xrec)*3;` (::private)
 * - `this -> rnn_dx = new torch::nn::Sequential({` (::private)
 * - `this -> rnn_hxx = new torch::nn::Sequential({` (::private)
 * - `this -> rnn_txx = new torch::nn::Sequential({` (::private)
 * - `int dxx_r = this -> _xrec*4;` (::private)
 * - `this -> rnn_rxx = new torch::nn::Sequential({` (::private)
 * - `this -> mlp_ntop = new torch::nn::Sequential({` (::private)
 * - `this -> mlp_sig = new torch::nn::Sequential({` (::private)
 * - `torch::Tensor nox = torch::cat({pyc::physics::cartesian::combined::M(pmc), pmc, ` (::private)
 * - `const std::string key_idx = "unique";` (::private)
 * - `const std::string key_smx = "node-sum";` (::private)
 * - `aggr = pyc::graph::unique_aggregation(torch::cat({_trk_i, _trk_j}, {-1}), pmc);` (::private)
 * - `torch::Tensor pmc_ij = aggr.at(key_smx);` (::private)
 * - `torch::Tensor m_ij   = pyc::physics::cartesian::combined::M(pmc_ij);` (::private)
 * - `torch::Tensor nds_ij = (aggr.at(key_idx) > -1).sum({-1}, true);` (::private)
 * - `torch::Tensor fx_ij  = torch::cat({m_ij, pmc_ij, nds_ij, hx_i+hx_j}, {-1});` (::private)
 * - `torch::Tensor pmc_i = aggr.at(key_smx);` (::private)
 * - `torch::Tensor m_i   = pyc::physics::cartesian::combined::M(pmc_i);` (::private)
 * - `torch::Tensor nds_i = (aggr.at(key_idx) > -1).sum({-1}, true);` (::private)
 * - `torch::Tensor fx_i  = torch::cat({m_i, pmc_i, nds_i, hx_i}, {-1});` (::private)
 * - `torch::Tensor pmc_j = aggr.at(key_smx);` (::private)
 * - `torch::Tensor m_j   = pyc::physics::cartesian::combined::M(pmc_j);` (::private)
 * - `torch::Tensor nds_j = (aggr.at(key_idx) > -1).sum({-1}, true);` (::private)
 * - `torch::Tensor fx_j  = torch::cat({m_j, pmc_j, nds_j, hx_j}, {-1});` (::private)
 * - `torch::Tensor batch_index  = data -> get_batch_index(this) -> view({-1}).clone()` (::private)
 * - `torch::Tensor event_index  = std::get<0>(torch::_unique(batch_index));` (::private)
 * - `torch::Tensor* pt          = data -> get_data_node("pt", this);` (::private)
 * - `torch::Tensor* eta         = data -> get_data_node("eta", this);` (::private)
 * - `torch::Tensor* phi         = data -> get_data_node("phi", this);` (::private)
 * - `torch::Tensor* energy      = data -> get_data_node("energy", this);` (::private)
 * - `torch::Tensor* is_lep      = data -> get_data_node("is_lep", this);` (::private)
 * - `torch::Tensor pmc          = pyc::transform::separate::PxPyPzE(*pt, *eta, *phi, ` (::private)
 * - `torch::Tensor edge_index   = data -> get_edge_index(this) -> to(torch::kLong);` (::private)
 * - `torch::Tensor src          = edge_index.index({0}).view({-1});` (::private)
 * - `torch::Tensor dst          = edge_index.index({1}).view({-1});` (::private)
 * - `torch::Tensor* num_jets = data -> get_data_graph("num_jets", this);` (::private)
 * - `torch::Tensor* num_leps = data -> get_data_graph("num_leps", this);` (::private)
 * - `torch::Tensor* met_phi  = data -> get_data_graph("phi", this);` (::private)
 * - `torch::Tensor* met      = data -> get_data_graph("met", this);` (::private)
 * - `torch::Tensor num_bjet = data -> get_data_node("is_b", this) -> clone();` (::private)
 * - `torch::Tensor num_bjets_ = torch::zeros({event_index.size({0}), 1}, num_bjet.dev` (::private)
 * - `torch::Tensor pid = torch::cat({*num_jets, num_bjets_, *num_leps, (*met)/1000.0,` (::private)
 * - `torch::Tensor trk = torch::zeros_like(*pt).to(torch::kInt);` (::private)
 * - `torch::Tensor null_idx = torch::zeros_like(src);` (::private)
 * - `torch::Tensor node_rnn = this -> x_nulls.index({trk.view({-1})}).to(torch::kFloa` (::private)
 * - `torch::Tensor edge_rnn = torch::zeros_like(this -> dx_nulls.index({null_idx}));` (::private)
 * - `torch::Tensor top_edge = torch::zeros_like(this -> te_nulls.index({null_idx}));` (::private)
 * - `torch::Tensor num_node = torch::ones_like(trk);` (::private)
 * - `torch::Tensor node_i   = num_node.cumsum({0})-1;` (::private)
 * - `torch::Tensor node_i_  = num_node.cumsum({0})-1;` (::private)
 * - `unsigned int n_nodes  = data -> num_nodes;` (::private)
 * - `torch::Tensor idx_mat = torch::zeros({n_nodes, n_nodes}, src.device()).to(torch:` (::private)
 * - `torch::Tensor norm  = torch::zeros_like(idx_mat);` (::private)
 * - `torch::Tensor hx_i   = node_rnn.index({src});` (::private)
 * - `torch::Tensor hx_j   = node_rnn.index({dst});` (::private)
 * - `torch::Tensor node_s = node_rnn;` (::private)
 * - `const std::string key_idx = "cls::1::node-indices";` (::private)
 * - `const std::string key_smx = "cls::1::node-sum";` (::private)
 * - `torch::Tensor top_edge_   = top_edge.clone();` (::private)
 * - `torch::Tensor edge_index_ = edge_index.clone();` (::private)
 * - `torch::Tensor src_ = edge_index_.index({0});` (::private)
 * - `torch::Tensor dst_ = edge_index_.index({1});` (::private)
 * - `hx_ij = torch::cat({hx_ij, edge_rnn, hx_i, hx_j + hx_i}, {-1});` (::private)
 * - `torch::Tensor idx = idx_mat.index({src_, dst_});` (::private)
 * - `torch::Tensor sel = std::get<1>((top_edge_).max({-1}));` (::private)
 * - `torch::Tensor skp = (norm.sum({-1}, true) > 0).view({-1});` (::private)
 * - `edge_index_ = edge_index_.index({torch::indexing::Slice(), sel});` (::private)
 * - `torch::Tensor node_trk = gr_.at(key_idx);` (::private)
 * - `torch::Tensor ntops = this -> node_encode(gr_.at(key_smx), (node_trk > -1).sum({` (::private)
 * - `torch::Tensor tmlp  = torch::zeros({event_index.size({0}), ntops.size({1})}, nto` (::private)
 * - `tmlp = torch::cat({tmlp, pid}, {-1});` (::private)
 * - `tmlp = (*this -> mlp_ntop) -> forward(tmlp.to(torch::kFloat32));` (::private)
 * - `torch::Tensor hxt_i = node_rnn.index({src});` (::private)
 * - `torch::Tensor hxt_j = node_rnn.index({dst});` (::private)
 * - `gr_ = pyc::graph::unique_aggregation(torch::cat({node_trk.index({src}), node_trk` (::private)
 * - `torch::Tensor node_res = this -> node_encode(gr_.at("node-sum"), (gr_.at("unique` (::private)
 * - `torch::Tensor fx_ij    = torch::cat({node_res, ntops.index({src}), hxt_i, hxt_j ` (::private)
 * - `torch::Tensor res_edge = (*this -> rnn_rxx) -> forward(fx_ij);` (::private)
 * - `torch::Tensor isres_ = torch::cat({res_edge, top_edge - res_edge, fx_ij}, {-1});` (::private)
 * - `torch::Tensor tmp = torch::zeros({event_index.size({0}), isres_.size({1})}, isre` (::private)
 * - `isres_ = torch::cat({tmp, pid, tmlp}, {-1});` (::private)
 * - `isres_ = (*this -> mlp_sig) -> forward(isres_.to(torch::kFloat32));` (::private)
 * - `torch::Tensor* ntops_t  = data -> get_truth_graph("ntops"  , this);` (::private)
 * - `torch::Tensor* signa_t  = data -> get_truth_graph("signal" , this);` (::private)
 * - `torch::Tensor* r_edge_t = data -> get_truth_edge("res_edge", this);` (::private)
 * - `torch::Tensor* t_edge_t = data -> get_truth_edge("top_edge", this);` (::private)
 */

/** @} */
