/**
 * @file nusol.cxx
 * @brief Documentation for pyc/interface/nusol.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/pyc/interface/nusol.cxx
 */

/**
 * @defgroup pyc_interface_nusol_cxx nusol.cxx
 * @brief nusol.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `torch::Dict<std::string, torch::Tensor> pyc::nusol::BaseMatrix(torch::Tensor pmc_b, torch::Tensor pm`
 * - `changedev(&pmc_b);`
 * - `return pyc::std_to_dict(nusol_::BaseMatrix(&pmc_b, &pmc_mu, &masses));`
 * - `std::map<std::string, torch::Tensor> out = nusol_::Nu(&pmc_b, &pmc_mu, &met_xy, &masses, &sigma, nul`
 * - `return pyc::std_to_dict(&out);`
 * - `changedev(&pmc_b1);`
 * - `out = nusol_::NuNu(&pmc_b1, &pmc_b2, &pmc_l1, &pmc_l2, &met_xy, null, &masses, nullptr, step, tolera`
 * - `out = nusol_::NuNu(&pmc_b1, &pmc_b2, &pmc_l1, &pmc_l2, &met_xy, null, &mass1, &mass2, step, toleranc`
 * - `changedev(&edge_index);`
 * - `out = nusol_::combinatorial(&edge_index, &batch, &pmc, &pid, &met_xy, mT, mW, null, perturb, steps, `
 * - `for (size_t x(0); x < particles.size(); ++x){`
 * - `quarks.push_back({}); leptons.push_back({});`
 * - `for (size_t y(0); y < particles[x].size(); ++y){`
 * - `bool is_b = !(particles[x][y] -> is_lep || particles[x][y] -> is_nu);`
 * - `if (is_b){quarks[x].push_back(particles[x][y]); continue;}`
 * - `if (is_l){leptons[x].push_back(particles[x][y]); continue;}`
 * - `for (size_t x(0); x < met_.size(); ++x){`
 * - `for (size_t y(0); y < quarks[x].size(); ++y){`
 * - `if (bq -> is_lep){continue;}`
 * - `index.push_back(long(y));`
 * - `isl_.push_back(long(0));`
 * - `isb_.push_back(long(1));`
 * - `pmc.push_back(pyc::as_pmc(bq));`
 * - `bth.push_back(bl);`
 * - `for (size_t y(0); y < leptons[x].size(); ++y){`
 * - `if (lp -> is_nu || !lp -> is_lep){continue;}`
 * - `isl_.push_back(long(leptons[x][y] -> is_lep));`
 * - `isb_.push_back(long(0));`
 * - `pmc.push_back(pyc::as_pmc(lp));`
 * - `out = pyc::nusol::combinatorial(&met_, &phi_, &pmc, &bth, &isb_, &isl_, dev, mT, mW, null, perturb, `
 * - `if (!out.size()){return out;}`
 * - `for (size_t x(0); x < out.size(); ++x){`
 * - `neutrino* nu1 = std::get<0>(out[x]);`
 * - `neutrino* nu2 = std::get<1>(out[x]);`
 * - `nu1 -> bquark = new particle_template(quarks[i][index[nu1 -> b_idx]]);`
 * - `nu1 -> lepton = new particle_template(leptons[i][index[nu1 -> l_idx]]);`
 * - `nu2 -> bquark = new particle_template(quarks[i][index[nu2 -> b_idx]]);`
 * - `nu2 -> lepton = new particle_template(leptons[i][index[nu2 -> l_idx]]);`
 * - `for (size_t a(0); a < nu1 -> alternatives.size(); ++a){`
 * - `if (!nx){continue;}`
 * - `nx -> bquark = new particle_template(quarks[i][index[nx -> b_idx]]);`
 * - `nx -> lepton = new particle_template(leptons[i][index[nx -> l_idx]]);`
 * - `alt1.push_back(nx);`
 * - `for (size_t a(0); a < nu2 -> alternatives.size(); ++a){`
 * - `alt2.push_back(nx);`
 */

/**
 * @section variables Variables
 *
 * - `std::map<std::string, torch::Tensor> out = nusol_::Nu(&pmc_b, &pmc_mu, &met_xy, ` (::private)
 * - `bool is_b = !(particles[x][y] -> is_lep || particles[x][y] -> is_nu);` (::private)
 * - `bool is_l = particles[x][y] -> is_lep;` (::private)
 * - `long bl = x;` (::private)
 * - `size_t i = bth[x];` (::private)
 * - `neutrino* nu1 = std::get<0>(out[x]);` (::private)
 * - `neutrino* nu2 = std::get<1>(out[x]);` (::private)
 * - `std::vector<neutrino*> alt1 = {};` (::private)
 * - `std::vector<neutrino*> alt2 = {};` (::private)
 */

/** @} */
