/**
 * @file edge_features.cxx
 * @brief Documentation for graphs/bsm_4tops/cxx/edge_features.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/graphs/bsm_4tops/cxx/edge_features.cxx
 */

/**
 * @defgroup graphs_bsm_4tops_cxx_edge_features_cxx edge_features.cxx
 * @brief edge_features.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `void m_res_edge(int* o, top* t         ){*o *= t -> from_res;}`
 * - `void m_res_edge(int* o, top_children* t){*o *= t -> from_res;}`
 * - `void m_res_edge(int* o, truthjet* t    ){*o *= t -> from_res;}`
 * - `void m_res_edge(int* o, jet* t         ){*o *= t -> from_res;}`
 * - `void m_res_edge(int* o, electron* t    ){*o *= t -> from_res;}`
 * - `void m_res_edge(int* o, muon* t        ){*o *= t -> from_res;}`
 * - `void m_res_edge(int* o, particle_template* pn, particle_template* nu){ std::map<std::string, particl`
 * - `if (pnx.count(pn -> hash)){return;}`
 * - `void res_edge(int* o, std::tuple<particle_template*, particle_template*>* pij){ particle_template* p`
 * - `particle_template* p1 = std::get<0>(*pij);`
 * - `particle_template* p2 = std::get<1>(*pij);`
 * - `if (type1 == "top"){m_res_edge(o, (top*)p1);}`
 * - `if (type2 == "top"){m_res_edge(o, (top*)p2);}`
 * - `if (type1 == "children"){m_res_edge(o, (top_children*)p1);}`
 * - `if (type2 == "children"){m_res_edge(o, (top_children*)p2);}`
 * - `if (type1 == "truthjets"){m_res_edge(o, (truthjet*)p1);}`
 * - `if (type2 == "truthjets"){m_res_edge(o, (truthjet*)p2);}`
 * - `if (type1 == "jet"){m_res_edge(o, (jet*)p1);}`
 * - `if (type2 == "jet"){m_res_edge(o, (jet*)p2);}`
 * - `if (type1 == "el"){m_res_edge(o, (electron*)p1);}`
 * - `if (type2 == "el"){m_res_edge(o, (electron*)p2);}`
 * - `if (type1 == "mu"){m_res_edge(o, (muon*)p1);}`
 * - `if (type2 == "mu"){m_res_edge(o, (muon*)p2);}`
 * - `if (type1 == "nunu"){m_res_edge(o, p2, p1);}`
 * - `if (type2 == "nunu"){m_res_edge(o, p1, p2);}`
 * - `int m_top_edge(top* t){return t -> index;}`
 * - `int m_top_edge(top_children* t){return t -> top_index;}`
 * - `std::vector<int> m_top_edge(jet*      t){return t -> top_index;  }`
 * - `std::vector<int> m_top_edge(muon*     t){return {t -> top_index};}`
 * - `std::vector<int> m_top_edge(electron* t){return {t -> top_index};}`
 * - `std::vector<int> m_top_edge(truthjet* t){return t -> top_index;  }`
 * - `std::vector<int> m_top_edge(particle_template* pn, particle_template* nu){ std::map<std::string, par`
 * - `if (!pnx.count(pn -> hash)){return {};}`
 * - `if      (type1 == "jet"){out = m_top_edge((jet*)pn);}`
 * - `else if (type1 == "mu" ){out = m_top_edge((muon*)pn);}`
 * - `else if (type1 == "el" ){out = m_top_edge((electron*)pn);}`
 * - `void top_edge(int* o, std::tuple<particle_template*, particle_template*>* pij){ particle_template* p`
 * - `if      (type1 == "top"      ){o1_.push_back(m_top_edge((top*)p1));}`
 * - `else if (type1 == "children" ){o1_.push_back(m_top_edge((top_children*)p1));}`
 * - `else if (type1 == "truthjets"){o1_ = m_top_edge((truthjet*)p1);}`
 * - `else if (type1 == "jet"      ){o1_ = m_top_edge((jet*)p1);}`
 * - `else if (type1 == "mu"       ){o1_ = m_top_edge((muon*)p1);}`
 * - `else if (type1 == "el"       ){o1_ = m_top_edge((electron*)p1);}`
 * - `else if (type1 == "nunu"     ){o1_ = m_top_edge(p2, p1);}`
 * - `if      (type2 == "top"      ){o2_.push_back(m_top_edge((top*)p2));}`
 * - `else if (type2 == "children" ){o2_.push_back(m_top_edge((top_children*)p2));}`
 * - `else if (type2 == "truthjets"){o2_ = m_top_edge((truthjet*)p2);}`
 * - `else if (type2 == "jet"      ){o2_ = m_top_edge((jet*)p2);}`
 * - `else if (type2 == "mu"       ){o2_ = m_top_edge((muon*)p2);}`
 * - `else if (type2 == "el"       ){o2_ = m_top_edge((electron*)p2);}`
 * - `else if (type2 == "nunu"     ){o2_ = m_top_edge(p1, p2);}`
 * - `for (size_t x(0); x < o1_.size(); ++x){`
 * - `if (o1_[x] < 0){continue;}`
 * - `for (size_t y(0); y < o2_.size(); ++y){`
 * - `if (o2_[y] < 0){continue;}`
 * - `if (o1_[x] != o2_[y]){continue;}`
 * - `void det_res_edge(int* o, std::tuple<particle_template*, particle_template*>* pij){ std::map<std::st`
 * - `std::map<std::string, particle_template*> p1x = std::get<0>(*pij) -> parents;`
 * - `std::map<std::string, particle_template*> p2x = std::get<1>(*pij) -> parents;`
 * - `for (itp = p1x.begin(); itp != p1x.end(); ++itp){`
 * - `if (!p2x.count(itp -> first)){continue;}`
 * - `void det_top_edge(int* o, std::tuple<particle_template*, particle_template*>* pij){ std::map<std::st`
 * - `std::map<std::string, particle_template*> p1x = std::get<0>(*pij) -> children;`
 * - `std::map<std::string, particle_template*> p2x = std::get<1>(*pij) -> children;`
 * - `if (!p1x.size() || !p2x.size()){return;}`
 */

/**
 * @section variables Variables
 *
 * - `std::map<std::string, particle_template*> pnx = nu -> parents;` (::private)
 * - `particle_template* p1 = std::get<0>(*pij);` (::private)
 * - `particle_template* p2 = std::get<1>(*pij);` (::private)
 * - `std::string type1 = p1 -> type;` (::private)
 * - `std::string type2 = p2 -> type;` (::private)
 * - `std::string type1 = pn -> type;` (::private)
 * - `std::vector<int> out = {};` (::private)
 * - `std::vector<int> o1_ = {};` (::private)
 * - `std::vector<int> o2_ = {};` (::private)
 * - `std::map<std::string, particle_template*> p1x = std::get<0>(*pij) -> parents;` (::private)
 * - `std::map<std::string, particle_template*> p2x = std::get<1>(*pij) -> parents;` (::private)
 * - `std::map<std::string, particle_template*> p1x = std::get<0>(*pij) -> children;` (::private)
 * - `std::map<std::string, particle_template*> p2x = std::get<1>(*pij) -> children;` (::private)
 */

/** @} */
