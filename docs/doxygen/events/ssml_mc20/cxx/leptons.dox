/**
 * @file leptons.cxx
 * @brief Documentation for events/ssml_mc20/cxx/leptons.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/events/ssml_mc20/cxx/leptons.cxx
 */

/**
 * @defgroup events_ssml_mc20_cxx_leptons_cxx leptons.cxx
 * @brief leptons.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `muon::muon(){ this -> type = "mu";`
 * - `this -> add_leaf("eta"   , "_eta");`
 * - `this -> add_leaf("phi"   , "_phi");`
 * - `this -> add_leaf("charge", "_charge");`
 * - `this -> add_leaf("pt"    , "_pt_NOSYS");`
 * - `this -> add_leaf("energy", "_e_NOSYS");`
 * - `this -> add_leaf("top_index", "_truthTopIndex");`
 * - `this -> apply_type_prefix();`
 * - `this -> from_res.set_object(this);`
 * - `this -> from_res.set_getter(this -> get_from_res);`
 * - `muon::~muon(){}  particle_template* muon::clone(){return (particle_template*)new muon();}`
 * - `particle_template* muon::clone(){return (particle_template*)new muon();}`
 * - `void muon::build(std::map<std::string, particle_template*>* prt, element_t* el){ std::vector<muon*> `
 * - `pmu(&elc, el);`
 * - `el -> get("charge", &ch);`
 * - `el -> get("top_index", &tp_index);`
 * - `bool sp = tp_index.size() == elc.size();`
 * - `for (size_t x(0); x < elc.size(); ++x){`
 * - `elx -> pdgid = ch[x]*(13);`
 * - `if (sp){elx -> top_index = tp_index[x];}`
 * - `(*prt)[elx -> hash] = elx;`
 * - `void muon::get_from_res(bool* val, muon* el){ std::map<std::string, particle_template*> prnt = el ->`
 * - `std::map<std::string, particle_template*>::iterator itr = prnt.begin();`
 * - `for (; itr != prnt.end(); ++itr){`
 * - `top* t = (top*)itr -> second;`
 * - `if (!t -> from_res){continue;}`
 * - `electron::electron(){ this -> type = "el";`
 * - `this -> add_leaf("charge"   , "_charge");`
 * - `this -> add_leaf("ecids"    , "_passECIDS_NOSYS");`
 * - `electron::~electron(){} particle_template* electron::clone(){return (particle_template*)new electron`
 * - `particle_template* electron::clone(){return (particle_template*)new electron();}`
 * - `void electron::build(std::map<std::string, particle_template*>* prt, element_t* el){ std::vector<ele`
 * - `el -> get("ecids"    , &ecid);`
 * - `void electron::get_from_res(bool* val, electron* el){ std::map<std::string, particle_template*> prnt`
 * - `lepton::lepton(){ this -> type = "lepton";`
 * - `this -> add_leaf("e"     , "_e_NOSYS");`
 * - `this -> add_leaf("ambiguity", "_DFCommonAddAmbiguity");`
 * - `lepton::~lepton(){} particle_template* lepton::clone(){return (particle_template*)new lepton();}`
 * - `particle_template* lepton::clone(){return (particle_template*)new lepton();}`
 * - `void lepton::build(std::map<std::string, particle_template*>* prt, element_t* el){ std::vector<float`
 * - `el -> get("eta", &eta);`
 * - `el -> get("phi", &phi);`
 * - `el -> get("pt" , &pt);`
 * - `el -> get("e"  , &e);`
 * - `el -> get("ambiguity", &df);`
 * - `for (int x(0); x < pt.size(); ++x){`
 * - `lepton* px      = new lepton();`
 * - `(*prt)[px -> hash] = px;`
 */

/**
 * @section variables Variables
 *
 * - `bool sp = tp_index.size() == elc.size();` (::private)
 * - `std::map<std::string, particle_template*> prnt = el -> parents;` (::private)
 * - `std::map<std::string, particle_template*>::iterator itr = prnt.begin();` (::private)
 */

/** @} */
