/**
 * @file event.cxx
 * @brief Documentation for events/gnn/cxx/event.cxx
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/events/gnn/cxx/event.cxx
 */

/**
 * @defgroup events_gnn_cxx_event_cxx event.cxx
 * @brief event.cxx
 * @{
 */

/**
 * @section functions Functions
 *
 * - `gnn_event::gnn_event(){ this -> name = "gnn_event";`
 * - `this -> add_leaf("weight"    , "event_weight");`
 * - `this -> add_leaf("edge_index", "edge_index");`
 * - `this -> add_leaf("res_edge"  , "extra_res_edge_score");`
 * - `this -> add_leaf("top_edge"  , "extra_top_edge_score");`
 * - `this -> add_leaf("ntops"     , "extra_ntops_score");`
 * - `this -> add_leaf("signal"    , "extra_is_res_score");`
 * - `this -> add_leaf("num_jets"  , "extra_num_jets");`
 * - `this -> add_leaf("num_bjets" , "extra_num_bjets");`
 * - `this -> add_leaf("num_leps"  , "extra_num_leps");`
 * - `this -> add_leaf("met"       , "g_i_met");`
 * - `this -> add_leaf("phi"       , "g_i_phi");`
 * - `this -> add_leaf("truth_ntops"   , "extra_truth_ntops"   );`
 * - `this -> add_leaf("truth_signal"  , "extra_truth_signal"  );`
 * - `this -> add_leaf("truth_res_edge", "extra_truth_res_edge");`
 * - `this -> add_leaf("truth_top_edge", "extra_truth_top_edge");`
 * - `this -> register_particle(&this -> m_event_particles);`
 * - `gnn_event::~gnn_event(){ this -> deregister_particle(&this -> m_r_zprime);`
 * - `this -> deregister_particle(&this -> m_r_zprime);`
 * - `this -> deregister_particle(&this -> m_t_zprime);`
 * - `this -> deregister_particle(&this -> m_r_tops);`
 * - `this -> deregister_particle(&this -> m_t_tops);`
 * - `event_template* gnn_event::clone(){return (event_template*)new gnn_event();}`
 * - `void gnn_event::build(element_t* el){ el -> get("edge_index" , &this -> m_edge_index);`
 * - `el -> get("edge_index" , &this -> m_edge_index);`
 * - `el -> get("res_edge"   , &this -> edge_res_scores);`
 * - `el -> get("top_edge"   , &this -> edge_top_scores);`
 * - `reduce(el, "weight"    , &this -> weight);`
 * - `reduce(el, "ntops"     , &this -> ntops_scores, -1);`
 * - `reduce(el, "signal"    , &this -> signal_scores, -1);`
 * - `reduce(el, "num_jets"  , &this -> num_jets);`
 * - `reduce(el, "num_bjets" , &this -> num_bjets);`
 * - `reduce(el, "num_leps"  , &this -> num_leps);`
 * - `reduce(el, "met"       , &this -> met);`
 * - `reduce(el, "phi"       , &this -> phi);`
 * - `reduce(el, "truth_ntops"   , &this -> t_ntops);`
 * - `reduce(el, "truth_signal"  , &this -> t_signal);`
 * - `reduce(el, "truth_res_edge", &this -> t_edge_res, 0);`
 * - `reduce(el, "truth_top_edge", &this -> t_edge_top, 0);`
 * - `void gnn_event::CompileEvent(){  auto cluster = [this]( std::map<int, std::map<std::string, particle`
 * - `float n_nodes = clust -> size();`
 * - `for (itr = clust -> begin(); itr != clust -> end(); ++itr){`
 * - `if (!bin_data){break;}`
 * - `for (size_t y(0); y < n_nodes; ++y){Mij[src][y] = (src != y)*(*bin_data)[src][y];}`
 * - `for (size_t y(0); y < n_nodes; ++y){`
 * - `for (size_t x(0); x < n_nodes; ++x){sm += Mij[x][y];}`
 * - `sm = ((sm) ? 1.0/sm : 0);`
 * - `for (size_t x(0); x < n_nodes; ++x){Mij[x][y] = ((sm) ? Mij[x][y]*sm : 1.0/n_nodes)*alpha;}`
 * - `pr_[y] = (*bin_data)[y][y]/n_nodes;`
 * - `while (bin_data){ pr_.clear();`
 * - `pr_.clear();`
 * - `for (size_t src(0); src < n_nodes; ++src){`
 * - `for (size_t x(0); x < n_nodes; ++x){pr_[src] += (Mij[src][x]*PR[x]);}`
 * - `pr_[src] += (1-alpha)/n_nodes;`
 * - `itr = clust -> begin();`
 * - `for (; itr != clust -> end(); ++itr){`
 * - `norm += std::abs(pr_[itr -> first] - PR[itr -> first]);`
 * - `if (norm > 1e-6 && timeout < 1e6){continue;}`
 * - `for (size_t x(0); x < n_nodes; ++x){`
 * - `sc += (x != y) * Mij[x][y] * (pr_[y]);`
 * - `if (!norm){break;}`
 * - `for (size_t x(0); x < n_nodes; ++x){PR[x] = PR[x] / norm;}`
 * - `tools tl = tools();`
 * - `if (!PR[src] && bin_data){continue;}`
 * - `for (itp = itr -> second.begin(); itp != itr -> second.end(); ++itp){`
 * - `if (bin_data && (*bin_data)[src][ptr -> index] < 0.5){continue;}`
 * - `std::map<std::string, particle_gnn*> mps = (*clust)[ptr -> index];`
 * - `std::map<std::string, particle_gnn*>::iterator itx = mps.begin();`
 * - `for (; itx != mps.end(); ++itx){`
 * - `if (tmp.count(ptr -> hash) || clust -> count(ptr -> index)){continue;}`
 * - `mps = (*clust)[ptr -> index];`
 * - `itx = mps.begin();`
 * - `if (tmp.size() <= 2){continue;}`
 * - `for (itp = tmp.begin(); itp != tmp.end(); ++itp){hash = tl.hash(hash + itp -> first);}`
 * - `if (out -> count(hash)){continue;}`
 * - `this -> vectorize(&tmp, &(*out)[hash]);`
 * - `if (!bin_out){continue;}`
 * - `for (itp = tmp.begin(); itp != tmp.end(); ++itp){(*bin_out)[hash] += PR[itp -> second -> index];}`
 * - `std::map<int, particle_gnn*> particle = this -> sort_by_index(&this -> m_event_particles);`
 * - `this -> s_ntops  = this -> max(&this -> ntops_scores);`
 * - `for (size_t x(0); x < 5; ++x){`
 * - `if (this -> s_ntops != this -> ntops_scores[x]){continue;}`
 * - `this -> p_ntops = int(x);`
 * - `for (size_t x(0); x < this -> m_edge_index.size(); ++x){`
 * - `int top_ij = (this -> edge_top_scores[x][0] < this -> edge_top_scores[x][1]);`
 * - `int res_ij = (this -> edge_res_scores[x][0] < this -> edge_res_scores[x][1]);`
 * - `if (!reco_tops.count(src)){reco_tops[src] = {};}`
 * - `if (!reco_zprime.count(src)){reco_zprime[src] = {};}`
 * - `if (top_ij){reco_tops[src][hx]   = ptr;}`
 * - `if (res_ij){reco_zprime[src][hx] = ptr;}`
 * - `if (this -> t_edge_top[x]){real_tops[src][hx]   = ptr;}`
 * - `if (this -> t_edge_res[x]){real_zprime[src][hx] = ptr;}`
 * - `cluster(&real_tops  , &c_real_tops, nullptr, nullptr);`
 * - `for (it = c_real_tops.begin(); it != c_real_tops.end(); ++it){`
 * - `this -> sum(&it -> second, &t);`
 * - `std::map<std::string, particle_template*>::iterator itc = ch.begin();`
 * - `for (; itc != ch.end(); ++itc){t -> n_leps += ((particle_gnn*)itc -> second) -> lep;}`
 * - `t -> n_nodes = ch.size();`
 * - `cluster(&real_zprime, &c_real_zprime, nullptr, nullptr);`
 * - `for (it = c_real_zprime.begin(); it != c_real_zprime.end(); ++it){`
 * - `cluster(&reco_tops  , &c_reco_tops, &c_reco_tops_bin, &bin_top);`
 * - `for (it = c_reco_tops.begin(); it != c_reco_tops.end(); ++it){`
 * - `cluster(&reco_zprime, &c_reco_zprime, &c_reco_zprime_bin, &bin_zprime);`
 * - `for (it = c_reco_zprime.begin(); it != c_reco_zprime.end(); ++it){`
 * - `this -> vectorize(&this -> m_r_zprime, &this -> r_zprime);`
 * - `this -> vectorize(&this -> m_t_zprime, &this -> t_zprime);`
 * - `this -> vectorize(&this -> m_r_tops, &this -> r_tops);`
 * - `this -> vectorize(&this -> m_t_tops, &this -> t_tops);`
 * - `this -> vectorize(&this -> m_event_particles, &this -> event_particles);`
 */

/**
 * @section variables Variables
 *
 * - `float alpha = 0.85;` (::private)
 * - `float n_nodes = clust -> size();` (::private)
 * - `int src = itr -> first;` (::private)
 * - `for (size_t y(0); y < n_nodes; ++y){Mij[src][y] = (src != y)*(*bin_data)[src][y]` (::private)
 * - `float sm = 0;` (::private)
 * - `for (size_t x(0); x < n_nodes; ++x){sm += Mij[x][y];}` (::private)
 * - `for (size_t x(0); x < n_nodes; ++x){Mij[x][y] = ((sm) ? Mij[x][y]*sm : 1.0/n_nod` (::private)
 * - `int timeout = 0;` (::private)
 * - `std::map<int, float> PR = pr_;` (::private)
 * - `float sx = 0;` (::private)
 * - `for (size_t x(0); x < n_nodes; ++x){pr_[src] += (Mij[src][x]*PR[x]);}` (::private)
 * - `float norm = 0;` (::private)
 * - `norm += std::abs(pr_[itr -> first] - PR[itr -> first]);` (::private)
 * - `float sc = 0;` (::private)
 * - `for (size_t x(0); x < n_nodes; ++x){PR[x] = PR[x] / norm;}` (::private)
 * - `std::map<std::string, particle_gnn*> mps = (*clust)[ptr -> index];` (::private)
 * - `std::map<std::string, particle_gnn*>::iterator itx = mps.begin();` (::private)
 * - `std::string hash = "";` (::private)
 * - `std::map<int, particle_gnn*> particle = this -> sort_by_index(&this -> m_event_p` (::private)
 * - `int src = this -> m_edge_index[x][0];` (::private)
 * - `int dst = this -> m_edge_index[x][1];` (::private)
 * - `int top_ij = (this -> edge_top_scores[x][0] < this -> edge_top_scores[x][1]);` (::private)
 * - `int res_ij = (this -> edge_res_scores[x][0] < this -> edge_res_scores[x][1]);` (::private)
 * - `std::string hx       = ptr -> hash;` (::private)
 * - `std::map<std::string, particle_template*> ch = t -> children;` (::private)
 * - `std::map<std::string, particle_template*>::iterator itc = ch.begin();` (::private)
 */

/** @} */
