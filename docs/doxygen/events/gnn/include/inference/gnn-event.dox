/**
 * @file gnn-event.h
 * @brief Documentation for events/gnn/include/inference/gnn-event.h
 * 
 * This file is part of the AnalysisG framework.
 * Location: src/AnalysisG/events/gnn/include/inference/gnn-event.h
 */

/**
 * @defgroup events_gnn_include_inference_gnn_event_h gnn-event.h
 * @brief gnn-event.h
 * @{
 */

/**
 * @section classes Classes and Structures
 *
 * - **gnn_event** (class)
 */

/**
 * @section functions Functions
 *
 * - `void reduce(element_t* el, std::string key, g* out){ std::vector<std::vector<g>> tmp;`
 * - `if (!el -> get(key, &tmp)){return;}`
 * - `(*out) = tmp[0][0];`
 * - `void reduce(element_t* el, std::string key, std::vector<g>* out, int dim){ std::vector<std::vector<g`
 * - `if (dim == -1){(*out) = tmp[0]; return;}`
 * - `for (size_t x(0); x < tmp.size(); ++x){`
 * - `(*out).push_back(tmp[x][0]);`
 * - `gnn_event();`
 * - `~gnn_event() override;`
 * - `event_template* clone() override;`
 * - `void build(element_t* el) override;`
 * - `void CompileEvent() override;`
 * - `std::map<int, G*> sort_by_index(std::map<std::string, G*>* ipt){ std::map<int, G*> data = {};`
 * - `typename std::map<std::string, G*>::iterator ix = ipt -> begin();`
 * - `for (; ix != ipt -> end(); ++ix){data[int(ix -> second -> index)] = ix -> second;}`
 * - `void vectorize(std::map<m, G*>* ipt, std::vector<Gx*>* vec){ typename std::map<m, G*>::iterator ix =`
 * - `typename std::map<m, G*>::iterator ix = ipt -> begin();`
 * - `for (; ix != ipt -> end(); ++ix){vec -> push_back(ix -> second);}`
 * - `void sum(std::vector<g*>* ch, G** out){ (*out) = new G();`
 * - `(*out) = new G();`
 * - `for (size_t x(0); x < ch -> size(); ++x){`
 * - `if (maps[ch -> at(x) -> hash]){continue;}`
 * - `maps[ch -> at(x) -> hash] = true;`
 * - `(*out) -> iadd(ch -> at(x));`
 * - `(*out) -> register_child(ch -> at(x));`
 * - `void print(std::vector<std::vector<g>>* data){ std::cout << "[" << std::endl;`
 * - `for (size_t x(0); x < data -> size(); ++x){`
 * - `std::cout << (*data)[x][0];`
 * - `if (x == data -> size()-1){continue;}`
 * - `std::cout << (*data)[x][1];`
 * - `void print(std::map<g, std::map<g, k>>* data){ std::cout << "[" << std::endl;`
 * - `int sx = data -> size();`
 * - `for (int x(0); x < sx; ++x){`
 * - `for (int y(0); y < sx; ++y){`
 * - `std::cout << (*data)[x][y];`
 * - `if (y == sx-1){continue;}`
 * - `if (x == sx-1){continue;}`
 * - `void print(std::map<g, k>* data){ std::cout << "[";`
 * - `std::cout << (*data)[x];`
 */

/**
 * @section variables Variables
 *
 * - `int   num_bjets = 0;` (::private)
 * - `double num_jets = 0;` (::private)
 * - `double num_leps = 0;` (::private)
 * - `double met      = 0;` (::private)
 * - `double phi      = 0;` (::private)
 * - `int   p_ntops  = 0;` (::private)
 * - `int   p_signal = 0;` (::private)
 * - `float s_ntops  = 0;` (::private)
 * - `float s_signal = 0;` (::private)
 * - `std::vector<float> ntops_scores  = {};` (::private)
 * - `std::vector<float> signal_scores = {};` (::private)
 * - `std::vector<std::vector<float>> edge_res_scores = {};` (::private)
 * - `std::vector<std::vector<float>> edge_top_scores = {};` (::private)
 * - `std::vector<top*>    r_tops   = {};` (::private)
 * - `std::vector<zprime*> r_zprime = {};` (::private)
 * - `std::vector<particle_gnn*> event_particles = {};` (::private)
 * - `std::vector<top*> t_tops   = {};` (::private)
 * - `std::vector<zprime*> t_zprime = {};` (::private)
 * - `std::vector<int> t_edge_res = {};` (::private)
 * - `std::vector<int> t_edge_top = {};` (::private)
 * - `int t_ntops  = 0;` (::private)
 * - `bool t_signal = 0;` (::private)
 * - `std::vector<std::vector<int>>        m_edge_index = {};` (::private)
 * - `std::map<std::string, particle_gnn*> m_event_particles = {};` (::private)
 * - `std::map<std::string, zprime*>  m_r_zprime = {};` (::private)
 * - `std::map<std::string, zprime*>  m_t_zprime = {};` (::private)
 * - `std::map<std::string, top*>     m_r_tops = {};` (::private)
 * - `std::map<std::string, top*>     m_t_tops = {};` (::private)
 * - `std::map<int, G*> data = {};` (::private)
 * - `typename std::map<std::string, G*>::iterator ix = ipt -> begin();` (::private)
 * - `typename std::map<m, G*>::iterator ix = ipt -> begin();` (::private)
 * - `int sx = data -> size();` (::private)
 */

/** @} */
