/**
 * @file metric_template.h
 * @brief Template base class for defining and computing evaluation metrics during GNN training
 *
 * @section metric_purpose Purpose
 * 
 * The metric_template serves as the foundational template for implementing custom evaluation metrics
 * that monitor and assess model performance during training, validation, and testing. It provides
 * a flexible framework for computing per-event, per-batch, and end-of-epoch metrics with automatic
 * integration into the AnalysisG training pipeline.
 *
 * @section metric_role Role in Framework
 *
 * **Critical Training Component**: Metrics are essential for:
 * - Monitoring model performance during training
 * - Validating model convergence and generalization
 * - Early stopping based on validation metrics
 * - Hyperparameter tuning and model selection
 * - Performance comparison across different architectures
 *
 * **Integration Points**:
 * - Connects to analysis class for training orchestration
 * - Accesses model_template predictions and ground truth
 * - Interfaces with graph_template for feature extraction
 * - Inherits from notification for logging capabilities
 * - Inherits from tools for utility functions
 * - Uses plotting module for visualization
 *
 * @section metric_structure Data Structures
 *
 * ### metric_t
 *
 * Encapsulates runtime metric computation context:
 * - **kfold**: Cross-validation fold number
 * - **epoch**: Current training epoch
 * - **device**: GPU device ID for multi-device training
 * - **get<T>()**: Template method for type-safe variable retrieval from graphs
 * - **mode()**: Returns current mode (train/validation/test)
 * - **get_filename()**: Retrieves input file name for current batch
 *
 * This struct provides metrics with access to:
 * - Graph features (node/edge/global) by name
 * - Training context (fold, epoch, device)
 * - Batch metadata (files, mode)
 * - Model state and predictions
 *
 * @section metric_lifecycle Metric Lifecycle
 *
 * Metrics follow a three-stage computation pattern:
 *
 * ### 1. Variable Definition (define_variables)
 * Called once during initialization to specify which graph features the metric needs:
 * ```cpp
 * virtual void define_variables() override {
 *     this->variables = {"prediction", "truth_label", "event_weight"};
 * }
 * ```
 *
 * ### 2. Event-Level Computation (event)
 * Called for each event in a batch:
 * ```cpp
 * virtual void event() override {
 *     // Access current event's metric_t context
 *     // Compute per-event metrics
 *     // Accumulate statistics
 * }
 * ```
 *
 * ### 3. Batch-Level Aggregation (batch)
 * Called after processing all events in a batch:
 * ```cpp
 * virtual void batch() override {
 *     // Aggregate event-level statistics
 *     // Compute batch-level metrics
 *     // Write intermediate results
 * }
 * ```
 *
 * ### 4. End-of-Epoch Summary (end)
 * Called at the end of each epoch:
 * ```cpp
 * virtual void end() override {
 *     // Compute final epoch metrics
 *     // Generate plots/visualizations
 *     // Write summary statistics
 * }
 * ```
 *
 * @section metric_properties Properties (cproperty instances)
 *
 * ### name
 * Metric identifier used for logging and output file naming.
 *
 * ### output_path
 * Directory path for metric output files (plots, summaries, histograms).
 *
 * ### variables
 * Vector of variable names to extract from graphs. Automatically validated against available features.
 *
 * ### run_names
 * Map of model names to human-readable labels for multi-model comparisons.
 *
 * @section metric_methods Key Methods
 *
 * ### Virtual Methods (Override Required)
 *
 * **define_variables()**: Specify required graph features
 * **define_metric(metric_t* v)**: Compute metric using provided context
 * **event()**: Per-event metric computation
 * **batch()**: Per-batch metric aggregation
 * **end()**: End-of-epoch metric summary
 * **clone()**: Create independent copy for parallel processing
 *
 * ### Output Methods
 *
 * **register_output<T>()**: Register ROOT tree branch for metric output
 * ```cpp
 * float accuracy = 0.0;
 * register_output("metrics", "accuracy", &accuracy);
 * ```
 *
 * **write<T>()**: Write value to registered branch
 * ```cpp
 * accuracy = compute_accuracy();
 * write("metrics", "accuracy", &accuracy, true);  // true = fill tree
 * ```
 *
 * ### Particle Utility Methods
 *
 * **sum<g,k>()**: Create composite particle from vector (inherits from selection_template pattern)
 * **make_unique<g>()**: Remove duplicate particles based on hash
 * **vectorize<g>()**: Convert map to vector
 * **safe_delete<g>()**: Delete unmarked particles to prevent memory leaks
 * **make_particle()**: Construct particle_template instances from kinematic vectors
 *
 * @section metric_multimodel Multi-Model Support
 *
 * Metrics can evaluate multiple models simultaneously:
 * - Each model gets independent metric computation
 * - K-fold cross-validation support with separate tracking
 * - Device-aware for multi-GPU training
 * - Run names for human-readable model identification
 *
 * @section metric_threading Thread Safety
 *
 * **clone() Pattern**: Each thread/device receives independent metric instance
 * - Prevents race conditions during parallel evaluation
 * - Enables lock-free metric accumulation
 * - Supports distributed training scenarios
 *
 * **Garbage Collection**: Automatic cleanup of temporary particles created during metric computation
 * - Prevents memory leaks from particle sum operations
 * - Thread-safe via per-instance garbage maps
 *
 * @section metric_memory Memory Management
 *
 * **Automatic Cleanup**:
 * - `flush_garbage()` called automatically after each batch
 * - Deletes temporary particles created via sum()
 * - writer handle managed by metric_template lifecycle
 *
 * **User Responsibilities**:
 * - Mark particles with `_is_marked = true` if they should persist
 * - Use safe_delete() for particle vectors to respect markers
 * - Clone creates deep copies for thread safety
 *
 * @section metric_example Usage Example
 *
 * ```cpp
 * class AccuracyMetric : public metric_template {
 * public:
 *     void define_variables() override {
 *         this->variables = {"prediction", "truth_label"};
 *     }
 *     
 *     void event() override {
 *         // Will be called with metric_t* containing variables
 *     }
 *     
 *     void define_metric(metric_t* mt) override {
 *         // Get predictions and truth
 *         auto pred = mt->get<std::vector<float>>(graph_enum::PREDICTION, "prediction");
 *         auto truth = mt->get<std::vector<int>>(graph_enum::TRUTH, "truth_label");
 *         
 *         // Compute accuracy
 *         int correct = 0;
 *         for (size_t i = 0; i < pred.size(); ++i) {
 *             if ((pred[i] > 0.5) == (truth[i] == 1)) correct++;
 *         }
 *         float accuracy = float(correct) / pred.size();
 *         
 *         // Accumulate for batch
 *         total_correct += correct;
 *         total_samples += pred.size();
 *     }
 *     
 *     void batch() override {
 *         // Compute batch accuracy
 *         float batch_acc = float(total_correct) / total_samples;
 *         
 *         // Write to output
 *         register_output("metrics", "batch_accuracy", &batch_acc);
 *         write("metrics", "batch_accuracy", &batch_acc, true);
 *         
 *         // Reset counters
 *         total_correct = 0;
 *         total_samples = 0;
 *     }
 *     
 *     void end() override {
 *         // Generate summary plots, write final statistics
 *     }
 *     
 * private:
 *     int total_correct = 0;
 *     int total_samples = 0;
 * };
 * ```
 *
 * @section metric_design Design Considerations
 *
 * **Performance**:
 * - Metrics called frequently (once per event/batch)
 * - Minimize computation in hot loops
 * - Cache expensive calculations
 * - Use efficient data structures for accumulation
 *
 * **Flexibility**:
 * - Support arbitrary variable types via templates
 * - Configurable via properties
 * - Extensible through virtual methods
 * - Compatible with existing plotting/notification infrastructure
 *
 * **Reliability**:
 * - Type-safe variable access with error messages
 * - Automatic memory management
 * - Thread-safe design via cloning
 * - Validation of required variables
 *
 * @see model_template For model predictions and loss computation
 * @see graph_template For feature storage and access
 * @see analysis For training orchestration and metric integration
 * @see selection_template For particle utility method patterns
 */