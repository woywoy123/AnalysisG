/**
 * @brief A class used for analyzing data and managing various templates and models.
 *
 * This class provides methods for adding different types of templates, models,
 * and configurations. It also includes functionality for tracking progress,
 * managing threads, and handling various metadata related to the analysis.
 */

/**
 * @brief Flushes all data from the map into a generic type g.
 *
 * This method is used to clear or update the contents of the map with elements
 * of type g. It allows for generic operations on different types of data.
 *
 * @param data A map containing keys and values of type g*
 * @param g The generic type of the elements in the map
 */
template<typename g> void flush(std::map<std::string, g*>, g* in);

/**
 * @brief The main class that handles all aspects of the analysis process.
 *
 * This class provides methods to add various templates (selections, events,
 * graphs, metrics), manage models, track progress, and handle metadata.
 */
class analysis: 
    public notification, 
    public tools
{
    public:
        /**
         * @brief Constructor for the analysis class.
         */
        analysis();

        /**
         * @brief destructor for the analysis class.
         */
        ~analysis();

        /**
         * @brief Adds samples to be analyzed.
         *
         * @param path The file path of the sample data
         * @param label A descriptive label for the sample
         */
        void add_samples(std::string path, std::string label);

        /**
         * @brief Adds a selection template to be used in analysis.
         *
         * @param sel A pointer to the selection template object
         */
        void add_selection_template(selection_template* sel);

        /**
         * @brief Adds an event template along with its label for tracking events during analysis.
         *
         * @param ev Pointer to event template object
         * @param label Descriptive label for the event
         */
        void add_event_template(event_template* ev, std::string label);

        /**
         * @brief Adds a graph template along with its label for building graphs during analysis.
         *
         * @param gr Pointer to graph template object
         * @param label Descriptive label for the graph
         */
        void add_graph_template(graph_template* gr, std::string label);

        /**
         * @brief Adds a metric template and an associated model template for tracking metrics.
         *
         * @param mx Pointer to metric template object
         * @param mdl Pointer to model template object
         */
        void add_metric_template(metric_template* mx, model_template* mdl);

        /**
         * @brief Adds a model template along with its optimizer parameters and run name.
         *
         * @param model Pointer to model template object
         * @param op Pointer to optimizer parameters object
         * @param run_name Name of the run or experiment
         */
        void add_model(model_template* model, optimizer_params_t* op, std::string run_name);

        /**
         * @brief Adds a model template along with its run name.
         *
         * @param model Pointer to model template object
         * @param run_name Name of the run or experiment
         */
        void add_model(model_template* model, std::string run_name);

        /**
         * @brief Attaches all registered threads for parallel processing.
         */
        void attach_threads();

        /**
         * @brief Starts the analysis process by initializing and building components.
         */
        void start();

        /**
         * @brief Returns a map of progress information including completion status.
         */
        std::map<std::string, std::vector<float>> progress();


        /**
         * @brief Returns a map of different progress modes used during analysis.
         */
        std::map<std::string, std::string> progress_mode();

        /**
         * @brief Returns a map of progress reports containing detailed information.
         */
        std::map<std::string, std::string> progress_report();

        /**
         * @brief Checks if all components are completed or if there's an error.
         */
        bool is_completed_or_error(); 

        /**
         * @brief Returns the number of active threads in the analysis process.
         */
        size_t num_threads(); 

    private:
        // Private members that handle internal state and operations
        model* m_model;  // Pointer to the main model being analyzed
        std::string run_name;  // Name of the current run or experiment
        bool is_initialized;  // Boolean indicating if initialization has started
};

