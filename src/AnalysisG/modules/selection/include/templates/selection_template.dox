#ifndef SELECTION_TEMPLATE_H
#define SELECTION_TEMPLATE_H

#include <templates/particle_template.h>
#include <templates/event_template.h>

#include <structs/property.h>
#include <structs/event.h>
#include <meta/meta.h>

#include <tools/vector_cast.h>
#include <tools/merge_cast.h>
#include <tools/tools.h>

class container; 

class selection_template: public tools
{
    public:
        selection_template(); 
        virtual ~selection_template(); 

        cproperty<std::string, selection_template> name; 
        void static set_name(std::string*, selection_template*); 
        void static get_name(std::string*, selection_template*);

        cproperty<std::string, selection_template> hash; 
        void static set_hash(std::string*, selection_template*); 
        void static get_hash(std::string*, selection_template*); 

        cproperty<std::string, selection_template> tree;  
        void static get_tree(std::string*, selection_template*); 

        cproperty<double, selection_template> weight;
        void static set_weight(double*, selection_template*); 
        void static get_weight(double*, selection_template*); 

        cproperty<long, selection_template> index; 
        void static set_index(long*, selection_template*); 
   
        virtual selection_template* clone(); 
        virtual bool selection(event_template* ev);
        virtual bool strategy(event_template* ev);
        virtual void merge(selection_template* sel); 
        virtual void bulk_write(const long* idx, std::string* hx); 

        template <typename g> 
        void write(g* var, std::string name)

        template <typename g> 
        void write(g var, std::string name)

        std::vector<std::map<std::string, float>> reverse_hash(std::vector<std::string>* hashes); 

        bool CompileEvent(); 
        selection_template* build(event_template* ev); 
        bool operator == (selection_template& p); 

        meta* meta_data = nullptr; 
        std::string filename = ""; 
        event_t data; 

        template <typename g, typename k>
        void sum(std::vector<g*>* ch, k** out)

        template <typename g>
        g* sum(std::map<std::string, g*>* ch)

        template <typename g>
        float sum(std::vector<g*>* ch)

        template <typename g>
        std::vector<g*> vectorize(std::map<std::string, g*>* in)

        template <typename g>
        std::vector<g*> make_unique(std::vector<g*>* inpt)

        template <typename g>
        void downcast(std::vector<g*>* inpt, std::vector<particle_template*>* out)

        template <typename o, typename g>
        void upcast(std::map<std::string, o*>* inpt, std::vector<g*>* out)

        template <typename o, typename g>
        void upcast(std::vector<o*>* inpt, std::vector<g*>* out)

        template <typename g>
        void get_leptonics(std::map<std::string, g*> inpt, std::vector<particle_template*>* out)

        template <typename g, typename j>
        bool contains(std::vector<g*>* inpt, j* pcheck)

        std::map<std::string, std::map<std::string, float>> passed_weights = {}; 
        std::map<std::string, meta_t> matched_meta = {}; 

    private:
        friend container;

        void bulk_write_out(); 
        void merger(selection_template* sl2); 

        std::unordered_map<long, std::string> sequence; 
        bool p_bulk_write = true; 
         
        write_t* handle = nullptr; 
        event_template* m_event = nullptr; 
        std::map<std::string, std::vector<particle_template*>> garbage = {}; 
}; 


#endif
